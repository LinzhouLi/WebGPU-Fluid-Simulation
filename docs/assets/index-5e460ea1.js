var ra=Object.defineProperty;var aa=(u,t,e)=>t in u?ra(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e;var T=(u,t,e)=>(aa(u,typeof t!="symbol"?t+"":t,e),e);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))i(s);new MutationObserver(s=>{for(const n of s)if(n.type==="childList")for(const r of n.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&i(r)}).observe(document,{childList:!0,subtree:!0});function e(s){const n={};return s.integrity&&(n.integrity=s.integrity),s.referrerpolicy&&(n.referrerPolicy=s.referrerpolicy),s.crossorigin==="use-credentials"?n.credentials="include":s.crossorigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function i(s){if(s.ep)return;s.ep=!0;const n=e(s);fetch(s.href,n)}})();var si=function(){var u=0,t=document.createElement("div");t.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",t.addEventListener("click",function(l){l.preventDefault(),i(++u%t.children.length)},!1);function e(l){return t.appendChild(l.dom),l}function i(l){for(var c=0;c<t.children.length;c++)t.children[c].style.display=c===l?"block":"none";u=l}var s=(performance||Date).now(),n=s,r=0,a=e(new si.Panel("FPS","#0ff","#002")),o=e(new si.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var h=e(new si.Panel("MB","#f08","#201"));return i(0),{REVISION:16,dom:t,addPanel:e,showPanel:i,begin:function(){s=(performance||Date).now()},end:function(){r++;var l=(performance||Date).now();if(o.update(l-s,200),l>n+1e3&&(a.update(r*1e3/(l-n),100),n=l,r=0,h)){var c=performance.memory;h.update(c.usedJSHeapSize/1048576,c.jsHeapSizeLimit/1048576)}return l},update:function(){s=this.end()},domElement:t,setMode:i}};si.Panel=function(u,t,e){var i=1/0,s=0,n=Math.round,r=n(window.devicePixelRatio||1),a=80*r,o=48*r,h=3*r,l=2*r,c=3*r,d=15*r,p=74*r,f=30*r,m=document.createElement("canvas");m.width=a,m.height=o,m.style.cssText="width:80px;height:48px";var g=m.getContext("2d");return g.font="bold "+9*r+"px Helvetica,Arial,sans-serif",g.textBaseline="top",g.fillStyle=e,g.fillRect(0,0,a,o),g.fillStyle=t,g.fillText(u,h,l),g.fillRect(c,d,p,f),g.fillStyle=e,g.globalAlpha=.9,g.fillRect(c,d,p,f),{dom:m,update:function(y,M){i=Math.min(i,y),s=Math.max(s,y),g.fillStyle=e,g.globalAlpha=1,g.fillRect(0,0,a,d),g.fillStyle=t,g.fillText(n(y)+" "+u+" ("+n(i)+"-"+n(s)+")",h,l),g.drawImage(m,c+r,d,p-r,f,c,d,p-r,f),g.fillRect(c+p-r,d,r,f),g.fillStyle=e,g.globalAlpha=.9,g.fillRect(c+p-r,d,r,n((1-y/M)*f))}}};/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const Mr="148",ye={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},xe={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},Wi=0,oa=1,ha=2,Sn=1,la=100,ca=204,ua=205,da=3,Ws=0,vr=300,pa=301,fa=303,ue=1e3,le=1001,Ls=1002,zs=1003,ma=1004,ga=1005,Xs=1006,ya=1007,qs=1008,xa=1009,ba=1015,Tr=1023,di=2300,Le=2301,es=2302,_n=2400,An=2401,En=2402,wa=2500,Ma=1,Sr=2,va=3e3,jt=3001,Ys=0,Gt="srgb",Bs="srgb-linear",is=7680,Ta=519,Ds=35044;class mi{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const i=this._listeners;i[t]===void 0&&(i[t]=[]),i[t].indexOf(e)===-1&&i[t].push(e)}hasEventListener(t,e){if(this._listeners===void 0)return!1;const i=this._listeners;return i[t]!==void 0&&i[t].indexOf(e)!==-1}removeEventListener(t,e){if(this._listeners===void 0)return;const s=this._listeners[t];if(s!==void 0){const n=s.indexOf(e);n!==-1&&s.splice(n,1)}}dispatchEvent(t){if(this._listeners===void 0)return;const i=this._listeners[t.type];if(i!==void 0){t.target=this;const s=i.slice(0);for(let n=0,r=s.length;n<r;n++)s[n].call(this,t);t.target=null}}}const et=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let Pn=1234567;const ni=Math.PI/180,pi=180/Math.PI;function _t(){const u=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,i=Math.random()*4294967295|0;return(et[u&255]+et[u>>8&255]+et[u>>16&255]+et[u>>24&255]+"-"+et[t&255]+et[t>>8&255]+"-"+et[t>>16&15|64]+et[t>>24&255]+"-"+et[e&63|128]+et[e>>8&255]+"-"+et[e>>16&255]+et[e>>24&255]+et[i&255]+et[i>>8&255]+et[i>>16&255]+et[i>>24&255]).toLowerCase()}function Q(u,t,e){return Math.max(t,Math.min(e,u))}function $s(u,t){return(u%t+t)%t}function Sa(u,t,e,i,s){return i+(u-t)*(s-i)/(e-t)}function _a(u,t,e){return u!==t?(e-u)/(t-u):0}function ri(u,t,e){return(1-e)*u+e*t}function Aa(u,t,e,i){return ri(u,t,1-Math.exp(-e*i))}function Ea(u,t=1){return t-Math.abs($s(u,t*2)-t)}function Pa(u,t,e){return u<=t?0:u>=e?1:(u=(u-t)/(e-t),u*u*(3-2*u))}function Ca(u,t,e){return u<=t?0:u>=e?1:(u=(u-t)/(e-t),u*u*u*(u*(u*6-15)+10))}function Ra(u,t){return u+Math.floor(Math.random()*(t-u+1))}function Fa(u,t){return u+Math.random()*(t-u)}function Ia(u){return u*(.5-Math.random())}function ka(u){u!==void 0&&(Pn=u);let t=Pn+=1831565813;return t=Math.imul(t^t>>>15,t|1),t^=t+Math.imul(t^t>>>7,t|61),((t^t>>>14)>>>0)/4294967296}function La(u){return u*ni}function za(u){return u*pi}function Ba(u){return(u&u-1)===0&&u!==0}function _r(u){return Math.pow(2,Math.ceil(Math.log(u)/Math.LN2))}function Da(u){return Math.pow(2,Math.floor(Math.log(u)/Math.LN2))}function Oa(u,t,e,i,s){const n=Math.cos,r=Math.sin,a=n(e/2),o=r(e/2),h=n((t+i)/2),l=r((t+i)/2),c=n((t-i)/2),d=r((t-i)/2),p=n((i-t)/2),f=r((i-t)/2);switch(s){case"XYX":u.set(a*l,o*c,o*d,a*h);break;case"YZY":u.set(o*d,a*l,o*c,a*h);break;case"ZXZ":u.set(o*c,o*d,a*l,a*h);break;case"XZX":u.set(a*l,o*f,o*p,a*h);break;case"YXY":u.set(o*p,a*l,o*f,a*h);break;case"ZYZ":u.set(o*f,o*p,a*l,a*h);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+s)}}function Ht(u,t){switch(t.constructor){case Float32Array:return u;case Uint16Array:return u/65535;case Uint8Array:return u/255;case Int16Array:return Math.max(u/32767,-1);case Int8Array:return Math.max(u/127,-1);default:throw new Error("Invalid component type.")}}function V(u,t){switch(t.constructor){case Float32Array:return u;case Uint16Array:return Math.round(u*65535);case Uint8Array:return Math.round(u*255);case Int16Array:return Math.round(u*32767);case Int8Array:return Math.round(u*127);default:throw new Error("Invalid component type.")}}var St=Object.freeze({__proto__:null,DEG2RAD:ni,RAD2DEG:pi,generateUUID:_t,clamp:Q,euclideanModulo:$s,mapLinear:Sa,inverseLerp:_a,lerp:ri,damp:Aa,pingpong:Ea,smoothstep:Pa,smootherstep:Ca,randInt:Ra,randFloat:Fa,randFloatSpread:Ia,seededRandom:ka,degToRad:La,radToDeg:za,isPowerOfTwo:Ba,ceilPowerOfTwo:_r,floorPowerOfTwo:Da,setQuaternionFromProperEuler:Oa,normalize:V,denormalize:Ht});class L{constructor(t=0,e=0){L.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,i=this.y,s=t.elements;return this.x=s[0]*e+s[3]*i+s[6],this.y=s[1]*e+s[4]*i+s[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y;return e*e+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const i=Math.cos(e),s=Math.sin(e),n=this.x-t.x,r=this.y-t.y;return this.x=n*i-r*s+t.x,this.y=n*s+r*i+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class ne{constructor(){ne.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1]}set(t,e,i,s,n,r,a,o,h){const l=this.elements;return l[0]=t,l[1]=s,l[2]=a,l[3]=e,l[4]=n,l[5]=o,l[6]=i,l[7]=r,l[8]=h,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],this}extractBasis(t,e,i){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const i=t.elements,s=e.elements,n=this.elements,r=i[0],a=i[3],o=i[6],h=i[1],l=i[4],c=i[7],d=i[2],p=i[5],f=i[8],m=s[0],g=s[3],y=s[6],M=s[1],w=s[4],S=s[7],v=s[2],_=s[5],A=s[8];return n[0]=r*m+a*M+o*v,n[3]=r*g+a*w+o*_,n[6]=r*y+a*S+o*A,n[1]=h*m+l*M+c*v,n[4]=h*g+l*w+c*_,n[7]=h*y+l*S+c*A,n[2]=d*m+p*M+f*v,n[5]=d*g+p*w+f*_,n[8]=d*y+p*S+f*A,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],i=t[1],s=t[2],n=t[3],r=t[4],a=t[5],o=t[6],h=t[7],l=t[8];return e*r*l-e*a*h-i*n*l+i*a*o+s*n*h-s*r*o}invert(){const t=this.elements,e=t[0],i=t[1],s=t[2],n=t[3],r=t[4],a=t[5],o=t[6],h=t[7],l=t[8],c=l*r-a*h,d=a*o-l*n,p=h*n-r*o,f=e*c+i*d+s*p;if(f===0)return this.set(0,0,0,0,0,0,0,0,0);const m=1/f;return t[0]=c*m,t[1]=(s*h-l*i)*m,t[2]=(a*i-s*r)*m,t[3]=d*m,t[4]=(l*e-s*o)*m,t[5]=(s*n-a*e)*m,t[6]=p*m,t[7]=(i*o-h*e)*m,t[8]=(r*e-i*n)*m,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,i,s,n,r,a){const o=Math.cos(n),h=Math.sin(n);return this.set(i*o,i*h,-i*(o*r+h*a)+r+t,-s*h,s*o,-s*(-h*r+o*a)+a+e,0,0,1),this}scale(t,e){return this.premultiply(ss.makeScale(t,e)),this}rotate(t){return this.premultiply(ss.makeRotation(-t)),this}translate(t,e){return this.premultiply(ss.makeTranslation(t,e)),this}makeTranslation(t,e){return this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,-i,0,i,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,i=t.elements;for(let s=0;s<9;s++)if(e[s]!==i[s])return!1;return!0}fromArray(t,e=0){for(let i=0;i<9;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){const i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t}clone(){return new this.constructor().fromArray(this.elements)}}const ss=new ne;function Na(u){for(let t=u.length-1;t>=0;--t)if(u[t]>=65535)return!0;return!1}function Os(u){return document.createElementNS("http://www.w3.org/1999/xhtml",u)}function ce(u){return u<.04045?u*.0773993808:Math.pow(u*.9478672986+.0521327014,2.4)}function Hi(u){return u<.0031308?u*12.92:1.055*Math.pow(u,.41666)-.055}const ns={[Gt]:{[Bs]:ce},[Bs]:{[Gt]:Hi}},st={legacyMode:!0,get workingColorSpace(){return Bs},set workingColorSpace(u){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(u,t,e){if(this.legacyMode||t===e||!t||!e)return u;if(ns[t]&&ns[t][e]!==void 0){const i=ns[t][e];return u.r=i(u.r),u.g=i(u.g),u.b=i(u.b),u}throw new Error("Unsupported color space conversion.")},fromWorkingColorSpace:function(u,t){return this.convert(u,this.workingColorSpace,t)},toWorkingColorSpace:function(u,t){return this.convert(u,t,this.workingColorSpace)}},Ar={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},$={r:0,g:0,b:0},wt={h:0,s:0,l:0},vi={h:0,s:0,l:0};function rs(u,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?u+(t-u)*6*e:e<1/2?t:e<2/3?u+(t-u)*6*(2/3-e):u}function Ti(u,t){return t.r=u.r,t.g=u.g,t.b=u.b,t}class U{constructor(t,e,i){return this.isColor=!0,this.r=1,this.g=1,this.b=1,e===void 0&&i===void 0?this.set(t):this.setRGB(t,e,i)}set(t){return t&&t.isColor?this.copy(t):typeof t=="number"?this.setHex(t):typeof t=="string"&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e=Gt){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,st.toWorkingColorSpace(this,e),this}setRGB(t,e,i,s=st.workingColorSpace){return this.r=t,this.g=e,this.b=i,st.toWorkingColorSpace(this,s),this}setHSL(t,e,i,s=st.workingColorSpace){if(t=$s(t,1),e=Q(e,0,1),i=Q(i,0,1),e===0)this.r=this.g=this.b=i;else{const n=i<=.5?i*(1+e):i+e-i*e,r=2*i-n;this.r=rs(r,n,t+1/3),this.g=rs(r,n,t),this.b=rs(r,n,t-1/3)}return st.toWorkingColorSpace(this,s),this}setStyle(t,e=Gt){function i(n){n!==void 0&&parseFloat(n)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let s;if(s=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let n;const r=s[1],a=s[2];switch(r){case"rgb":case"rgba":if(n=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(255,parseInt(n[1],10))/255,this.g=Math.min(255,parseInt(n[2],10))/255,this.b=Math.min(255,parseInt(n[3],10))/255,st.toWorkingColorSpace(this,e),i(n[4]),this;if(n=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(100,parseInt(n[1],10))/100,this.g=Math.min(100,parseInt(n[2],10))/100,this.b=Math.min(100,parseInt(n[3],10))/100,st.toWorkingColorSpace(this,e),i(n[4]),this;break;case"hsl":case"hsla":if(n=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)){const o=parseFloat(n[1])/360,h=parseFloat(n[2])/100,l=parseFloat(n[3])/100;return i(n[4]),this.setHSL(o,h,l,e)}break}}else if(s=/^\#([A-Fa-f\d]+)$/.exec(t)){const n=s[1],r=n.length;if(r===3)return this.r=parseInt(n.charAt(0)+n.charAt(0),16)/255,this.g=parseInt(n.charAt(1)+n.charAt(1),16)/255,this.b=parseInt(n.charAt(2)+n.charAt(2),16)/255,st.toWorkingColorSpace(this,e),this;if(r===6)return this.r=parseInt(n.charAt(0)+n.charAt(1),16)/255,this.g=parseInt(n.charAt(2)+n.charAt(3),16)/255,this.b=parseInt(n.charAt(4)+n.charAt(5),16)/255,st.toWorkingColorSpace(this,e),this}return t&&t.length>0?this.setColorName(t,e):this}setColorName(t,e=Gt){const i=Ar[t.toLowerCase()];return i!==void 0?this.setHex(i,e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=ce(t.r),this.g=ce(t.g),this.b=ce(t.b),this}copyLinearToSRGB(t){return this.r=Hi(t.r),this.g=Hi(t.g),this.b=Hi(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=Gt){return st.fromWorkingColorSpace(Ti(this,$),t),Q($.r*255,0,255)<<16^Q($.g*255,0,255)<<8^Q($.b*255,0,255)<<0}getHexString(t=Gt){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e=st.workingColorSpace){st.fromWorkingColorSpace(Ti(this,$),e);const i=$.r,s=$.g,n=$.b,r=Math.max(i,s,n),a=Math.min(i,s,n);let o,h;const l=(a+r)/2;if(a===r)o=0,h=0;else{const c=r-a;switch(h=l<=.5?c/(r+a):c/(2-r-a),r){case i:o=(s-n)/c+(s<n?6:0);break;case s:o=(n-i)/c+2;break;case n:o=(i-s)/c+4;break}o/=6}return t.h=o,t.s=h,t.l=l,t}getRGB(t,e=st.workingColorSpace){return st.fromWorkingColorSpace(Ti(this,$),e),t.r=$.r,t.g=$.g,t.b=$.b,t}getStyle(t=Gt){return st.fromWorkingColorSpace(Ti(this,$),t),t!==Gt?`color(${t} ${$.r} ${$.g} ${$.b})`:`rgb(${$.r*255|0},${$.g*255|0},${$.b*255|0})`}offsetHSL(t,e,i){return this.getHSL(wt),wt.h+=t,wt.s+=e,wt.l+=i,this.setHSL(wt.h,wt.s,wt.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,i){return this.r=t.r+(e.r-t.r)*i,this.g=t.g+(e.g-t.g)*i,this.b=t.b+(e.b-t.b)*i,this}lerpHSL(t,e){this.getHSL(wt),t.getHSL(vi);const i=ri(wt.h,vi.h,e),s=ri(wt.s,vi.s,e),n=ri(wt.l,vi.l,e);return this.setHSL(i,s,n),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}U.NAMES=Ar;let be;class Ua{static getDataURL(t){if(/^data:/i.test(t.src)||typeof HTMLCanvasElement>"u")return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{be===void 0&&(be=Os("canvas")),be.width=t.width,be.height=t.height;const i=be.getContext("2d");t instanceof ImageData?i.putImageData(t,0,0):i.drawImage(t,0,0,t.width,t.height),e=be}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}static sRGBToLinear(t){if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&t instanceof ImageBitmap){const e=Os("canvas");e.width=t.width,e.height=t.height;const i=e.getContext("2d");i.drawImage(t,0,0,t.width,t.height);const s=i.getImageData(0,0,t.width,t.height),n=s.data;for(let r=0;r<n.length;r++)n[r]=ce(n[r]/255)*255;return i.putImageData(s,0,0),e}else if(t.data){const e=t.data.slice(0);for(let i=0;i<e.length;i++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[i]=Math.floor(ce(e[i]/255)*255):e[i]=ce(e[i]);return{data:e,width:t.width,height:t.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}class Ga{constructor(t=null){this.isSource=!0,this.uuid=_t(),this.data=t,this.version=0}set needsUpdate(t){t===!0&&this.version++}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.images[this.uuid]!==void 0)return t.images[this.uuid];const i={uuid:this.uuid,url:""},s=this.data;if(s!==null){let n;if(Array.isArray(s)){n=[];for(let r=0,a=s.length;r<a;r++)s[r].isDataTexture?n.push(as(s[r].image)):n.push(as(s[r]))}else n=as(s);i.url=n}return e||(t.images[this.uuid]=i),i}}function as(u){return typeof HTMLImageElement<"u"&&u instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&u instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&u instanceof ImageBitmap?Ua.getDataURL(u):u.data?{data:Array.from(u.data),width:u.width,height:u.height,type:u.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let Va=0;class ht extends mi{constructor(t=ht.DEFAULT_IMAGE,e=ht.DEFAULT_MAPPING,i=le,s=le,n=Xs,r=qs,a=Tr,o=xa,h=ht.DEFAULT_ANISOTROPY,l=va){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:Va++}),this.uuid=_t(),this.name="",this.source=new Ga(t),this.mipmaps=[],this.mapping=e,this.wrapS=i,this.wrapT=s,this.magFilter=n,this.minFilter=r,this.anisotropy=h,this.format=a,this.internalFormat=null,this.type=o,this.offset=new L(0,0),this.repeat=new L(1,1),this.center=new L(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new ne,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=l,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(t){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const i={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(i.userData=this.userData),e||(t.textures[this.uuid]=i),i}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==vr)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case ue:t.x=t.x-Math.floor(t.x);break;case le:t.x=t.x<0?0:1;break;case Ls:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x);break}if(t.y<0||t.y>1)switch(this.wrapT){case ue:t.y=t.y-Math.floor(t.y);break;case le:t.y=t.y<0?0:1;break;case Ls:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y);break}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&(this.version++,this.source.needsUpdate=!0)}}ht.DEFAULT_IMAGE=null;ht.DEFAULT_MAPPING=vr;ht.DEFAULT_ANISOTROPY=1;class it{constructor(t=0,e=0,i=0,s=1){it.prototype.isVector4=!0,this.x=t,this.y=e,this.z=i,this.w=s}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,i,s){return this.x=t,this.y=e,this.z=i,this.w=s,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,i=this.y,s=this.z,n=this.w,r=t.elements;return this.x=r[0]*e+r[4]*i+r[8]*s+r[12]*n,this.y=r[1]*e+r[5]*i+r[9]*s+r[13]*n,this.z=r[2]*e+r[6]*i+r[10]*s+r[14]*n,this.w=r[3]*e+r[7]*i+r[11]*s+r[15]*n,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,i,s,n;const o=t.elements,h=o[0],l=o[4],c=o[8],d=o[1],p=o[5],f=o[9],m=o[2],g=o[6],y=o[10];if(Math.abs(l-d)<.01&&Math.abs(c-m)<.01&&Math.abs(f-g)<.01){if(Math.abs(l+d)<.1&&Math.abs(c+m)<.1&&Math.abs(f+g)<.1&&Math.abs(h+p+y-3)<.1)return this.set(1,0,0,0),this;e=Math.PI;const w=(h+1)/2,S=(p+1)/2,v=(y+1)/2,_=(l+d)/4,A=(c+m)/4,R=(f+g)/4;return w>S&&w>v?w<.01?(i=0,s=.707106781,n=.707106781):(i=Math.sqrt(w),s=_/i,n=A/i):S>v?S<.01?(i=.707106781,s=0,n=.707106781):(s=Math.sqrt(S),i=_/s,n=R/s):v<.01?(i=.707106781,s=.707106781,n=0):(n=Math.sqrt(v),i=A/n,s=R/n),this.set(i,s,n,e),this}let M=Math.sqrt((g-f)*(g-f)+(c-m)*(c-m)+(d-l)*(d-l));return Math.abs(M)<.001&&(M=1),this.x=(g-f)/M,this.y=(c-m)/M,this.z=(d-l)/M,this.w=Math.acos((h+p+y-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this.w=t.w+(e.w-t.w)*i,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class ot{constructor(t=0,e=0,i=0,s=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=i,this._w=s}static slerpFlat(t,e,i,s,n,r,a){let o=i[s+0],h=i[s+1],l=i[s+2],c=i[s+3];const d=n[r+0],p=n[r+1],f=n[r+2],m=n[r+3];if(a===0){t[e+0]=o,t[e+1]=h,t[e+2]=l,t[e+3]=c;return}if(a===1){t[e+0]=d,t[e+1]=p,t[e+2]=f,t[e+3]=m;return}if(c!==m||o!==d||h!==p||l!==f){let g=1-a;const y=o*d+h*p+l*f+c*m,M=y>=0?1:-1,w=1-y*y;if(w>Number.EPSILON){const v=Math.sqrt(w),_=Math.atan2(v,y*M);g=Math.sin(g*_)/v,a=Math.sin(a*_)/v}const S=a*M;if(o=o*g+d*S,h=h*g+p*S,l=l*g+f*S,c=c*g+m*S,g===1-a){const v=1/Math.sqrt(o*o+h*h+l*l+c*c);o*=v,h*=v,l*=v,c*=v}}t[e]=o,t[e+1]=h,t[e+2]=l,t[e+3]=c}static multiplyQuaternionsFlat(t,e,i,s,n,r){const a=i[s],o=i[s+1],h=i[s+2],l=i[s+3],c=n[r],d=n[r+1],p=n[r+2],f=n[r+3];return t[e]=a*f+l*c+o*p-h*d,t[e+1]=o*f+l*d+h*c-a*p,t[e+2]=h*f+l*p+a*d-o*c,t[e+3]=l*f-a*c-o*d-h*p,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,i,s){return this._x=t,this._y=e,this._z=i,this._w=s,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){const i=t._x,s=t._y,n=t._z,r=t._order,a=Math.cos,o=Math.sin,h=a(i/2),l=a(s/2),c=a(n/2),d=o(i/2),p=o(s/2),f=o(n/2);switch(r){case"XYZ":this._x=d*l*c+h*p*f,this._y=h*p*c-d*l*f,this._z=h*l*f+d*p*c,this._w=h*l*c-d*p*f;break;case"YXZ":this._x=d*l*c+h*p*f,this._y=h*p*c-d*l*f,this._z=h*l*f-d*p*c,this._w=h*l*c+d*p*f;break;case"ZXY":this._x=d*l*c-h*p*f,this._y=h*p*c+d*l*f,this._z=h*l*f+d*p*c,this._w=h*l*c-d*p*f;break;case"ZYX":this._x=d*l*c-h*p*f,this._y=h*p*c+d*l*f,this._z=h*l*f-d*p*c,this._w=h*l*c+d*p*f;break;case"YZX":this._x=d*l*c+h*p*f,this._y=h*p*c+d*l*f,this._z=h*l*f-d*p*c,this._w=h*l*c-d*p*f;break;case"XZY":this._x=d*l*c-h*p*f,this._y=h*p*c-d*l*f,this._z=h*l*f+d*p*c,this._w=h*l*c+d*p*f;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+r)}return e!==!1&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const i=e/2,s=Math.sin(i);return this._x=t.x*s,this._y=t.y*s,this._z=t.z*s,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,i=e[0],s=e[4],n=e[8],r=e[1],a=e[5],o=e[9],h=e[2],l=e[6],c=e[10],d=i+a+c;if(d>0){const p=.5/Math.sqrt(d+1);this._w=.25/p,this._x=(l-o)*p,this._y=(n-h)*p,this._z=(r-s)*p}else if(i>a&&i>c){const p=2*Math.sqrt(1+i-a-c);this._w=(l-o)/p,this._x=.25*p,this._y=(s+r)/p,this._z=(n+h)/p}else if(a>c){const p=2*Math.sqrt(1+a-i-c);this._w=(n-h)/p,this._x=(s+r)/p,this._y=.25*p,this._z=(o+l)/p}else{const p=2*Math.sqrt(1+c-i-a);this._w=(r-s)/p,this._x=(n+h)/p,this._y=(o+l)/p,this._z=.25*p}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let i=t.dot(e)+1;return i<Number.EPSILON?(i=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=i):(this._x=0,this._y=-t.z,this._z=t.y,this._w=i)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=i),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(Q(this.dot(t),-1,1)))}rotateTowards(t,e){const i=this.angleTo(t);if(i===0)return this;const s=Math.min(1,e/i);return this.slerp(t,s),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const i=t._x,s=t._y,n=t._z,r=t._w,a=e._x,o=e._y,h=e._z,l=e._w;return this._x=i*l+r*a+s*h-n*o,this._y=s*l+r*o+n*a-i*h,this._z=n*l+r*h+i*o-s*a,this._w=r*l-i*a-s*o-n*h,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const i=this._x,s=this._y,n=this._z,r=this._w;let a=r*t._w+i*t._x+s*t._y+n*t._z;if(a<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,a=-a):this.copy(t),a>=1)return this._w=r,this._x=i,this._y=s,this._z=n,this;const o=1-a*a;if(o<=Number.EPSILON){const p=1-e;return this._w=p*r+e*this._w,this._x=p*i+e*this._x,this._y=p*s+e*this._y,this._z=p*n+e*this._z,this.normalize(),this._onChangeCallback(),this}const h=Math.sqrt(o),l=Math.atan2(h,a),c=Math.sin((1-e)*l)/h,d=Math.sin(e*l)/h;return this._w=r*c+this._w*d,this._x=i*c+this._x*d,this._y=s*c+this._y*d,this._z=n*c+this._z*d,this._onChangeCallback(),this}slerpQuaternions(t,e,i){return this.copy(t).slerp(e,i)}random(){const t=Math.random(),e=Math.sqrt(1-t),i=Math.sqrt(t),s=2*Math.PI*Math.random(),n=2*Math.PI*Math.random();return this.set(e*Math.cos(s),i*Math.sin(n),i*Math.cos(n),e*Math.sin(s))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class x{constructor(t=0,e=0,i=0){x.prototype.isVector3=!0,this.x=t,this.y=e,this.z=i}set(t,e,i){return i===void 0&&(i=this.z),this.x=t,this.y=e,this.z=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return this.applyQuaternion(Cn.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(Cn.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,i=this.y,s=this.z,n=t.elements;return this.x=n[0]*e+n[3]*i+n[6]*s,this.y=n[1]*e+n[4]*i+n[7]*s,this.z=n[2]*e+n[5]*i+n[8]*s,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,i=this.y,s=this.z,n=t.elements,r=1/(n[3]*e+n[7]*i+n[11]*s+n[15]);return this.x=(n[0]*e+n[4]*i+n[8]*s+n[12])*r,this.y=(n[1]*e+n[5]*i+n[9]*s+n[13])*r,this.z=(n[2]*e+n[6]*i+n[10]*s+n[14])*r,this}applyQuaternion(t){const e=this.x,i=this.y,s=this.z,n=t.x,r=t.y,a=t.z,o=t.w,h=o*e+r*s-a*i,l=o*i+a*e-n*s,c=o*s+n*i-r*e,d=-n*e-r*i-a*s;return this.x=h*o+d*-n+l*-a-c*-r,this.y=l*o+d*-r+c*-n-h*-a,this.z=c*o+d*-a+h*-r-l*-n,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,i=this.y,s=this.z,n=t.elements;return this.x=n[0]*e+n[4]*i+n[8]*s,this.y=n[1]*e+n[5]*i+n[9]*s,this.z=n[2]*e+n[6]*i+n[10]*s,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,e){const i=t.x,s=t.y,n=t.z,r=e.x,a=e.y,o=e.z;return this.x=s*o-n*a,this.y=n*r-i*o,this.z=i*a-s*r,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const i=t.dot(this)/e;return this.copy(t).multiplyScalar(i)}projectOnPlane(t){return os.copy(this).projectOnVector(t),this.sub(os)}reflect(t){return this.sub(os.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const i=this.dot(t)/e;return Math.acos(Q(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y,s=this.z-t.z;return e*e+i*i+s*s}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,i){const s=Math.sin(e)*t;return this.x=s*Math.sin(i),this.y=Math.cos(e)*t,this.z=s*Math.cos(i),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,i){return this.x=t*Math.sin(e),this.y=i,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),i=this.setFromMatrixColumn(t,1).length(),s=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=i,this.z=s,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,e*4)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,e*3)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=(Math.random()-.5)*2,e=Math.random()*Math.PI*2,i=Math.sqrt(1-t**2);return this.x=i*Math.cos(e),this.y=i*Math.sin(e),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const os=new x,Cn=new ot;class Oe{constructor(t=new x(1/0,1/0,1/0),e=new x(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,i=1/0,s=1/0,n=-1/0,r=-1/0,a=-1/0;for(let o=0,h=t.length;o<h;o+=3){const l=t[o],c=t[o+1],d=t[o+2];l<e&&(e=l),c<i&&(i=c),d<s&&(s=d),l>n&&(n=l),c>r&&(r=c),d>a&&(a=d)}return this.min.set(e,i,s),this.max.set(n,r,a),this}setFromBufferAttribute(t){let e=1/0,i=1/0,s=1/0,n=-1/0,r=-1/0,a=-1/0;for(let o=0,h=t.count;o<h;o++){const l=t.getX(o),c=t.getY(o),d=t.getZ(o);l<e&&(e=l),c<i&&(i=c),d<s&&(s=d),l>n&&(n=l),c>r&&(r=c),d>a&&(a=d)}return this.min.set(e,i,s),this.max.set(n,r,a),this}setFromPoints(t){this.makeEmpty();for(let e=0,i=t.length;e<i;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const i=ae.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(i),this.max.copy(t).add(i),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);const i=t.geometry;if(i!==void 0)if(e&&i.attributes!=null&&i.attributes.position!==void 0){const n=i.attributes.position;for(let r=0,a=n.count;r<a;r++)ae.fromBufferAttribute(n,r).applyMatrix4(t.matrixWorld),this.expandByPoint(ae)}else i.boundingBox===null&&i.computeBoundingBox(),hs.copy(i.boundingBox),hs.applyMatrix4(t.matrixWorld),this.union(hs);const s=t.children;for(let n=0,r=s.length;n<r;n++)this.expandByObject(s[n],e);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,ae),ae.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,i;return t.normal.x>0?(e=t.normal.x*this.min.x,i=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,i=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,i+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,i+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,i+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,i+=t.normal.z*this.min.z),e<=-t.constant&&i>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(Xe),Si.subVectors(this.max,Xe),we.subVectors(t.a,Xe),Me.subVectors(t.b,Xe),ve.subVectors(t.c,Xe),Xt.subVectors(Me,we),qt.subVectors(ve,Me),oe.subVectors(we,ve);let e=[0,-Xt.z,Xt.y,0,-qt.z,qt.y,0,-oe.z,oe.y,Xt.z,0,-Xt.x,qt.z,0,-qt.x,oe.z,0,-oe.x,-Xt.y,Xt.x,0,-qt.y,qt.x,0,-oe.y,oe.x,0];return!ls(e,we,Me,ve,Si)||(e=[1,0,0,0,1,0,0,0,1],!ls(e,we,Me,ve,Si))?!1:(_i.crossVectors(Xt,qt),e=[_i.x,_i.y,_i.z],ls(e,we,Me,ve,Si))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return ae.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return this.getCenter(t.center),t.radius=this.getSize(ae).length()*.5,t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:(zt[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),zt[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),zt[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),zt[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),zt[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),zt[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),zt[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),zt[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(zt),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const zt=[new x,new x,new x,new x,new x,new x,new x,new x],ae=new x,hs=new Oe,we=new x,Me=new x,ve=new x,Xt=new x,qt=new x,oe=new x,Xe=new x,Si=new x,_i=new x,he=new x;function ls(u,t,e,i,s){for(let n=0,r=u.length-3;n<=r;n+=3){he.fromArray(u,n);const a=s.x*Math.abs(he.x)+s.y*Math.abs(he.y)+s.z*Math.abs(he.z),o=t.dot(he),h=e.dot(he),l=i.dot(he);if(Math.max(-Math.max(o,h,l),Math.min(o,h,l))>a)return!1}return!0}const ja=new Oe,qe=new x,cs=new x;class Ne{constructor(t=new x,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const i=this.center;e!==void 0?i.copy(e):ja.setFromPoints(t).getCenter(i);let s=0;for(let n=0,r=t.length;n<r;n++)s=Math.max(s,i.distanceToSquared(t[n]));return this.radius=Math.sqrt(s),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const i=this.center.distanceToSquared(t);return e.copy(t),i>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){if(this.isEmpty())return this.center.copy(t),this.radius=0,this;qe.subVectors(t,this.center);const e=qe.lengthSq();if(e>this.radius*this.radius){const i=Math.sqrt(e),s=(i-this.radius)*.5;this.center.addScaledVector(qe,s/i),this.radius+=s}return this}union(t){return t.isEmpty()?this:this.isEmpty()?(this.copy(t),this):(this.center.equals(t.center)===!0?this.radius=Math.max(this.radius,t.radius):(cs.subVectors(t.center,this.center).setLength(t.radius),this.expandByPoint(qe.copy(t.center).add(cs)),this.expandByPoint(qe.copy(t.center).sub(cs))),this)}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}}const Bt=new x,us=new x,Ai=new x,Yt=new x,ds=new x,Ei=new x,ps=new x;class Ks{constructor(t=new x,e=new x(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,Bt)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const i=e.dot(this.direction);return i<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(i).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=Bt.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(Bt.copy(this.direction).multiplyScalar(e).add(this.origin),Bt.distanceToSquared(t))}distanceSqToSegment(t,e,i,s){us.copy(t).add(e).multiplyScalar(.5),Ai.copy(e).sub(t).normalize(),Yt.copy(this.origin).sub(us);const n=t.distanceTo(e)*.5,r=-this.direction.dot(Ai),a=Yt.dot(this.direction),o=-Yt.dot(Ai),h=Yt.lengthSq(),l=Math.abs(1-r*r);let c,d,p,f;if(l>0)if(c=r*o-a,d=r*a-o,f=n*l,c>=0)if(d>=-f)if(d<=f){const m=1/l;c*=m,d*=m,p=c*(c+r*d+2*a)+d*(r*c+d+2*o)+h}else d=n,c=Math.max(0,-(r*d+a)),p=-c*c+d*(d+2*o)+h;else d=-n,c=Math.max(0,-(r*d+a)),p=-c*c+d*(d+2*o)+h;else d<=-f?(c=Math.max(0,-(-r*n+a)),d=c>0?-n:Math.min(Math.max(-n,-o),n),p=-c*c+d*(d+2*o)+h):d<=f?(c=0,d=Math.min(Math.max(-n,-o),n),p=d*(d+2*o)+h):(c=Math.max(0,-(r*n+a)),d=c>0?n:Math.min(Math.max(-n,-o),n),p=-c*c+d*(d+2*o)+h);else d=r>0?-n:n,c=Math.max(0,-(r*d+a)),p=-c*c+d*(d+2*o)+h;return i&&i.copy(this.direction).multiplyScalar(c).add(this.origin),s&&s.copy(Ai).multiplyScalar(d).add(us),p}intersectSphere(t,e){Bt.subVectors(t.center,this.origin);const i=Bt.dot(this.direction),s=Bt.dot(Bt)-i*i,n=t.radius*t.radius;if(s>n)return null;const r=Math.sqrt(n-s),a=i-r,o=i+r;return a<0&&o<0?null:a<0?this.at(o,e):this.at(a,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(e===0)return t.distanceToPoint(this.origin)===0?0:null;const i=-(this.origin.dot(t.normal)+t.constant)/e;return i>=0?i:null}intersectPlane(t,e){const i=this.distanceToPlane(t);return i===null?null:this.at(i,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let i,s,n,r,a,o;const h=1/this.direction.x,l=1/this.direction.y,c=1/this.direction.z,d=this.origin;return h>=0?(i=(t.min.x-d.x)*h,s=(t.max.x-d.x)*h):(i=(t.max.x-d.x)*h,s=(t.min.x-d.x)*h),l>=0?(n=(t.min.y-d.y)*l,r=(t.max.y-d.y)*l):(n=(t.max.y-d.y)*l,r=(t.min.y-d.y)*l),i>r||n>s||((n>i||isNaN(i))&&(i=n),(r<s||isNaN(s))&&(s=r),c>=0?(a=(t.min.z-d.z)*c,o=(t.max.z-d.z)*c):(a=(t.max.z-d.z)*c,o=(t.min.z-d.z)*c),i>o||a>s)||((a>i||i!==i)&&(i=a),(o<s||s!==s)&&(s=o),s<0)?null:this.at(i>=0?i:s,e)}intersectsBox(t){return this.intersectBox(t,Bt)!==null}intersectTriangle(t,e,i,s,n){ds.subVectors(e,t),Ei.subVectors(i,t),ps.crossVectors(ds,Ei);let r=this.direction.dot(ps),a;if(r>0){if(s)return null;a=1}else if(r<0)a=-1,r=-r;else return null;Yt.subVectors(this.origin,t);const o=a*this.direction.dot(Ei.crossVectors(Yt,Ei));if(o<0)return null;const h=a*this.direction.dot(ds.cross(Yt));if(h<0||o+h>r)return null;const l=-a*Yt.dot(ps);return l<0?null:this.at(l/r,n)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class P{constructor(){P.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}set(t,e,i,s,n,r,a,o,h,l,c,d,p,f,m,g){const y=this.elements;return y[0]=t,y[4]=e,y[8]=i,y[12]=s,y[1]=n,y[5]=r,y[9]=a,y[13]=o,y[2]=h,y[6]=l,y[10]=c,y[14]=d,y[3]=p,y[7]=f,y[11]=m,y[15]=g,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new P().fromArray(this.elements)}copy(t){const e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],e[9]=i[9],e[10]=i[10],e[11]=i[11],e[12]=i[12],e[13]=i[13],e[14]=i[14],e[15]=i[15],this}copyPosition(t){const e=this.elements,i=t.elements;return e[12]=i[12],e[13]=i[13],e[14]=i[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,i){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(t,e,i){return this.set(t.x,e.x,i.x,0,t.y,e.y,i.y,0,t.z,e.z,i.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,i=t.elements,s=1/Te.setFromMatrixColumn(t,0).length(),n=1/Te.setFromMatrixColumn(t,1).length(),r=1/Te.setFromMatrixColumn(t,2).length();return e[0]=i[0]*s,e[1]=i[1]*s,e[2]=i[2]*s,e[3]=0,e[4]=i[4]*n,e[5]=i[5]*n,e[6]=i[6]*n,e[7]=0,e[8]=i[8]*r,e[9]=i[9]*r,e[10]=i[10]*r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){const e=this.elements,i=t.x,s=t.y,n=t.z,r=Math.cos(i),a=Math.sin(i),o=Math.cos(s),h=Math.sin(s),l=Math.cos(n),c=Math.sin(n);if(t.order==="XYZ"){const d=r*l,p=r*c,f=a*l,m=a*c;e[0]=o*l,e[4]=-o*c,e[8]=h,e[1]=p+f*h,e[5]=d-m*h,e[9]=-a*o,e[2]=m-d*h,e[6]=f+p*h,e[10]=r*o}else if(t.order==="YXZ"){const d=o*l,p=o*c,f=h*l,m=h*c;e[0]=d+m*a,e[4]=f*a-p,e[8]=r*h,e[1]=r*c,e[5]=r*l,e[9]=-a,e[2]=p*a-f,e[6]=m+d*a,e[10]=r*o}else if(t.order==="ZXY"){const d=o*l,p=o*c,f=h*l,m=h*c;e[0]=d-m*a,e[4]=-r*c,e[8]=f+p*a,e[1]=p+f*a,e[5]=r*l,e[9]=m-d*a,e[2]=-r*h,e[6]=a,e[10]=r*o}else if(t.order==="ZYX"){const d=r*l,p=r*c,f=a*l,m=a*c;e[0]=o*l,e[4]=f*h-p,e[8]=d*h+m,e[1]=o*c,e[5]=m*h+d,e[9]=p*h-f,e[2]=-h,e[6]=a*o,e[10]=r*o}else if(t.order==="YZX"){const d=r*o,p=r*h,f=a*o,m=a*h;e[0]=o*l,e[4]=m-d*c,e[8]=f*c+p,e[1]=c,e[5]=r*l,e[9]=-a*l,e[2]=-h*l,e[6]=p*c+f,e[10]=d-m*c}else if(t.order==="XZY"){const d=r*o,p=r*h,f=a*o,m=a*h;e[0]=o*l,e[4]=-c,e[8]=h*l,e[1]=d*c+m,e[5]=r*l,e[9]=p*c-f,e[2]=f*c-p,e[6]=a*l,e[10]=m*c+d}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(Ha,t,Wa)}lookAt(t,e,i){const s=this.elements;return ct.subVectors(t,e),ct.lengthSq()===0&&(ct.z=1),ct.normalize(),$t.crossVectors(i,ct),$t.lengthSq()===0&&(Math.abs(i.z)===1?ct.x+=1e-4:ct.z+=1e-4,ct.normalize(),$t.crossVectors(i,ct)),$t.normalize(),Pi.crossVectors(ct,$t),s[0]=$t.x,s[4]=Pi.x,s[8]=ct.x,s[1]=$t.y,s[5]=Pi.y,s[9]=ct.y,s[2]=$t.z,s[6]=Pi.z,s[10]=ct.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const i=t.elements,s=e.elements,n=this.elements,r=i[0],a=i[4],o=i[8],h=i[12],l=i[1],c=i[5],d=i[9],p=i[13],f=i[2],m=i[6],g=i[10],y=i[14],M=i[3],w=i[7],S=i[11],v=i[15],_=s[0],A=s[4],R=s[8],G=s[12],C=s[1],O=s[5],z=s[9],I=s[13],X=s[2],N=s[6],W=s[10],Et=s[14],xt=s[3],Pt=s[7],lt=s[11],It=s[15];return n[0]=r*_+a*C+o*X+h*xt,n[4]=r*A+a*O+o*N+h*Pt,n[8]=r*R+a*z+o*W+h*lt,n[12]=r*G+a*I+o*Et+h*It,n[1]=l*_+c*C+d*X+p*xt,n[5]=l*A+c*O+d*N+p*Pt,n[9]=l*R+c*z+d*W+p*lt,n[13]=l*G+c*I+d*Et+p*It,n[2]=f*_+m*C+g*X+y*xt,n[6]=f*A+m*O+g*N+y*Pt,n[10]=f*R+m*z+g*W+y*lt,n[14]=f*G+m*I+g*Et+y*It,n[3]=M*_+w*C+S*X+v*xt,n[7]=M*A+w*O+S*N+v*Pt,n[11]=M*R+w*z+S*W+v*lt,n[15]=M*G+w*I+S*Et+v*It,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],i=t[4],s=t[8],n=t[12],r=t[1],a=t[5],o=t[9],h=t[13],l=t[2],c=t[6],d=t[10],p=t[14],f=t[3],m=t[7],g=t[11],y=t[15];return f*(+n*o*c-s*h*c-n*a*d+i*h*d+s*a*p-i*o*p)+m*(+e*o*p-e*h*d+n*r*d-s*r*p+s*h*l-n*o*l)+g*(+e*h*c-e*a*p-n*r*c+i*r*p+n*a*l-i*h*l)+y*(-s*a*l-e*o*c+e*a*d+s*r*c-i*r*d+i*o*l)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,i){const s=this.elements;return t.isVector3?(s[12]=t.x,s[13]=t.y,s[14]=t.z):(s[12]=t,s[13]=e,s[14]=i),this}invert(){const t=this.elements,e=t[0],i=t[1],s=t[2],n=t[3],r=t[4],a=t[5],o=t[6],h=t[7],l=t[8],c=t[9],d=t[10],p=t[11],f=t[12],m=t[13],g=t[14],y=t[15],M=c*g*h-m*d*h+m*o*p-a*g*p-c*o*y+a*d*y,w=f*d*h-l*g*h-f*o*p+r*g*p+l*o*y-r*d*y,S=l*m*h-f*c*h+f*a*p-r*m*p-l*a*y+r*c*y,v=f*c*o-l*m*o-f*a*d+r*m*d+l*a*g-r*c*g,_=e*M+i*w+s*S+n*v;if(_===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const A=1/_;return t[0]=M*A,t[1]=(m*d*n-c*g*n-m*s*p+i*g*p+c*s*y-i*d*y)*A,t[2]=(a*g*n-m*o*n+m*s*h-i*g*h-a*s*y+i*o*y)*A,t[3]=(c*o*n-a*d*n-c*s*h+i*d*h+a*s*p-i*o*p)*A,t[4]=w*A,t[5]=(l*g*n-f*d*n+f*s*p-e*g*p-l*s*y+e*d*y)*A,t[6]=(f*o*n-r*g*n-f*s*h+e*g*h+r*s*y-e*o*y)*A,t[7]=(r*d*n-l*o*n+l*s*h-e*d*h-r*s*p+e*o*p)*A,t[8]=S*A,t[9]=(f*c*n-l*m*n-f*i*p+e*m*p+l*i*y-e*c*y)*A,t[10]=(r*m*n-f*a*n+f*i*h-e*m*h-r*i*y+e*a*y)*A,t[11]=(l*a*n-r*c*n-l*i*h+e*c*h+r*i*p-e*a*p)*A,t[12]=v*A,t[13]=(l*m*s-f*c*s+f*i*d-e*m*d-l*i*g+e*c*g)*A,t[14]=(f*a*s-r*m*s-f*i*o+e*m*o+r*i*g-e*a*g)*A,t[15]=(r*c*s-l*a*s+l*i*o-e*c*o-r*i*d+e*a*d)*A,this}scale(t){const e=this.elements,i=t.x,s=t.y,n=t.z;return e[0]*=i,e[4]*=s,e[8]*=n,e[1]*=i,e[5]*=s,e[9]*=n,e[2]*=i,e[6]*=s,e[10]*=n,e[3]*=i,e[7]*=s,e[11]*=n,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],i=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],s=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,i,s))}makeTranslation(t,e,i){return this.set(1,0,0,t,0,1,0,e,0,0,1,i,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),i=Math.sin(t);return this.set(1,0,0,0,0,e,-i,0,0,i,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,0,i,0,0,1,0,0,-i,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,-i,0,0,i,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const i=Math.cos(e),s=Math.sin(e),n=1-i,r=t.x,a=t.y,o=t.z,h=n*r,l=n*a;return this.set(h*r+i,h*a-s*o,h*o+s*a,0,h*a+s*o,l*a+i,l*o-s*r,0,h*o-s*a,l*o+s*r,n*o*o+i,0,0,0,0,1),this}makeScale(t,e,i){return this.set(t,0,0,0,0,e,0,0,0,0,i,0,0,0,0,1),this}makeShear(t,e,i,s,n,r){return this.set(1,i,n,0,t,1,r,0,e,s,1,0,0,0,0,1),this}compose(t,e,i){const s=this.elements,n=e._x,r=e._y,a=e._z,o=e._w,h=n+n,l=r+r,c=a+a,d=n*h,p=n*l,f=n*c,m=r*l,g=r*c,y=a*c,M=o*h,w=o*l,S=o*c,v=i.x,_=i.y,A=i.z;return s[0]=(1-(m+y))*v,s[1]=(p+S)*v,s[2]=(f-w)*v,s[3]=0,s[4]=(p-S)*_,s[5]=(1-(d+y))*_,s[6]=(g+M)*_,s[7]=0,s[8]=(f+w)*A,s[9]=(g-M)*A,s[10]=(1-(d+m))*A,s[11]=0,s[12]=t.x,s[13]=t.y,s[14]=t.z,s[15]=1,this}decompose(t,e,i){const s=this.elements;let n=Te.set(s[0],s[1],s[2]).length();const r=Te.set(s[4],s[5],s[6]).length(),a=Te.set(s[8],s[9],s[10]).length();this.determinant()<0&&(n=-n),t.x=s[12],t.y=s[13],t.z=s[14],Mt.copy(this);const h=1/n,l=1/r,c=1/a;return Mt.elements[0]*=h,Mt.elements[1]*=h,Mt.elements[2]*=h,Mt.elements[4]*=l,Mt.elements[5]*=l,Mt.elements[6]*=l,Mt.elements[8]*=c,Mt.elements[9]*=c,Mt.elements[10]*=c,e.setFromRotationMatrix(Mt),i.x=n,i.y=r,i.z=a,this}makePerspective(t,e,i,s,n,r){const a=this.elements,o=2*n/(e-t),h=2*n/(i-s),l=(e+t)/(e-t),c=(i+s)/(i-s),d=-(r+n)/(r-n),p=-2*r*n/(r-n);return a[0]=o,a[4]=0,a[8]=l,a[12]=0,a[1]=0,a[5]=h,a[9]=c,a[13]=0,a[2]=0,a[6]=0,a[10]=d,a[14]=p,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(t,e,i,s,n,r){const a=this.elements,o=1/(e-t),h=1/(i-s),l=1/(r-n),c=(e+t)*o,d=(i+s)*h,p=(r+n)*l;return a[0]=2*o,a[4]=0,a[8]=0,a[12]=-c,a[1]=0,a[5]=2*h,a[9]=0,a[13]=-d,a[2]=0,a[6]=0,a[10]=-2*l,a[14]=-p,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(t){const e=this.elements,i=t.elements;for(let s=0;s<16;s++)if(e[s]!==i[s])return!1;return!0}fromArray(t,e=0){for(let i=0;i<16;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){const i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t[e+9]=i[9],t[e+10]=i[10],t[e+11]=i[11],t[e+12]=i[12],t[e+13]=i[13],t[e+14]=i[14],t[e+15]=i[15],t}}const Te=new x,Mt=new P,Ha=new x(0,0,0),Wa=new x(1,1,1),$t=new x,Pi=new x,ct=new x,Rn=new P,Fn=new ot;class dt{constructor(t=0,e=0,i=0,s=dt.DefaultOrder){this.isEuler=!0,this._x=t,this._y=e,this._z=i,this._order=s}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,i,s=this._order){return this._x=t,this._y=e,this._z=i,this._order=s,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,i=!0){const s=t.elements,n=s[0],r=s[4],a=s[8],o=s[1],h=s[5],l=s[9],c=s[2],d=s[6],p=s[10];switch(e){case"XYZ":this._y=Math.asin(Q(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-l,p),this._z=Math.atan2(-r,n)):(this._x=Math.atan2(d,h),this._z=0);break;case"YXZ":this._x=Math.asin(-Q(l,-1,1)),Math.abs(l)<.9999999?(this._y=Math.atan2(a,p),this._z=Math.atan2(o,h)):(this._y=Math.atan2(-c,n),this._z=0);break;case"ZXY":this._x=Math.asin(Q(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-c,p),this._z=Math.atan2(-r,h)):(this._y=0,this._z=Math.atan2(o,n));break;case"ZYX":this._y=Math.asin(-Q(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(d,p),this._z=Math.atan2(o,n)):(this._x=0,this._z=Math.atan2(-r,h));break;case"YZX":this._z=Math.asin(Q(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-l,h),this._y=Math.atan2(-c,n)):(this._x=0,this._y=Math.atan2(a,p));break;case"XZY":this._z=Math.asin(-Q(r,-1,1)),Math.abs(r)<.9999999?(this._x=Math.atan2(d,h),this._y=Math.atan2(a,n)):(this._x=Math.atan2(-l,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,i===!0&&this._onChangeCallback(),this}setFromQuaternion(t,e,i){return Rn.makeRotationFromQuaternion(t),this.setFromRotationMatrix(Rn,e,i)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return Fn.setFromEuler(this),this.setFromQuaternion(Fn,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}toVector3(){console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")}}dt.DefaultOrder="XYZ";dt.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class Xa{constructor(){this.mask=1}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!==0}isEnabled(t){return(this.mask&(1<<t|0))!==0}}let qa=0;const In=new x,Se=new ot,Dt=new P,Ci=new x,Ye=new x,Ya=new x,$a=new ot,kn=new x(1,0,0),Ln=new x(0,1,0),zn=new x(0,0,1),Ka={type:"added"},Bn={type:"removed"};class H extends mi{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:qa++}),this.uuid=_t(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=H.DefaultUp.clone();const t=new x,e=new dt,i=new ot,s=new x(1,1,1);function n(){i.setFromEuler(e,!1)}function r(){e.setFromQuaternion(i,void 0,!1)}e._onChange(n),i._onChange(r),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:i},scale:{configurable:!0,enumerable:!0,value:s},modelViewMatrix:{value:new P},normalMatrix:{value:new ne}}),this.matrix=new P,this.matrixWorld=new P,this.matrixAutoUpdate=H.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.matrixWorldAutoUpdate=H.DefaultMatrixWorldAutoUpdate,this.layers=new Xa,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return Se.setFromAxisAngle(t,e),this.quaternion.multiply(Se),this}rotateOnWorldAxis(t,e){return Se.setFromAxisAngle(t,e),this.quaternion.premultiply(Se),this}rotateX(t){return this.rotateOnAxis(kn,t)}rotateY(t){return this.rotateOnAxis(Ln,t)}rotateZ(t){return this.rotateOnAxis(zn,t)}translateOnAxis(t,e){return In.copy(t).applyQuaternion(this.quaternion),this.position.add(In.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(kn,t)}translateY(t){return this.translateOnAxis(Ln,t)}translateZ(t){return this.translateOnAxis(zn,t)}localToWorld(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(Dt.copy(this.matrixWorld).invert())}lookAt(t,e,i){t.isVector3?Ci.copy(t):Ci.set(t,e,i);const s=this.parent;this.updateWorldMatrix(!0,!1),Ye.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Dt.lookAt(Ye,Ci,this.up):Dt.lookAt(Ci,Ye,this.up),this.quaternion.setFromRotationMatrix(Dt),s&&(Dt.extractRotation(s.matrixWorld),Se.setFromRotationMatrix(Dt),this.quaternion.premultiply(Se.invert()))}add(t){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.parent!==null&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(Ka)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let i=0;i<arguments.length;i++)this.remove(arguments[i]);return this}const e=this.children.indexOf(t);return e!==-1&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(Bn)),this}removeFromParent(){const t=this.parent;return t!==null&&t.remove(this),this}clear(){for(let t=0;t<this.children.length;t++){const e=this.children[t];e.parent=null,e.dispatchEvent(Bn)}return this.children.length=0,this}attach(t){return this.updateWorldMatrix(!0,!1),Dt.copy(this.matrixWorld).invert(),t.parent!==null&&(t.parent.updateWorldMatrix(!0,!1),Dt.multiply(t.parent.matrixWorld)),t.applyMatrix4(Dt),this.add(t),t.updateWorldMatrix(!1,!0),this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let i=0,s=this.children.length;i<s;i++){const r=this.children[i].getObjectByProperty(t,e);if(r!==void 0)return r}}getObjectsByProperty(t,e){let i=[];this[t]===e&&i.push(this);for(let s=0,n=this.children.length;s<n;s++){const r=this.children[s].getObjectsByProperty(t,e);r.length>0&&(i=i.concat(r))}return i}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Ye,t,Ya),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Ye,$a,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let i=0,s=e.length;i<s;i++)e[i].traverse(t)}traverseVisible(t){if(this.visible===!1)return;t(this);const e=this.children;for(let i=0,s=e.length;i<s;i++)e[i].traverseVisible(t)}traverseAncestors(t){const e=this.parent;e!==null&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let i=0,s=e.length;i<s;i++){const n=e[i];(n.matrixWorldAutoUpdate===!0||t===!0)&&n.updateMatrixWorld(t)}}updateWorldMatrix(t,e){const i=this.parent;if(t===!0&&i!==null&&i.matrixWorldAutoUpdate===!0&&i.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),e===!0){const s=this.children;for(let n=0,r=s.length;n<r;n++){const a=s[n];a.matrixWorldAutoUpdate===!0&&a.updateWorldMatrix(!1,!0)}}}toJSON(t){const e=t===void 0||typeof t=="string",i={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},i.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const s={};s.uuid=this.uuid,s.type=this.type,this.name!==""&&(s.name=this.name),this.castShadow===!0&&(s.castShadow=!0),this.receiveShadow===!0&&(s.receiveShadow=!0),this.visible===!1&&(s.visible=!1),this.frustumCulled===!1&&(s.frustumCulled=!1),this.renderOrder!==0&&(s.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(s.userData=this.userData),s.layers=this.layers.mask,s.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(s.matrixAutoUpdate=!1),this.isInstancedMesh&&(s.type="InstancedMesh",s.count=this.count,s.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(s.instanceColor=this.instanceColor.toJSON()));function n(a,o){return a[o.uuid]===void 0&&(a[o.uuid]=o.toJSON(t)),o.uuid}if(this.isScene)this.background&&(this.background.isColor?s.background=this.background.toJSON():this.background.isTexture&&(s.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(s.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){s.geometry=n(t.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const o=a.shapes;if(Array.isArray(o))for(let h=0,l=o.length;h<l;h++){const c=o[h];n(t.shapes,c)}else n(t.shapes,o)}}if(this.isSkinnedMesh&&(s.bindMode=this.bindMode,s.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(n(t.skeletons,this.skeleton),s.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let o=0,h=this.material.length;o<h;o++)a.push(n(t.materials,this.material[o]));s.material=a}else s.material=n(t.materials,this.material);if(this.children.length>0){s.children=[];for(let a=0;a<this.children.length;a++)s.children.push(this.children[a].toJSON(t).object)}if(this.animations.length>0){s.animations=[];for(let a=0;a<this.animations.length;a++){const o=this.animations[a];s.animations.push(n(t.animations,o))}}if(e){const a=r(t.geometries),o=r(t.materials),h=r(t.textures),l=r(t.images),c=r(t.shapes),d=r(t.skeletons),p=r(t.animations),f=r(t.nodes);a.length>0&&(i.geometries=a),o.length>0&&(i.materials=o),h.length>0&&(i.textures=h),l.length>0&&(i.images=l),c.length>0&&(i.shapes=c),d.length>0&&(i.skeletons=d),p.length>0&&(i.animations=p),f.length>0&&(i.nodes=f)}return i.object=s,i;function r(a){const o=[];for(const h in a){const l=a[h];delete l.metadata,o.push(l)}return o}}clone(t){return new this.constructor().copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.matrixWorldAutoUpdate=t.matrixWorldAutoUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),e===!0)for(let i=0;i<t.children.length;i++){const s=t.children[i];this.add(s.clone())}return this}}H.DefaultUp=new x(0,1,0);H.DefaultMatrixAutoUpdate=!0;H.DefaultMatrixWorldAutoUpdate=!0;const vt=new x,Ot=new x,fs=new x,Nt=new x,_e=new x,Ae=new x,Dn=new x,ms=new x,gs=new x,ys=new x;class Vt{constructor(t=new x,e=new x,i=new x){this.a=t,this.b=e,this.c=i}static getNormal(t,e,i,s){s.subVectors(i,e),vt.subVectors(t,e),s.cross(vt);const n=s.lengthSq();return n>0?s.multiplyScalar(1/Math.sqrt(n)):s.set(0,0,0)}static getBarycoord(t,e,i,s,n){vt.subVectors(s,e),Ot.subVectors(i,e),fs.subVectors(t,e);const r=vt.dot(vt),a=vt.dot(Ot),o=vt.dot(fs),h=Ot.dot(Ot),l=Ot.dot(fs),c=r*h-a*a;if(c===0)return n.set(-2,-1,-1);const d=1/c,p=(h*o-a*l)*d,f=(r*l-a*o)*d;return n.set(1-p-f,f,p)}static containsPoint(t,e,i,s){return this.getBarycoord(t,e,i,s,Nt),Nt.x>=0&&Nt.y>=0&&Nt.x+Nt.y<=1}static getUV(t,e,i,s,n,r,a,o){return this.getBarycoord(t,e,i,s,Nt),o.set(0,0),o.addScaledVector(n,Nt.x),o.addScaledVector(r,Nt.y),o.addScaledVector(a,Nt.z),o}static isFrontFacing(t,e,i,s){return vt.subVectors(i,e),Ot.subVectors(t,e),vt.cross(Ot).dot(s)<0}set(t,e,i){return this.a.copy(t),this.b.copy(e),this.c.copy(i),this}setFromPointsAndIndices(t,e,i,s){return this.a.copy(t[e]),this.b.copy(t[i]),this.c.copy(t[s]),this}setFromAttributeAndIndices(t,e,i,s){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,i),this.c.fromBufferAttribute(t,s),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return vt.subVectors(this.c,this.b),Ot.subVectors(this.a,this.b),vt.cross(Ot).length()*.5}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return Vt.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return Vt.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,i,s,n){return Vt.getUV(t,this.a,this.b,this.c,e,i,s,n)}containsPoint(t){return Vt.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return Vt.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const i=this.a,s=this.b,n=this.c;let r,a;_e.subVectors(s,i),Ae.subVectors(n,i),ms.subVectors(t,i);const o=_e.dot(ms),h=Ae.dot(ms);if(o<=0&&h<=0)return e.copy(i);gs.subVectors(t,s);const l=_e.dot(gs),c=Ae.dot(gs);if(l>=0&&c<=l)return e.copy(s);const d=o*c-l*h;if(d<=0&&o>=0&&l<=0)return r=o/(o-l),e.copy(i).addScaledVector(_e,r);ys.subVectors(t,n);const p=_e.dot(ys),f=Ae.dot(ys);if(f>=0&&p<=f)return e.copy(n);const m=p*h-o*f;if(m<=0&&h>=0&&f<=0)return a=h/(h-f),e.copy(i).addScaledVector(Ae,a);const g=l*f-p*c;if(g<=0&&c-l>=0&&p-f>=0)return Dn.subVectors(n,s),a=(c-l)/(c-l+(p-f)),e.copy(s).addScaledVector(Dn,a);const y=1/(g+m+d);return r=m*y,a=d*y,e.copy(i).addScaledVector(_e,r).addScaledVector(Ae,a)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}let Za=0;class Wt extends mi{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:Za++}),this.uuid=_t(),this.name="",this.type="Material",this.blending=Sn,this.side=Wi,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=ca,this.blendDst=ua,this.blendEquation=la,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=da,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=Ta,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=is,this.stencilZFail=is,this.stencilZPass=is,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(t!==void 0)for(const e in t){const i=t[e];if(i===void 0){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}const s=this[e];if(s===void 0){console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.");continue}s&&s.isColor?s.set(i):s&&s.isVector3&&i&&i.isVector3?s.copy(i):this[e]=i}}toJSON(t){const e=t===void 0||typeof t=="string";e&&(t={textures:{},images:{}});const i={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.color&&this.color.isColor&&(i.color=this.color.getHex()),this.roughness!==void 0&&(i.roughness=this.roughness),this.metalness!==void 0&&(i.metalness=this.metalness),this.sheen!==void 0&&(i.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(i.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(i.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(i.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(i.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(i.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(i.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(i.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(i.shininess=this.shininess),this.clearcoat!==void 0&&(i.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(i.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(i.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(i.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,i.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.iridescence!==void 0&&(i.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(i.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(i.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(i.iridescenceMap=this.iridescenceMap.toJSON(t).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(i.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(t).uuid),this.map&&this.map.isTexture&&(i.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(i.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(i.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(i.lightMap=this.lightMap.toJSON(t).uuid,i.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(i.aoMap=this.aoMap.toJSON(t).uuid,i.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(i.bumpMap=this.bumpMap.toJSON(t).uuid,i.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(i.normalMap=this.normalMap.toJSON(t).uuid,i.normalMapType=this.normalMapType,i.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(i.displacementMap=this.displacementMap.toJSON(t).uuid,i.displacementScale=this.displacementScale,i.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(i.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(i.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(i.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(i.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(i.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(i.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(i.envMap=this.envMap.toJSON(t).uuid,this.combine!==void 0&&(i.combine=this.combine)),this.envMapIntensity!==void 0&&(i.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(i.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(i.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(i.gradientMap=this.gradientMap.toJSON(t).uuid),this.transmission!==void 0&&(i.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(i.transmissionMap=this.transmissionMap.toJSON(t).uuid),this.thickness!==void 0&&(i.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(i.thicknessMap=this.thicknessMap.toJSON(t).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(i.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(i.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(i.size=this.size),this.shadowSide!==null&&(i.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(i.sizeAttenuation=this.sizeAttenuation),this.blending!==Sn&&(i.blending=this.blending),this.side!==Wi&&(i.side=this.side),this.vertexColors&&(i.vertexColors=!0),this.opacity<1&&(i.opacity=this.opacity),this.transparent===!0&&(i.transparent=this.transparent),i.depthFunc=this.depthFunc,i.depthTest=this.depthTest,i.depthWrite=this.depthWrite,i.colorWrite=this.colorWrite,i.stencilWrite=this.stencilWrite,i.stencilWriteMask=this.stencilWriteMask,i.stencilFunc=this.stencilFunc,i.stencilRef=this.stencilRef,i.stencilFuncMask=this.stencilFuncMask,i.stencilFail=this.stencilFail,i.stencilZFail=this.stencilZFail,i.stencilZPass=this.stencilZPass,this.rotation!==void 0&&this.rotation!==0&&(i.rotation=this.rotation),this.polygonOffset===!0&&(i.polygonOffset=!0),this.polygonOffsetFactor!==0&&(i.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(i.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(i.linewidth=this.linewidth),this.dashSize!==void 0&&(i.dashSize=this.dashSize),this.gapSize!==void 0&&(i.gapSize=this.gapSize),this.scale!==void 0&&(i.scale=this.scale),this.dithering===!0&&(i.dithering=!0),this.alphaTest>0&&(i.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(i.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(i.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(i.wireframe=this.wireframe),this.wireframeLinewidth>1&&(i.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(i.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(i.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(i.flatShading=this.flatShading),this.visible===!1&&(i.visible=!1),this.toneMapped===!1&&(i.toneMapped=!1),this.fog===!1&&(i.fog=!1),Object.keys(this.userData).length>0&&(i.userData=this.userData);function s(n){const r=[];for(const a in n){const o=n[a];delete o.metadata,r.push(o)}return r}if(e){const n=s(t.textures),r=s(t.images);n.length>0&&(i.textures=n),r.length>0&&(i.images=r)}return i}clone(){return new this.constructor().copy(this)}copy(t){this.name=t.name,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let i=null;if(e!==null){const s=e.length;i=new Array(s);for(let n=0;n!==s;++n)i[n]=e[n].clone()}return this.clippingPlanes=i,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){t===!0&&this.version++}}class Ie extends Wt{constructor(t){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new U(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Ws,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}const Y=new x,Ri=new L;class At{constructor(t,e,i=!1){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=t,this.itemSize=e,this.count=t!==void 0?t.length/e:0,this.normalized=i,this.usage=Ds,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this}copyAt(t,e,i){t*=this.itemSize,i*=e.itemSize;for(let s=0,n=this.itemSize;s<n;s++)this.array[t+s]=e.array[i+s];return this}copyArray(t){return this.array.set(t),this}applyMatrix3(t){if(this.itemSize===2)for(let e=0,i=this.count;e<i;e++)Ri.fromBufferAttribute(this,e),Ri.applyMatrix3(t),this.setXY(e,Ri.x,Ri.y);else if(this.itemSize===3)for(let e=0,i=this.count;e<i;e++)Y.fromBufferAttribute(this,e),Y.applyMatrix3(t),this.setXYZ(e,Y.x,Y.y,Y.z);return this}applyMatrix4(t){for(let e=0,i=this.count;e<i;e++)Y.fromBufferAttribute(this,e),Y.applyMatrix4(t),this.setXYZ(e,Y.x,Y.y,Y.z);return this}applyNormalMatrix(t){for(let e=0,i=this.count;e<i;e++)Y.fromBufferAttribute(this,e),Y.applyNormalMatrix(t),this.setXYZ(e,Y.x,Y.y,Y.z);return this}transformDirection(t){for(let e=0,i=this.count;e<i;e++)Y.fromBufferAttribute(this,e),Y.transformDirection(t),this.setXYZ(e,Y.x,Y.y,Y.z);return this}set(t,e=0){return this.array.set(t,e),this}getX(t){let e=this.array[t*this.itemSize];return this.normalized&&(e=Ht(e,this.array)),e}setX(t,e){return this.normalized&&(e=V(e,this.array)),this.array[t*this.itemSize]=e,this}getY(t){let e=this.array[t*this.itemSize+1];return this.normalized&&(e=Ht(e,this.array)),e}setY(t,e){return this.normalized&&(e=V(e,this.array)),this.array[t*this.itemSize+1]=e,this}getZ(t){let e=this.array[t*this.itemSize+2];return this.normalized&&(e=Ht(e,this.array)),e}setZ(t,e){return this.normalized&&(e=V(e,this.array)),this.array[t*this.itemSize+2]=e,this}getW(t){let e=this.array[t*this.itemSize+3];return this.normalized&&(e=Ht(e,this.array)),e}setW(t,e){return this.normalized&&(e=V(e,this.array)),this.array[t*this.itemSize+3]=e,this}setXY(t,e,i){return t*=this.itemSize,this.normalized&&(e=V(e,this.array),i=V(i,this.array)),this.array[t+0]=e,this.array[t+1]=i,this}setXYZ(t,e,i,s){return t*=this.itemSize,this.normalized&&(e=V(e,this.array),i=V(i,this.array),s=V(s,this.array)),this.array[t+0]=e,this.array[t+1]=i,this.array[t+2]=s,this}setXYZW(t,e,i,s,n){return t*=this.itemSize,this.normalized&&(e=V(e,this.array),i=V(i,this.array),s=V(s,this.array),n=V(n,this.array)),this.array[t+0]=e,this.array[t+1]=i,this.array[t+2]=s,this.array[t+3]=n,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(t.name=this.name),this.usage!==Ds&&(t.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(t.updateRange=this.updateRange),t}copyColorsArray(){console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")}copyVector2sArray(){console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")}copyVector3sArray(){console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")}copyVector4sArray(){console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")}}class Er extends At{constructor(t,e,i){super(new Uint16Array(t),e,i)}}class Ja extends At{constructor(t,e,i){super(new Uint32Array(t),e,i)}}class gt extends At{constructor(t,e,i){super(new Float32Array(t),e,i)}}let Qa=0;const ft=new P,xs=new H,Ee=new x,ut=new Oe,$e=new Oe,Z=new x;class Ct extends mi{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:Qa++}),this.uuid=_t(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(Na(t)?Ja:Er)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return this.attributes[t]!==void 0}addGroup(t,e,i=0){this.groups.push({start:t,count:e,materialIndex:i})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(t),e.needsUpdate=!0);const i=this.attributes.normal;if(i!==void 0){const n=new ne().getNormalMatrix(t);i.applyNormalMatrix(n),i.needsUpdate=!0}const s=this.attributes.tangent;return s!==void 0&&(s.transformDirection(t),s.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(t){return ft.makeRotationFromQuaternion(t),this.applyMatrix4(ft),this}rotateX(t){return ft.makeRotationX(t),this.applyMatrix4(ft),this}rotateY(t){return ft.makeRotationY(t),this.applyMatrix4(ft),this}rotateZ(t){return ft.makeRotationZ(t),this.applyMatrix4(ft),this}translate(t,e,i){return ft.makeTranslation(t,e,i),this.applyMatrix4(ft),this}scale(t,e,i){return ft.makeScale(t,e,i),this.applyMatrix4(ft),this}lookAt(t){return xs.lookAt(t),xs.updateMatrix(),this.applyMatrix4(xs.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Ee).negate(),this.translate(Ee.x,Ee.y,Ee.z),this}setFromPoints(t){const e=[];for(let i=0,s=t.length;i<s;i++){const n=t[i];e.push(n.x,n.y,n.z||0)}return this.setAttribute("position",new gt(e,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Oe);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new x(-1/0,-1/0,-1/0),new x(1/0,1/0,1/0));return}if(t!==void 0){if(this.boundingBox.setFromBufferAttribute(t),e)for(let i=0,s=e.length;i<s;i++){const n=e[i];ut.setFromBufferAttribute(n),this.morphTargetsRelative?(Z.addVectors(this.boundingBox.min,ut.min),this.boundingBox.expandByPoint(Z),Z.addVectors(this.boundingBox.max,ut.max),this.boundingBox.expandByPoint(Z)):(this.boundingBox.expandByPoint(ut.min),this.boundingBox.expandByPoint(ut.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Ne);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new x,1/0);return}if(t){const i=this.boundingSphere.center;if(ut.setFromBufferAttribute(t),e)for(let n=0,r=e.length;n<r;n++){const a=e[n];$e.setFromBufferAttribute(a),this.morphTargetsRelative?(Z.addVectors(ut.min,$e.min),ut.expandByPoint(Z),Z.addVectors(ut.max,$e.max),ut.expandByPoint(Z)):(ut.expandByPoint($e.min),ut.expandByPoint($e.max))}ut.getCenter(i);let s=0;for(let n=0,r=t.count;n<r;n++)Z.fromBufferAttribute(t,n),s=Math.max(s,i.distanceToSquared(Z));if(e)for(let n=0,r=e.length;n<r;n++){const a=e[n],o=this.morphTargetsRelative;for(let h=0,l=a.count;h<l;h++)Z.fromBufferAttribute(a,h),o&&(Ee.fromBufferAttribute(t,h),Z.add(Ee)),s=Math.max(s,i.distanceToSquared(Z))}this.boundingSphere.radius=Math.sqrt(s),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(t===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const i=t.array,s=e.position.array,n=e.normal.array,r=e.uv.array,a=s.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new At(new Float32Array(4*a),4));const o=this.getAttribute("tangent").array,h=[],l=[];for(let C=0;C<a;C++)h[C]=new x,l[C]=new x;const c=new x,d=new x,p=new x,f=new L,m=new L,g=new L,y=new x,M=new x;function w(C,O,z){c.fromArray(s,C*3),d.fromArray(s,O*3),p.fromArray(s,z*3),f.fromArray(r,C*2),m.fromArray(r,O*2),g.fromArray(r,z*2),d.sub(c),p.sub(c),m.sub(f),g.sub(f);const I=1/(m.x*g.y-g.x*m.y);isFinite(I)&&(y.copy(d).multiplyScalar(g.y).addScaledVector(p,-m.y).multiplyScalar(I),M.copy(p).multiplyScalar(m.x).addScaledVector(d,-g.x).multiplyScalar(I),h[C].add(y),h[O].add(y),h[z].add(y),l[C].add(M),l[O].add(M),l[z].add(M))}let S=this.groups;S.length===0&&(S=[{start:0,count:i.length}]);for(let C=0,O=S.length;C<O;++C){const z=S[C],I=z.start,X=z.count;for(let N=I,W=I+X;N<W;N+=3)w(i[N+0],i[N+1],i[N+2])}const v=new x,_=new x,A=new x,R=new x;function G(C){A.fromArray(n,C*3),R.copy(A);const O=h[C];v.copy(O),v.sub(A.multiplyScalar(A.dot(O))).normalize(),_.crossVectors(R,O);const I=_.dot(l[C])<0?-1:1;o[C*4]=v.x,o[C*4+1]=v.y,o[C*4+2]=v.z,o[C*4+3]=I}for(let C=0,O=S.length;C<O;++C){const z=S[C],I=z.start,X=z.count;for(let N=I,W=I+X;N<W;N+=3)G(i[N+0]),G(i[N+1]),G(i[N+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(e!==void 0){let i=this.getAttribute("normal");if(i===void 0)i=new At(new Float32Array(e.count*3),3),this.setAttribute("normal",i);else for(let d=0,p=i.count;d<p;d++)i.setXYZ(d,0,0,0);const s=new x,n=new x,r=new x,a=new x,o=new x,h=new x,l=new x,c=new x;if(t)for(let d=0,p=t.count;d<p;d+=3){const f=t.getX(d+0),m=t.getX(d+1),g=t.getX(d+2);s.fromBufferAttribute(e,f),n.fromBufferAttribute(e,m),r.fromBufferAttribute(e,g),l.subVectors(r,n),c.subVectors(s,n),l.cross(c),a.fromBufferAttribute(i,f),o.fromBufferAttribute(i,m),h.fromBufferAttribute(i,g),a.add(l),o.add(l),h.add(l),i.setXYZ(f,a.x,a.y,a.z),i.setXYZ(m,o.x,o.y,o.z),i.setXYZ(g,h.x,h.y,h.z)}else for(let d=0,p=e.count;d<p;d+=3)s.fromBufferAttribute(e,d+0),n.fromBufferAttribute(e,d+1),r.fromBufferAttribute(e,d+2),l.subVectors(r,n),c.subVectors(s,n),l.cross(c),i.setXYZ(d+0,l.x,l.y,l.z),i.setXYZ(d+1,l.x,l.y,l.z),i.setXYZ(d+2,l.x,l.y,l.z);this.normalizeNormals(),i.needsUpdate=!0}}merge(){return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."),this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,i=t.count;e<i;e++)Z.fromBufferAttribute(t,e),Z.normalize(),t.setXYZ(e,Z.x,Z.y,Z.z)}toNonIndexed(){function t(a,o){const h=a.array,l=a.itemSize,c=a.normalized,d=new h.constructor(o.length*l);let p=0,f=0;for(let m=0,g=o.length;m<g;m++){a.isInterleavedBufferAttribute?p=o[m]*a.data.stride+a.offset:p=o[m]*l;for(let y=0;y<l;y++)d[f++]=h[p++]}return new At(d,l,c)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new Ct,i=this.index.array,s=this.attributes;for(const a in s){const o=s[a],h=t(o,i);e.setAttribute(a,h)}const n=this.morphAttributes;for(const a in n){const o=[],h=n[a];for(let l=0,c=h.length;l<c;l++){const d=h[l],p=t(d,i);o.push(p)}e.morphAttributes[a]=o}e.morphTargetsRelative=this.morphTargetsRelative;const r=this.groups;for(let a=0,o=r.length;a<o;a++){const h=r[a];e.addGroup(h.start,h.count,h.materialIndex)}return e}toJSON(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),this.parameters!==void 0){const o=this.parameters;for(const h in o)o[h]!==void 0&&(t[h]=o[h]);return t}t.data={attributes:{}};const e=this.index;e!==null&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const i=this.attributes;for(const o in i){const h=i[o];t.data.attributes[o]=h.toJSON(t.data)}const s={};let n=!1;for(const o in this.morphAttributes){const h=this.morphAttributes[o],l=[];for(let c=0,d=h.length;c<d;c++){const p=h[c];l.push(p.toJSON(t.data))}l.length>0&&(s[o]=l,n=!0)}n&&(t.data.morphAttributes=s,t.data.morphTargetsRelative=this.morphTargetsRelative);const r=this.groups;r.length>0&&(t.data.groups=JSON.parse(JSON.stringify(r)));const a=this.boundingSphere;return a!==null&&(t.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),t}clone(){return new this.constructor().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const i=t.index;i!==null&&this.setIndex(i.clone(e));const s=t.attributes;for(const h in s){const l=s[h];this.setAttribute(h,l.clone(e))}const n=t.morphAttributes;for(const h in n){const l=[],c=n[h];for(let d=0,p=c.length;d<p;d++)l.push(c[d].clone(e));this.morphAttributes[h]=l}this.morphTargetsRelative=t.morphTargetsRelative;const r=t.groups;for(let h=0,l=r.length;h<l;h++){const c=r[h];this.addGroup(c.start,c.count,c.materialIndex)}const a=t.boundingBox;a!==null&&(this.boundingBox=a.clone());const o=t.boundingSphere;return o!==null&&(this.boundingSphere=o.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,t.parameters!==void 0&&(this.parameters=Object.assign({},t.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}const On=new P,Pe=new Ks,bs=new Ne,Ke=new x,Ze=new x,Je=new x,ws=new x,Fi=new x,Ii=new L,ki=new L,Li=new L,Ms=new x,zi=new x;class Ue extends H{constructor(t=new Ct,e=new Ie){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this}updateMorphTargets(){const e=this.geometry.morphAttributes,i=Object.keys(e);if(i.length>0){const s=e[i[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let n=0,r=s.length;n<r;n++){const a=s[n].name||String(n);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=n}}}}getVertexPosition(t,e){const i=this.geometry,s=i.attributes.position,n=i.morphAttributes.position,r=i.morphTargetsRelative;e.fromBufferAttribute(s,t);const a=this.morphTargetInfluences;if(n&&a){Fi.set(0,0,0);for(let o=0,h=n.length;o<h;o++){const l=a[o],c=n[o];l!==0&&(ws.fromBufferAttribute(c,t),r?Fi.addScaledVector(ws,l):Fi.addScaledVector(ws.sub(e),l))}e.add(Fi)}return this.isSkinnedMesh&&this.boneTransform(t,e),e}raycast(t,e){const i=this.geometry,s=this.material,n=this.matrixWorld;if(s===void 0||(i.boundingSphere===null&&i.computeBoundingSphere(),bs.copy(i.boundingSphere),bs.applyMatrix4(n),t.ray.intersectsSphere(bs)===!1)||(On.copy(n).invert(),Pe.copy(t.ray).applyMatrix4(On),i.boundingBox!==null&&Pe.intersectsBox(i.boundingBox)===!1))return;let r;const a=i.index,o=i.attributes.position,h=i.attributes.uv,l=i.attributes.uv2,c=i.groups,d=i.drawRange;if(a!==null)if(Array.isArray(s))for(let p=0,f=c.length;p<f;p++){const m=c[p],g=s[m.materialIndex],y=Math.max(m.start,d.start),M=Math.min(a.count,Math.min(m.start+m.count,d.start+d.count));for(let w=y,S=M;w<S;w+=3){const v=a.getX(w),_=a.getX(w+1),A=a.getX(w+2);r=Bi(this,g,t,Pe,h,l,v,_,A),r&&(r.faceIndex=Math.floor(w/3),r.face.materialIndex=m.materialIndex,e.push(r))}}else{const p=Math.max(0,d.start),f=Math.min(a.count,d.start+d.count);for(let m=p,g=f;m<g;m+=3){const y=a.getX(m),M=a.getX(m+1),w=a.getX(m+2);r=Bi(this,s,t,Pe,h,l,y,M,w),r&&(r.faceIndex=Math.floor(m/3),e.push(r))}}else if(o!==void 0)if(Array.isArray(s))for(let p=0,f=c.length;p<f;p++){const m=c[p],g=s[m.materialIndex],y=Math.max(m.start,d.start),M=Math.min(o.count,Math.min(m.start+m.count,d.start+d.count));for(let w=y,S=M;w<S;w+=3){const v=w,_=w+1,A=w+2;r=Bi(this,g,t,Pe,h,l,v,_,A),r&&(r.faceIndex=Math.floor(w/3),r.face.materialIndex=m.materialIndex,e.push(r))}}else{const p=Math.max(0,d.start),f=Math.min(o.count,d.start+d.count);for(let m=p,g=f;m<g;m+=3){const y=m,M=m+1,w=m+2;r=Bi(this,s,t,Pe,h,l,y,M,w),r&&(r.faceIndex=Math.floor(m/3),e.push(r))}}}}function to(u,t,e,i,s,n,r,a){let o;if(t.side===oa?o=i.intersectTriangle(r,n,s,!0,a):o=i.intersectTriangle(s,n,r,t.side===Wi,a),o===null)return null;zi.copy(a),zi.applyMatrix4(u.matrixWorld);const h=e.ray.origin.distanceTo(zi);return h<e.near||h>e.far?null:{distance:h,point:zi.clone(),object:u}}function Bi(u,t,e,i,s,n,r,a,o){u.getVertexPosition(r,Ke),u.getVertexPosition(a,Ze),u.getVertexPosition(o,Je);const h=to(u,t,e,i,Ke,Ze,Je,Ms);if(h){s&&(Ii.fromBufferAttribute(s,r),ki.fromBufferAttribute(s,a),Li.fromBufferAttribute(s,o),h.uv=Vt.getUV(Ms,Ke,Ze,Je,Ii,ki,Li,new L)),n&&(Ii.fromBufferAttribute(n,r),ki.fromBufferAttribute(n,a),Li.fromBufferAttribute(n,o),h.uv2=Vt.getUV(Ms,Ke,Ze,Je,Ii,ki,Li,new L));const l={a:r,b:a,c:o,normal:new x,materialIndex:0};Vt.getNormal(Ke,Ze,Je,l.normal),h.face=l}return h}let Pr=class extends H{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new P,this.projectionMatrix=new P,this.projectionMatrixInverse=new P}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(-e[8],-e[9],-e[10]).normalize()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}};class gi extends Pr{constructor(t=50,e=1,i=.1,s=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=i,this.far=s,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=t.view===null?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=pi*2*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(ni*.5*this.fov);return .5*this.getFilmHeight()/t}getEffectiveFOV(){return pi*2*Math.atan(Math.tan(ni*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(t,e,i,s,n,r){this.aspect=t/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=i,this.view.offsetY=s,this.view.width=n,this.view.height=r,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(ni*.5*this.fov)/this.zoom,i=2*e,s=this.aspect*i,n=-.5*s;const r=this.view;if(this.view!==null&&this.view.enabled){const o=r.fullWidth,h=r.fullHeight;n+=r.offsetX*s/o,e-=r.offsetY*i/h,s*=r.width/o,i*=r.height/h}const a=this.filmOffset;a!==0&&(n+=t*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(n,n+s,e,e-i,t,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}class eo extends ht{constructor(t,e,i,s,n,r,a,o,h,l){t=t!==void 0?t:[],e=e!==void 0?e:pa,super(t,e,i,s,n,r,a,o,h,l),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}const vs=new x,io=new x,so=new ne;class Ce{constructor(t=new x(1,0,0),e=0){this.isPlane=!0,this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,i,s){return this.normal.set(t,e,i),this.constant=s,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,i){const s=vs.subVectors(i,e).cross(io.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(s,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){const i=t.delta(vs),s=this.normal.dot(i);if(s===0)return this.distanceToPoint(t.start)===0?e.copy(t.start):null;const n=-(t.start.dot(this.normal)+this.constant)/s;return n<0||n>1?null:e.copy(i).multiplyScalar(n).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),i=this.distanceToPoint(t.end);return e<0&&i>0||i<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const i=e||so.getNormalMatrix(t),s=this.coplanarPoint(vs).applyMatrix4(t),n=this.normal.applyMatrix3(i).normalize();return this.constant=-s.dot(n),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}const Re=new Ne,Di=new x;class Cr{constructor(t=new Ce,e=new Ce,i=new Ce,s=new Ce,n=new Ce,r=new Ce){this.planes=[t,e,i,s,n,r]}set(t,e,i,s,n,r){const a=this.planes;return a[0].copy(t),a[1].copy(e),a[2].copy(i),a[3].copy(s),a[4].copy(n),a[5].copy(r),this}copy(t){const e=this.planes;for(let i=0;i<6;i++)e[i].copy(t.planes[i]);return this}setFromProjectionMatrix(t){const e=this.planes,i=t.elements,s=i[0],n=i[1],r=i[2],a=i[3],o=i[4],h=i[5],l=i[6],c=i[7],d=i[8],p=i[9],f=i[10],m=i[11],g=i[12],y=i[13],M=i[14],w=i[15];return e[0].setComponents(a-s,c-o,m-d,w-g).normalize(),e[1].setComponents(a+s,c+o,m+d,w+g).normalize(),e[2].setComponents(a+n,c+h,m+p,w+y).normalize(),e[3].setComponents(a-n,c-h,m-p,w-y).normalize(),e[4].setComponents(a-r,c-l,m-f,w-M).normalize(),e[5].setComponents(a+r,c+l,m+f,w+M).normalize(),this}intersectsObject(t){const e=t.geometry;return e.boundingSphere===null&&e.computeBoundingSphere(),Re.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(Re)}intersectsSprite(t){return Re.center.set(0,0,0),Re.radius=.7071067811865476,Re.applyMatrix4(t.matrixWorld),this.intersectsSphere(Re)}intersectsSphere(t){const e=this.planes,i=t.center,s=-t.radius;for(let n=0;n<6;n++)if(e[n].distanceToPoint(i)<s)return!1;return!0}intersectsBox(t){const e=this.planes;for(let i=0;i<6;i++){const s=e[i];if(Di.x=s.normal.x>0?t.max.x:t.min.x,Di.y=s.normal.y>0?t.max.y:t.min.y,Di.z=s.normal.z>0?t.max.z:t.min.z,s.distanceToPoint(Di)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let i=0;i<6;i++)if(e[i].distanceToPoint(t)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}class Zs extends Ct{constructor(t=1,e=1,i=1,s=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:i,heightSegments:s};const n=t/2,r=e/2,a=Math.floor(i),o=Math.floor(s),h=a+1,l=o+1,c=t/a,d=e/o,p=[],f=[],m=[],g=[];for(let y=0;y<l;y++){const M=y*d-r;for(let w=0;w<h;w++){const S=w*c-n;f.push(S,-M,0),m.push(0,0,1),g.push(w/a),g.push(1-y/o)}}for(let y=0;y<o;y++)for(let M=0;M<a;M++){const w=M+h*y,S=M+h*(y+1),v=M+1+h*(y+1),_=M+1+h*y;p.push(w,S,_),p.push(S,v,_)}this.setIndex(p),this.setAttribute("position",new gt(f,3)),this.setAttribute("normal",new gt(m,3)),this.setAttribute("uv",new gt(g,2))}static fromJSON(t){return new Zs(t.width,t.height,t.widthSegments,t.heightSegments)}}class Js extends Pr{constructor(t=-1,e=1,i=1,s=-1,n=.1,r=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=i,this.bottom=s,this.near=n,this.far=r,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=t.view===null?null:Object.assign({},t.view),this}setViewOffset(t,e,i,s,n,r){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=i,this.view.offsetY=s,this.view.width=n,this.view.height=r,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),i=(this.right+this.left)/2,s=(this.top+this.bottom)/2;let n=i-t,r=i+t,a=s+e,o=s-e;if(this.view!==null&&this.view.enabled){const h=(this.right-this.left)/this.view.fullWidth/this.zoom,l=(this.top-this.bottom)/this.view.fullHeight/this.zoom;n+=h*this.view.offsetX,r=n+h*this.view.width,a-=l*this.view.offsetY,o=a-l*this.view.height}this.projectionMatrix.makeOrthographic(n,r,a,o,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}}class ai extends H{constructor(){super(),this.isGroup=!0,this.type="Group"}}class no{constructor(t,e){this.isInterleavedBuffer=!0,this.array=t,this.stride=e,this.count=t!==void 0?t.length/e:0,this.usage=Ds,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=_t()}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,i){t*=this.stride,i*=e.stride;for(let s=0,n=this.stride;s<n;s++)this.array[t+s]=e.array[i+s];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=_t()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),i=new this.constructor(e,this.stride);return i.setUsage(this.usage),i}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=_t()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const nt=new x;class Qs{constructor(t,e,i,s=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=t,this.itemSize=e,this.offset=i,this.normalized=s}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,i=this.data.count;e<i;e++)nt.fromBufferAttribute(this,e),nt.applyMatrix4(t),this.setXYZ(e,nt.x,nt.y,nt.z);return this}applyNormalMatrix(t){for(let e=0,i=this.count;e<i;e++)nt.fromBufferAttribute(this,e),nt.applyNormalMatrix(t),this.setXYZ(e,nt.x,nt.y,nt.z);return this}transformDirection(t){for(let e=0,i=this.count;e<i;e++)nt.fromBufferAttribute(this,e),nt.transformDirection(t),this.setXYZ(e,nt.x,nt.y,nt.z);return this}setX(t,e){return this.normalized&&(e=V(e,this.array)),this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.normalized&&(e=V(e,this.array)),this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.normalized&&(e=V(e,this.array)),this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.normalized&&(e=V(e,this.array)),this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){let e=this.data.array[t*this.data.stride+this.offset];return this.normalized&&(e=Ht(e,this.array)),e}getY(t){let e=this.data.array[t*this.data.stride+this.offset+1];return this.normalized&&(e=Ht(e,this.array)),e}getZ(t){let e=this.data.array[t*this.data.stride+this.offset+2];return this.normalized&&(e=Ht(e,this.array)),e}getW(t){let e=this.data.array[t*this.data.stride+this.offset+3];return this.normalized&&(e=Ht(e,this.array)),e}setXY(t,e,i){return t=t*this.data.stride+this.offset,this.normalized&&(e=V(e,this.array),i=V(i,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=i,this}setXYZ(t,e,i,s){return t=t*this.data.stride+this.offset,this.normalized&&(e=V(e,this.array),i=V(i,this.array),s=V(s,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=i,this.data.array[t+2]=s,this}setXYZW(t,e,i,s,n){return t=t*this.data.stride+this.offset,this.normalized&&(e=V(e,this.array),i=V(i,this.array),s=V(s,this.array),n=V(n,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=i,this.data.array[t+2]=s,this.data.array[t+3]=n,this}clone(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const e=[];for(let i=0;i<this.count;i++){const s=i*this.data.stride+this.offset;for(let n=0;n<this.itemSize;n++)e.push(this.data.array[s+n])}return new At(new this.array.constructor(e),this.itemSize,this.normalized)}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new Qs(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const e=[];for(let i=0;i<this.count;i++){const s=i*this.data.stride+this.offset;for(let n=0;n<this.itemSize;n++)e.push(this.data.array[s+n])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}const Nn=new x,Un=new it,Gn=new it,ro=new x,Vn=new P;class Rr extends Ue{constructor(t,e){super(t,e),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new P,this.bindMatrixInverse=new P}copy(t,e){return super.copy(t,e),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,this}bind(t,e){this.skeleton=t,e===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new it,e=this.geometry.attributes.skinWeight;for(let i=0,s=e.count;i<s;i++){t.fromBufferAttribute(e,i);const n=1/t.manhattanLength();n!==1/0?t.multiplyScalar(n):t.set(1,0,0,0),e.setXYZW(i,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(t,e){const i=this.skeleton,s=this.geometry;Un.fromBufferAttribute(s.attributes.skinIndex,t),Gn.fromBufferAttribute(s.attributes.skinWeight,t),Nn.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let n=0;n<4;n++){const r=Gn.getComponent(n);if(r!==0){const a=Un.getComponent(n);Vn.multiplyMatrices(i.bones[a].matrixWorld,i.boneInverses[a]),e.addScaledVector(ro.copy(Nn).applyMatrix4(Vn),r)}}return e.applyMatrix4(this.bindMatrixInverse)}}class Xi extends H{constructor(){super(),this.isBone=!0,this.type="Bone"}}class ao extends ht{constructor(t=null,e=1,i=1,s,n,r,a,o,h=zs,l=zs,c,d){super(null,r,a,o,h,l,s,n,c,d),this.isDataTexture=!0,this.image={data:t,width:e,height:i},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const jn=new P,oo=new P;class $i{constructor(t=[],e=[]){this.uuid=_t(),this.bones=t.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const t=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(t.length*16),e.length===0)this.calculateInverses();else if(t.length!==e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let i=0,s=this.bones.length;i<s;i++)this.boneInverses.push(new P)}}calculateInverses(){this.boneInverses.length=0;for(let t=0,e=this.bones.length;t<e;t++){const i=new P;this.bones[t]&&i.copy(this.bones[t].matrixWorld).invert(),this.boneInverses.push(i)}}pose(){for(let t=0,e=this.bones.length;t<e;t++){const i=this.bones[t];i&&i.matrixWorld.copy(this.boneInverses[t]).invert()}for(let t=0,e=this.bones.length;t<e;t++){const i=this.bones[t];i&&(i.parent&&i.parent.isBone?(i.matrix.copy(i.parent.matrixWorld).invert(),i.matrix.multiply(i.matrixWorld)):i.matrix.copy(i.matrixWorld),i.matrix.decompose(i.position,i.quaternion,i.scale))}}update(){const t=this.bones,e=this.boneInverses,i=this.boneMatrices,s=this.boneTexture;for(let n=0,r=t.length;n<r;n++){const a=t[n]?t[n].matrixWorld:oo;jn.multiplyMatrices(a,e[n]),jn.toArray(i,n*16)}s!==null&&(s.needsUpdate=!0)}clone(){return new $i(this.bones,this.boneInverses)}computeBoneTexture(){let t=Math.sqrt(this.bones.length*4);t=_r(t),t=Math.max(t,4);const e=new Float32Array(t*t*4);e.set(this.boneMatrices);const i=new ao(e,t,t,Tr,ba);return i.needsUpdate=!0,this.boneMatrices=e,this.boneTexture=i,this.boneTextureSize=t,this}getBoneByName(t){for(let e=0,i=this.bones.length;e<i;e++){const s=this.bones[e];if(s.name===t)return s}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(t,e){this.uuid=t.uuid;for(let i=0,s=t.bones.length;i<s;i++){const n=t.bones[i];let r=e[n];r===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",n),r=new Xi),this.bones.push(r),this.boneInverses.push(new P().fromArray(t.boneInverses[i]))}return this.init(),this}toJSON(){const t={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};t.uuid=this.uuid;const e=this.bones,i=this.boneInverses;for(let s=0,n=e.length;s<n;s++){const r=e[s];t.bones.push(r.uuid);const a=i[s];t.boneInverses.push(a.toArray())}return t}}class Hn extends At{constructor(t,e,i,s=1){super(t,e,i),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=s}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}const Wn=new P,Xn=new P,Oi=[],ho=new P,Qe=new Ue;class lo extends Ue{constructor(t,e,i){super(t,e),this.isInstancedMesh=!0,this.instanceMatrix=new Hn(new Float32Array(i*16),16),this.instanceColor=null,this.count=i,this.frustumCulled=!1;for(let s=0;s<i;s++)this.setMatrixAt(s,ho)}copy(t,e){return super.copy(t,e),this.instanceMatrix.copy(t.instanceMatrix),t.instanceColor!==null&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,this}getColorAt(t,e){e.fromArray(this.instanceColor.array,t*3)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,t*16)}raycast(t,e){const i=this.matrixWorld,s=this.count;if(Qe.geometry=this.geometry,Qe.material=this.material,Qe.material!==void 0)for(let n=0;n<s;n++){this.getMatrixAt(n,Wn),Xn.multiplyMatrices(i,Wn),Qe.matrixWorld=Xn,Qe.raycast(t,Oi);for(let r=0,a=Oi.length;r<a;r++){const o=Oi[r];o.instanceId=n,o.object=this,e.push(o)}Oi.length=0}}setColorAt(t,e){this.instanceColor===null&&(this.instanceColor=new Hn(new Float32Array(this.instanceMatrix.count*3),3)),e.toArray(this.instanceColor.array,t*3)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,t*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}class tn extends Wt{constructor(t){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new U(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.fog=t.fog,this}}const qn=new x,Yn=new x,$n=new P,Ts=new Ks,Ni=new Ne;class Ki extends H{constructor(t=new Ct,e=new tn){super(),this.isLine=!0,this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(t.index===null){const e=t.attributes.position,i=[0];for(let s=1,n=e.count;s<n;s++)qn.fromBufferAttribute(e,s-1),Yn.fromBufferAttribute(e,s),i[s]=i[s-1],i[s]+=qn.distanceTo(Yn);t.setAttribute("lineDistance",new gt(i,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(t,e){const i=this.geometry,s=this.matrixWorld,n=t.params.Line.threshold,r=i.drawRange;if(i.boundingSphere===null&&i.computeBoundingSphere(),Ni.copy(i.boundingSphere),Ni.applyMatrix4(s),Ni.radius+=n,t.ray.intersectsSphere(Ni)===!1)return;$n.copy(s).invert(),Ts.copy(t.ray).applyMatrix4($n);const a=n/((this.scale.x+this.scale.y+this.scale.z)/3),o=a*a,h=new x,l=new x,c=new x,d=new x,p=this.isLineSegments?2:1,f=i.index,g=i.attributes.position;if(f!==null){const y=Math.max(0,r.start),M=Math.min(f.count,r.start+r.count);for(let w=y,S=M-1;w<S;w+=p){const v=f.getX(w),_=f.getX(w+1);if(h.fromBufferAttribute(g,v),l.fromBufferAttribute(g,_),Ts.distanceSqToSegment(h,l,d,c)>o)continue;d.applyMatrix4(this.matrixWorld);const R=t.ray.origin.distanceTo(d);R<t.near||R>t.far||e.push({distance:R,point:c.clone().applyMatrix4(this.matrixWorld),index:w,face:null,faceIndex:null,object:this})}}else{const y=Math.max(0,r.start),M=Math.min(g.count,r.start+r.count);for(let w=y,S=M-1;w<S;w+=p){if(h.fromBufferAttribute(g,w),l.fromBufferAttribute(g,w+1),Ts.distanceSqToSegment(h,l,d,c)>o)continue;d.applyMatrix4(this.matrixWorld);const _=t.ray.origin.distanceTo(d);_<t.near||_>t.far||e.push({distance:_,point:c.clone().applyMatrix4(this.matrixWorld),index:w,face:null,faceIndex:null,object:this})}}}updateMorphTargets(){const e=this.geometry.morphAttributes,i=Object.keys(e);if(i.length>0){const s=e[i[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let n=0,r=s.length;n<r;n++){const a=s[n].name||String(n);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=n}}}}}const Kn=new x,Zn=new x;class co extends Ki{constructor(t,e){super(t,e),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(t.index===null){const e=t.attributes.position,i=[];for(let s=0,n=e.count;s<n;s+=2)Kn.fromBufferAttribute(e,s),Zn.fromBufferAttribute(e,s+1),i[s]=s===0?0:i[s-1],i[s+1]=i[s]+Kn.distanceTo(Zn);t.setAttribute("lineDistance",new gt(i,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class uo extends Ki{constructor(t,e){super(t,e),this.isLineLoop=!0,this.type="LineLoop"}}class Fr extends Wt{constructor(t){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new U(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}const Jn=new P,Ns=new Ks,Ui=new Ne,Gi=new x;class po extends H{constructor(t=new Ct,e=new Fr){super(),this.isPoints=!0,this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=t.material,this.geometry=t.geometry,this}raycast(t,e){const i=this.geometry,s=this.matrixWorld,n=t.params.Points.threshold,r=i.drawRange;if(i.boundingSphere===null&&i.computeBoundingSphere(),Ui.copy(i.boundingSphere),Ui.applyMatrix4(s),Ui.radius+=n,t.ray.intersectsSphere(Ui)===!1)return;Jn.copy(s).invert(),Ns.copy(t.ray).applyMatrix4(Jn);const a=n/((this.scale.x+this.scale.y+this.scale.z)/3),o=a*a,h=i.index,c=i.attributes.position;if(h!==null){const d=Math.max(0,r.start),p=Math.min(h.count,r.start+r.count);for(let f=d,m=p;f<m;f++){const g=h.getX(f);Gi.fromBufferAttribute(c,g),Qn(Gi,g,o,s,t,e,this)}}else{const d=Math.max(0,r.start),p=Math.min(c.count,r.start+r.count);for(let f=d,m=p;f<m;f++)Gi.fromBufferAttribute(c,f),Qn(Gi,f,o,s,t,e,this)}}updateMorphTargets(){const e=this.geometry.morphAttributes,i=Object.keys(e);if(i.length>0){const s=e[i[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let n=0,r=s.length;n<r;n++){const a=s[n].name||String(n);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=n}}}}}function Qn(u,t,e,i,s,n,r){const a=Ns.distanceSqToPoint(u);if(a<e){const o=new x;Ns.closestPointToPoint(u,o),o.applyMatrix4(i);const h=s.ray.origin.distanceTo(o);if(h<s.near||h>s.far)return;n.push({distance:h,distanceToRay:Math.sqrt(a),point:o,index:t,face:null,object:r})}}class fo{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(t,e){const i=this.getUtoTmapping(t);return this.getPoint(i,e)}getPoints(t=5){const e=[];for(let i=0;i<=t;i++)e.push(this.getPoint(i/t));return e}getSpacedPoints(t=5){const e=[];for(let i=0;i<=t;i++)e.push(this.getPointAt(i/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let i,s=this.getPoint(0),n=0;e.push(0);for(let r=1;r<=t;r++)i=this.getPoint(r/t),n+=i.distanceTo(s),e.push(n),s=i;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e){const i=this.getLengths();let s=0;const n=i.length;let r;e?r=e:r=t*i[n-1];let a=0,o=n-1,h;for(;a<=o;)if(s=Math.floor(a+(o-a)/2),h=i[s]-r,h<0)a=s+1;else if(h>0)o=s-1;else{o=s;break}if(s=o,i[s]===r)return s/(n-1);const l=i[s],d=i[s+1]-l,p=(r-l)/d;return(s+p)/(n-1)}getTangent(t,e){let s=t-1e-4,n=t+1e-4;s<0&&(s=0),n>1&&(n=1);const r=this.getPoint(s),a=this.getPoint(n),o=e||(r.isVector2?new L:new x);return o.copy(a).sub(r).normalize(),o}getTangentAt(t,e){const i=this.getUtoTmapping(t);return this.getTangent(i,e)}computeFrenetFrames(t,e){const i=new x,s=[],n=[],r=[],a=new x,o=new P;for(let p=0;p<=t;p++){const f=p/t;s[p]=this.getTangentAt(f,new x)}n[0]=new x,r[0]=new x;let h=Number.MAX_VALUE;const l=Math.abs(s[0].x),c=Math.abs(s[0].y),d=Math.abs(s[0].z);l<=h&&(h=l,i.set(1,0,0)),c<=h&&(h=c,i.set(0,1,0)),d<=h&&i.set(0,0,1),a.crossVectors(s[0],i).normalize(),n[0].crossVectors(s[0],a),r[0].crossVectors(s[0],n[0]);for(let p=1;p<=t;p++){if(n[p]=n[p-1].clone(),r[p]=r[p-1].clone(),a.crossVectors(s[p-1],s[p]),a.length()>Number.EPSILON){a.normalize();const f=Math.acos(Q(s[p-1].dot(s[p]),-1,1));n[p].applyMatrix4(o.makeRotationAxis(a,f))}r[p].crossVectors(s[p],n[p])}if(e===!0){let p=Math.acos(Q(n[0].dot(n[t]),-1,1));p/=t,s[0].dot(a.crossVectors(n[0],n[t]))>0&&(p=-p);for(let f=1;f<=t;f++)n[f].applyMatrix4(o.makeRotationAxis(s[f],p*f)),r[f].crossVectors(s[f],n[f])}return{tangents:s,normals:n,binormals:r}}clone(){return new this.constructor().copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}class en extends Wt{constructor(t){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new U(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new U(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Ys,this.normalScale=new L(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class pe extends en{constructor(t){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new L(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return Q(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(e){this.ior=(1+.4*e)/(1-.4*e)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new U(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new U(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new U(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._iridescence=0,this._transmission=0,this.setValues(t)}get sheen(){return this._sheen}set sheen(t){this._sheen>0!=t>0&&this.version++,this._sheen=t}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get iridescence(){return this._iridescence}set iridescence(t){this._iridescence>0!=t>0&&this.version++,this._iridescence=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.ior=t.ior,this.iridescence=t.iridescence,this.iridescenceMap=t.iridescenceMap,this.iridescenceIOR=t.iridescenceIOR,this.iridescenceThicknessRange=[...t.iridescenceThicknessRange],this.iridescenceThicknessMap=t.iridescenceThicknessMap,this.sheen=t.sheen,this.sheenColor.copy(t.sheenColor),this.sheenColorMap=t.sheenColorMap,this.sheenRoughness=t.sheenRoughness,this.sheenRoughnessMap=t.sheenRoughnessMap,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationColor.copy(t.attenuationColor),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularColor.copy(t.specularColor),this.specularColorMap=t.specularColorMap,this}}class Ss extends Wt{constructor(t){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new U(16777215),this.specular=new U(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new U(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Ys,this.normalScale=new L(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Ws,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class Ir extends Wt{constructor(t){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new U(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new U(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Ys,this.normalScale=new L(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Ws,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}function Kt(u,t,e){return kr(u)?new u.constructor(u.subarray(t,e!==void 0?e:u.length)):u.slice(t,e)}function Vi(u,t,e){return!u||!e&&u.constructor===t?u:typeof t.BYTES_PER_ELEMENT=="number"?new t(u):Array.prototype.slice.call(u)}function kr(u){return ArrayBuffer.isView(u)&&!(u instanceof DataView)}function mo(u){function t(s,n){return u[s]-u[n]}const e=u.length,i=new Array(e);for(let s=0;s!==e;++s)i[s]=s;return i.sort(t),i}function tr(u,t,e){const i=u.length,s=new u.constructor(i);for(let n=0,r=0;r!==i;++n){const a=e[n]*t;for(let o=0;o!==t;++o)s[r++]=u[a+o]}return s}function Lr(u,t,e,i){let s=1,n=u[0];for(;n!==void 0&&n[i]===void 0;)n=u[s++];if(n===void 0)return;let r=n[i];if(r!==void 0)if(Array.isArray(r))do r=n[i],r!==void 0&&(t.push(n.time),e.push.apply(e,r)),n=u[s++];while(n!==void 0);else if(r.toArray!==void 0)do r=n[i],r!==void 0&&(t.push(n.time),r.toArray(e,e.length)),n=u[s++];while(n!==void 0);else do r=n[i],r!==void 0&&(t.push(n.time),e.push(r)),n=u[s++];while(n!==void 0)}class yi{constructor(t,e,i,s){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=s!==void 0?s:new e.constructor(i),this.sampleValues=e,this.valueSize=i,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let i=this._cachedIndex,s=e[i],n=e[i-1];i:{t:{let r;e:{s:if(!(t<s)){for(let a=i+2;;){if(s===void 0){if(t<n)break s;return i=e.length,this._cachedIndex=i,this.copySampleValue_(i-1)}if(i===a)break;if(n=s,s=e[++i],t<s)break t}r=e.length;break e}if(!(t>=n)){const a=e[1];t<a&&(i=2,n=a);for(let o=i-2;;){if(n===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(i===o)break;if(s=n,n=e[--i-1],t>=n)break t}r=i,i=0;break e}break i}for(;i<r;){const a=i+r>>>1;t<e[a]?r=a:i=a+1}if(s=e[i],n=e[i-1],n===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(s===void 0)return i=e.length,this._cachedIndex=i,this.copySampleValue_(i-1)}this._cachedIndex=i,this.intervalChanged_(i,n,s)}return this.interpolate_(i,n,t,s)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,i=this.sampleValues,s=this.valueSize,n=t*s;for(let r=0;r!==s;++r)e[r]=i[n+r];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class go extends yi{constructor(t,e,i,s){super(t,e,i,s),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:_n,endingEnd:_n}}intervalChanged_(t,e,i){const s=this.parameterPositions;let n=t-2,r=t+1,a=s[n],o=s[r];if(a===void 0)switch(this.getSettings_().endingStart){case An:n=t,a=2*e-i;break;case En:n=s.length-2,a=e+s[n]-s[n+1];break;default:n=t,a=i}if(o===void 0)switch(this.getSettings_().endingEnd){case An:r=t,o=2*i-e;break;case En:r=1,o=i+s[1]-s[0];break;default:r=t-1,o=e}const h=(i-e)*.5,l=this.valueSize;this._weightPrev=h/(e-a),this._weightNext=h/(o-i),this._offsetPrev=n*l,this._offsetNext=r*l}interpolate_(t,e,i,s){const n=this.resultBuffer,r=this.sampleValues,a=this.valueSize,o=t*a,h=o-a,l=this._offsetPrev,c=this._offsetNext,d=this._weightPrev,p=this._weightNext,f=(i-e)/(s-e),m=f*f,g=m*f,y=-d*g+2*d*m-d*f,M=(1+d)*g+(-1.5-2*d)*m+(-.5+d)*f+1,w=(-1-p)*g+(1.5+p)*m+.5*f,S=p*g-p*m;for(let v=0;v!==a;++v)n[v]=y*r[l+v]+M*r[h+v]+w*r[o+v]+S*r[c+v];return n}}class yo extends yi{constructor(t,e,i,s){super(t,e,i,s)}interpolate_(t,e,i,s){const n=this.resultBuffer,r=this.sampleValues,a=this.valueSize,o=t*a,h=o-a,l=(i-e)/(s-e),c=1-l;for(let d=0;d!==a;++d)n[d]=r[h+d]*c+r[o+d]*l;return n}}class xo extends yi{constructor(t,e,i,s){super(t,e,i,s)}interpolate_(t){return this.copySampleValue_(t-1)}}class Ft{constructor(t,e,i,s){if(t===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(e===void 0||e.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=Vi(e,this.TimeBufferType),this.values=Vi(i,this.ValueBufferType),this.setInterpolation(s||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let i;if(e.toJSON!==this.toJSON)i=e.toJSON(t);else{i={name:t.name,times:Vi(t.times,Array),values:Vi(t.values,Array)};const s=t.getInterpolation();s!==t.DefaultInterpolation&&(i.interpolation=s)}return i.type=t.ValueTypeName,i}InterpolantFactoryMethodDiscrete(t){return new xo(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new yo(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new go(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case di:e=this.InterpolantFactoryMethodDiscrete;break;case Le:e=this.InterpolantFactoryMethodLinear;break;case es:e=this.InterpolantFactoryMethodSmooth;break}if(e===void 0){const i="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(t!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(i);return console.warn("THREE.KeyframeTrack:",i),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return di;case this.InterpolantFactoryMethodLinear:return Le;case this.InterpolantFactoryMethodSmooth:return es}}getValueSize(){return this.values.length/this.times.length}shift(t){if(t!==0){const e=this.times;for(let i=0,s=e.length;i!==s;++i)e[i]+=t}return this}scale(t){if(t!==1){const e=this.times;for(let i=0,s=e.length;i!==s;++i)e[i]*=t}return this}trim(t,e){const i=this.times,s=i.length;let n=0,r=s-1;for(;n!==s&&i[n]<t;)++n;for(;r!==-1&&i[r]>e;)--r;if(++r,n!==0||r!==s){n>=r&&(r=Math.max(r,1),n=r-1);const a=this.getValueSize();this.times=Kt(i,n,r),this.values=Kt(this.values,n*a,r*a)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const i=this.times,s=this.values,n=i.length;n===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let r=null;for(let a=0;a!==n;a++){const o=i[a];if(typeof o=="number"&&isNaN(o)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,a,o),t=!1;break}if(r!==null&&r>o){console.error("THREE.KeyframeTrack: Out of order keys.",this,a,o,r),t=!1;break}r=o}if(s!==void 0&&kr(s))for(let a=0,o=s.length;a!==o;++a){const h=s[a];if(isNaN(h)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,a,h),t=!1;break}}return t}optimize(){const t=Kt(this.times),e=Kt(this.values),i=this.getValueSize(),s=this.getInterpolation()===es,n=t.length-1;let r=1;for(let a=1;a<n;++a){let o=!1;const h=t[a],l=t[a+1];if(h!==l&&(a!==1||h!==t[0]))if(s)o=!0;else{const c=a*i,d=c-i,p=c+i;for(let f=0;f!==i;++f){const m=e[c+f];if(m!==e[d+f]||m!==e[p+f]){o=!0;break}}}if(o){if(a!==r){t[r]=t[a];const c=a*i,d=r*i;for(let p=0;p!==i;++p)e[d+p]=e[c+p]}++r}}if(n>0){t[r]=t[n];for(let a=n*i,o=r*i,h=0;h!==i;++h)e[o+h]=e[a+h];++r}return r!==t.length?(this.times=Kt(t,0,r),this.values=Kt(e,0,r*i)):(this.times=t,this.values=e),this}clone(){const t=Kt(this.times,0),e=Kt(this.values,0),i=this.constructor,s=new i(this.name,t,e);return s.createInterpolant=this.createInterpolant,s}}Ft.prototype.TimeBufferType=Float32Array;Ft.prototype.ValueBufferType=Float32Array;Ft.prototype.DefaultInterpolation=Le;class Ge extends Ft{}Ge.prototype.ValueTypeName="bool";Ge.prototype.ValueBufferType=Array;Ge.prototype.DefaultInterpolation=di;Ge.prototype.InterpolantFactoryMethodLinear=void 0;Ge.prototype.InterpolantFactoryMethodSmooth=void 0;class zr extends Ft{}zr.prototype.ValueTypeName="color";class ze extends Ft{}ze.prototype.ValueTypeName="number";class bo extends yi{constructor(t,e,i,s){super(t,e,i,s)}interpolate_(t,e,i,s){const n=this.resultBuffer,r=this.sampleValues,a=this.valueSize,o=(i-e)/(s-e);let h=t*a;for(let l=h+a;h!==l;h+=4)ot.slerpFlat(n,0,r,h-a,r,h,o);return n}}class se extends Ft{InterpolantFactoryMethodLinear(t){return new bo(this.times,this.values,this.getValueSize(),t)}}se.prototype.ValueTypeName="quaternion";se.prototype.DefaultInterpolation=Le;se.prototype.InterpolantFactoryMethodSmooth=void 0;class Ve extends Ft{}Ve.prototype.ValueTypeName="string";Ve.prototype.ValueBufferType=Array;Ve.prototype.DefaultInterpolation=di;Ve.prototype.InterpolantFactoryMethodLinear=void 0;Ve.prototype.InterpolantFactoryMethodSmooth=void 0;class Be extends Ft{}Be.prototype.ValueTypeName="vector";class Br{constructor(t,e=-1,i,s=wa){this.name=t,this.tracks=i,this.duration=e,this.blendMode=s,this.uuid=_t(),this.duration<0&&this.resetDuration()}static parse(t){const e=[],i=t.tracks,s=1/(t.fps||1);for(let r=0,a=i.length;r!==a;++r)e.push(Mo(i[r]).scale(s));const n=new this(t.name,t.duration,e,t.blendMode);return n.uuid=t.uuid,n}static toJSON(t){const e=[],i=t.tracks,s={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let n=0,r=i.length;n!==r;++n)e.push(Ft.toJSON(i[n]));return s}static CreateFromMorphTargetSequence(t,e,i,s){const n=e.length,r=[];for(let a=0;a<n;a++){let o=[],h=[];o.push((a+n-1)%n,a,(a+1)%n),h.push(0,1,0);const l=mo(o);o=tr(o,1,l),h=tr(h,1,l),!s&&o[0]===0&&(o.push(n),h.push(h[0])),r.push(new ze(".morphTargetInfluences["+e[a].name+"]",o,h).scale(1/i))}return new this(t,-1,r)}static findByName(t,e){let i=t;if(!Array.isArray(t)){const s=t;i=s.geometry&&s.geometry.animations||s.animations}for(let s=0;s<i.length;s++)if(i[s].name===e)return i[s];return null}static CreateClipsFromMorphTargetSequences(t,e,i){const s={},n=/^([\w-]*?)([\d]+)$/;for(let a=0,o=t.length;a<o;a++){const h=t[a],l=h.name.match(n);if(l&&l.length>1){const c=l[1];let d=s[c];d||(s[c]=d=[]),d.push(h)}}const r=[];for(const a in s)r.push(this.CreateFromMorphTargetSequence(a,s[a],e,i));return r}static parseAnimation(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const i=function(c,d,p,f,m){if(p.length!==0){const g=[],y=[];Lr(p,g,y,f),g.length!==0&&m.push(new c(d,g,y))}},s=[],n=t.name||"default",r=t.fps||30,a=t.blendMode;let o=t.length||-1;const h=t.hierarchy||[];for(let c=0;c<h.length;c++){const d=h[c].keys;if(!(!d||d.length===0))if(d[0].morphTargets){const p={};let f;for(f=0;f<d.length;f++)if(d[f].morphTargets)for(let m=0;m<d[f].morphTargets.length;m++)p[d[f].morphTargets[m]]=-1;for(const m in p){const g=[],y=[];for(let M=0;M!==d[f].morphTargets.length;++M){const w=d[f];g.push(w.time),y.push(w.morphTarget===m?1:0)}s.push(new ze(".morphTargetInfluence["+m+"]",g,y))}o=p.length*r}else{const p=".bones["+e[c].name+"]";i(Be,p+".position",d,"pos",s),i(se,p+".quaternion",d,"rot",s),i(Be,p+".scale",d,"scl",s)}}return s.length===0?null:new this(n,o,s,a)}resetDuration(){const t=this.tracks;let e=0;for(let i=0,s=t.length;i!==s;++i){const n=this.tracks[i];e=Math.max(e,n.times[n.times.length-1])}return this.duration=e,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function wo(u){switch(u.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return ze;case"vector":case"vector2":case"vector3":case"vector4":return Be;case"color":return zr;case"quaternion":return se;case"bool":case"boolean":return Ge;case"string":return Ve}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+u)}function Mo(u){if(u.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=wo(u.type);if(u.times===void 0){const e=[],i=[];Lr(u.keys,e,i,"value"),u.times=e,u.values=i}return t.parse!==void 0?t.parse(u):new t(u.name,u.times,u.values,u.interpolation)}const De={enabled:!1,files:{},add:function(u,t){this.enabled!==!1&&(this.files[u]=t)},get:function(u){if(this.enabled!==!1)return this.files[u]},remove:function(u){delete this.files[u]},clear:function(){this.files={}}};class vo{constructor(t,e,i){const s=this;let n=!1,r=0,a=0,o;const h=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=i,this.itemStart=function(l){a++,n===!1&&s.onStart!==void 0&&s.onStart(l,r,a),n=!0},this.itemEnd=function(l){r++,s.onProgress!==void 0&&s.onProgress(l,r,a),r===a&&(n=!1,s.onLoad!==void 0&&s.onLoad())},this.itemError=function(l){s.onError!==void 0&&s.onError(l)},this.resolveURL=function(l){return o?o(l):l},this.setURLModifier=function(l){return o=l,this},this.addHandler=function(l,c){return h.push(l,c),this},this.removeHandler=function(l){const c=h.indexOf(l);return c!==-1&&h.splice(c,2),this},this.getHandler=function(l){for(let c=0,d=h.length;c<d;c+=2){const p=h[c],f=h[c+1];if(p.global&&(p.lastIndex=0),p.test(l))return f}return null}}}const To=new vo;let fe=class{constructor(t){this.manager=t!==void 0?t:To,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const i=this;return new Promise(function(s,n){i.load(t,s,e,n)})}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}};const Ut={};class So extends Error{constructor(t,e){super(t),this.response=e}}class sn extends fe{constructor(t){super(t)}load(t,e,i,s){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const n=De.get(t);if(n!==void 0)return this.manager.itemStart(t),setTimeout(()=>{e&&e(n),this.manager.itemEnd(t)},0),n;if(Ut[t]!==void 0){Ut[t].push({onLoad:e,onProgress:i,onError:s});return}Ut[t]=[],Ut[t].push({onLoad:e,onProgress:i,onError:s});const r=new Request(t,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),a=this.mimeType,o=this.responseType;fetch(r).then(h=>{if(h.status===200||h.status===0){if(h.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||h.body===void 0||h.body.getReader===void 0)return h;const l=Ut[t],c=h.body.getReader(),d=h.headers.get("Content-Length")||h.headers.get("X-File-Size"),p=d?parseInt(d):0,f=p!==0;let m=0;const g=new ReadableStream({start(y){M();function M(){c.read().then(({done:w,value:S})=>{if(w)y.close();else{m+=S.byteLength;const v=new ProgressEvent("progress",{lengthComputable:f,loaded:m,total:p});for(let _=0,A=l.length;_<A;_++){const R=l[_];R.onProgress&&R.onProgress(v)}y.enqueue(S),M()}})}}});return new Response(g)}else throw new So(`fetch for "${h.url}" responded with ${h.status}: ${h.statusText}`,h)}).then(h=>{switch(o){case"arraybuffer":return h.arrayBuffer();case"blob":return h.blob();case"document":return h.text().then(l=>new DOMParser().parseFromString(l,a));case"json":return h.json();default:if(a===void 0)return h.text();{const c=/charset="?([^;"\s]*)"?/i.exec(a),d=c&&c[1]?c[1].toLowerCase():void 0,p=new TextDecoder(d);return h.arrayBuffer().then(f=>p.decode(f))}}}).then(h=>{De.add(t,h);const l=Ut[t];delete Ut[t];for(let c=0,d=l.length;c<d;c++){const p=l[c];p.onLoad&&p.onLoad(h)}}).catch(h=>{const l=Ut[t];if(l===void 0)throw this.manager.itemError(t),h;delete Ut[t];for(let c=0,d=l.length;c<d;c++){const p=l[c];p.onError&&p.onError(h)}this.manager.itemError(t)}).finally(()=>{this.manager.itemEnd(t)}),this.manager.itemStart(t)}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}class Dr extends fe{constructor(t){super(t)}load(t,e,i,s){this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const n=this,r=De.get(t);if(r!==void 0)return n.manager.itemStart(t),setTimeout(function(){e&&e(r),n.manager.itemEnd(t)},0),r;const a=Os("img");function o(){l(),De.add(t,this),e&&e(this),n.manager.itemEnd(t)}function h(c){l(),s&&s(c),n.manager.itemError(t),n.manager.itemEnd(t)}function l(){a.removeEventListener("load",o,!1),a.removeEventListener("error",h,!1)}return a.addEventListener("load",o,!1),a.addEventListener("error",h,!1),t.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(a.crossOrigin=this.crossOrigin),n.manager.itemStart(t),a.src=t,a}}class _o extends fe{constructor(t){super(t)}load(t,e,i,s){const n=new eo,r=new Dr(this.manager);r.setCrossOrigin(this.crossOrigin),r.setPath(this.path);let a=0;function o(h){r.load(t[h],function(l){n.images[h]=l,a++,a===6&&(n.needsUpdate=!0,e&&e(n))},void 0,s)}for(let h=0;h<t.length;++h)o(h);return n}}class nn extends fe{constructor(t){super(t)}load(t,e,i,s){const n=new ht,r=new Dr(this.manager);return r.setCrossOrigin(this.crossOrigin),r.setPath(this.path),r.load(t,function(a){n.image=a,n.needsUpdate=!0,e!==void 0&&e(n)},i,s),n}}class Zi extends H{constructor(t,e=1){super(),this.isLight=!0,this.type="Light",this.color=new U(t),this.intensity=e}dispose(){}copy(t,e){return super.copy(t,e),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,this.groundColor!==void 0&&(e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(e.object.distance=this.distance),this.angle!==void 0&&(e.object.angle=this.angle),this.decay!==void 0&&(e.object.decay=this.decay),this.penumbra!==void 0&&(e.object.penumbra=this.penumbra),this.shadow!==void 0&&(e.object.shadow=this.shadow.toJSON()),e}}const _s=new P,er=new x,ir=new x;class rn{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new L(512,512),this.map=null,this.mapPass=null,this.matrix=new P,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Cr,this._frameExtents=new L(1,1),this._viewportCount=1,this._viewports=[new it(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,i=this.matrix;er.setFromMatrixPosition(t.matrixWorld),e.position.copy(er),ir.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(ir),e.updateMatrixWorld(),_s.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(_s),i.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),i.multiply(_s)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const t={};return this.bias!==0&&(t.bias=this.bias),this.normalBias!==0&&(t.normalBias=this.normalBias),this.radius!==1&&(t.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class Ao extends rn{constructor(){super(new gi(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(t){const e=this.camera,i=pi*2*t.angle*this.focus,s=this.mapSize.width/this.mapSize.height,n=t.distance||e.far;(i!==e.fov||s!==e.aspect||n!==e.far)&&(e.fov=i,e.aspect=s,e.far=n,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}class Or extends Zi{constructor(t,e,i=0,s=Math.PI/3,n=0,r=2){super(t,e),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(H.DefaultUp),this.updateMatrix(),this.target=new H,this.distance=i,this.angle=s,this.penumbra=n,this.decay=r,this.map=null,this.shadow=new Ao}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}const sr=new P,ti=new x,As=new x;class Eo extends rn{constructor(){super(new gi(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new L(4,2),this._viewportCount=6,this._viewports=[new it(2,1,1,1),new it(0,1,1,1),new it(3,1,1,1),new it(1,1,1,1),new it(3,0,1,1),new it(1,0,1,1)],this._cubeDirections=[new x(1,0,0),new x(-1,0,0),new x(0,0,1),new x(0,0,-1),new x(0,1,0),new x(0,-1,0)],this._cubeUps=[new x(0,1,0),new x(0,1,0),new x(0,1,0),new x(0,1,0),new x(0,0,1),new x(0,0,-1)]}updateMatrices(t,e=0){const i=this.camera,s=this.matrix,n=t.distance||i.far;n!==i.far&&(i.far=n,i.updateProjectionMatrix()),ti.setFromMatrixPosition(t.matrixWorld),i.position.copy(ti),As.copy(i.position),As.add(this._cubeDirections[e]),i.up.copy(this._cubeUps[e]),i.lookAt(As),i.updateMatrixWorld(),s.makeTranslation(-ti.x,-ti.y,-ti.z),sr.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),this._frustum.setFromProjectionMatrix(sr)}}class Us extends Zi{constructor(t,e,i=0,s=2){super(t,e),this.isPointLight=!0,this.type="PointLight",this.distance=i,this.decay=s,this.shadow=new Eo}get power(){return this.intensity*4*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}class Po extends rn{constructor(){super(new Js(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}let an=class extends Zi{constructor(t,e){super(t,e),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(H.DefaultUp),this.updateMatrix(),this.target=new H,this.shadow=new Po}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}};class Co extends Zi{constructor(t,e){super(t,e),this.isAmbientLight=!0,this.type="AmbientLight"}}class Rt{static decodeText(t){if(typeof TextDecoder<"u")return new TextDecoder().decode(t);let e="";for(let i=0,s=t.length;i<s;i++)e+=String.fromCharCode(t[i]);try{return decodeURIComponent(escape(e))}catch{return e}}static extractUrlBase(t){const e=t.lastIndexOf("/");return e===-1?"./":t.slice(0,e+1)}static resolveURL(t,e){return typeof t!="string"||t===""?"":(/^https?:\/\//i.test(e)&&/^\//.test(t)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(t)||/^data:.*,.*$/i.test(t)||/^blob:.*$/i.test(t)?t:e+t)}}class Ro extends fe{constructor(t){super(t),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(t){return this.options=t,this}load(t,e,i,s){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const n=this,r=De.get(t);if(r!==void 0)return n.manager.itemStart(t),setTimeout(function(){e&&e(r),n.manager.itemEnd(t)},0),r;const a={};a.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",a.headers=this.requestHeader,fetch(t,a).then(function(o){return o.blob()}).then(function(o){return createImageBitmap(o,Object.assign(n.options,{colorSpaceConversion:"none"}))}).then(function(o){De.add(t,o),e&&e(o),n.manager.itemEnd(t)}).catch(function(o){s&&s(o),n.manager.itemError(t),n.manager.itemEnd(t)}),n.manager.itemStart(t)}}const on="\\[\\]\\.:\\/",Fo=new RegExp("["+on+"]","g"),hn="[^"+on+"]",Io="[^"+on.replace("\\.","")+"]",ko=/((?:WC+[\/:])*)/.source.replace("WC",hn),Lo=/(WCOD+)?/.source.replace("WCOD",Io),zo=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",hn),Bo=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",hn),Do=new RegExp("^"+ko+Lo+zo+Bo+"$"),Oo=["material","materials","bones","map"];class No{constructor(t,e,i){const s=i||B.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,s)}getValue(t,e){this.bind();const i=this._targetGroup.nCachedObjects_,s=this._bindings[i];s!==void 0&&s.getValue(t,e)}setValue(t,e){const i=this._bindings;for(let s=this._targetGroup.nCachedObjects_,n=i.length;s!==n;++s)i[s].setValue(t,e)}bind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,i=t.length;e!==i;++e)t[e].bind()}unbind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,i=t.length;e!==i;++e)t[e].unbind()}}class B{constructor(t,e,i){this.path=e,this.parsedPath=i||B.parseTrackName(e),this.node=B.findNode(t,this.parsedPath.nodeName)||t,this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,i){return t&&t.isAnimationObjectGroup?new B.Composite(t,e,i):new B(t,e,i)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(Fo,"")}static parseTrackName(t){const e=Do.exec(t);if(e===null)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const i={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},s=i.nodeName&&i.nodeName.lastIndexOf(".");if(s!==void 0&&s!==-1){const n=i.nodeName.substring(s+1);Oo.indexOf(n)!==-1&&(i.nodeName=i.nodeName.substring(0,s),i.objectName=n)}if(i.propertyName===null||i.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return i}static findNode(t,e){if(e===void 0||e===""||e==="."||e===-1||e===t.name||e===t.uuid)return t;if(t.skeleton){const i=t.skeleton.getBoneByName(e);if(i!==void 0)return i}if(t.children){const i=function(n){for(let r=0;r<n.length;r++){const a=n[r];if(a.name===e||a.uuid===e)return a;const o=i(a.children);if(o)return o}return null},s=i(t.children);if(s)return s}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.targetObject[this.propertyName]}_getValue_array(t,e){const i=this.resolvedProperty;for(let s=0,n=i.length;s!==n;++s)t[e++]=i[s]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){const i=this.resolvedProperty;for(let s=0,n=i.length;s!==n;++s)i[s]=t[e++]}_setValue_array_setNeedsUpdate(t,e){const i=this.resolvedProperty;for(let s=0,n=i.length;s!==n;++s)i[s]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){const i=this.resolvedProperty;for(let s=0,n=i.length;s!==n;++s)i[s]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,i=e.objectName,s=e.propertyName;let n=e.propertyIndex;if(t||(t=B.findNode(this.rootNode,e.nodeName)||this.rootNode,this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(i){let h=e.objectIndex;switch(i){case"materials":if(!t.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!t.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}t=t.material.materials;break;case"bones":if(!t.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}t=t.skeleton.bones;for(let l=0;l<t.length;l++)if(t[l].name===h){h=l;break}break;case"map":if("map"in t){t=t.map;break}if(!t.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!t.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}t=t.material.map;break;default:if(t[i]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}t=t[i]}if(h!==void 0){if(t[h]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);return}t=t[h]}}const r=t[s];if(r===void 0){const h=e.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+h+"."+s+" but it wasn't found.",t);return}let a=this.Versioning.None;this.targetObject=t,t.needsUpdate!==void 0?a=this.Versioning.NeedsUpdate:t.matrixWorldNeedsUpdate!==void 0&&(a=this.Versioning.MatrixWorldNeedsUpdate);let o=this.BindingType.Direct;if(n!==void 0){if(s==="morphTargetInfluences"){if(!t.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!t.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}t.morphTargetDictionary[n]!==void 0&&(n=t.morphTargetDictionary[n])}o=this.BindingType.ArrayElement,this.resolvedProperty=r,this.propertyIndex=n}else r.fromArray!==void 0&&r.toArray!==void 0?(o=this.BindingType.HasFromToArray,this.resolvedProperty=r):Array.isArray(r)?(o=this.BindingType.EntireArray,this.resolvedProperty=r):this.propertyName=s;this.getValue=this.GetterByBindingType[o],this.setValue=this.SetterByBindingTypeAndVersioning[o][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}B.Composite=No;B.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};B.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};B.prototype.GetterByBindingType=[B.prototype._getValue_direct,B.prototype._getValue_array,B.prototype._getValue_arrayElement,B.prototype._getValue_toArray];B.prototype.SetterByBindingTypeAndVersioning=[[B.prototype._setValue_direct,B.prototype._setValue_direct_setNeedsUpdate,B.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[B.prototype._setValue_array,B.prototype._setValue_array_setNeedsUpdate,B.prototype._setValue_array_setMatrixWorldNeedsUpdate],[B.prototype._setValue_arrayElement,B.prototype._setValue_arrayElement_setNeedsUpdate,B.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[B.prototype._setValue_fromArray,B.prototype._setValue_fromArray_setNeedsUpdate,B.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class nr{constructor(t=1,e=0,i=0){return this.radius=t,this.phi=e,this.theta=i,this}set(t,e,i){return this.radius=t,this.phi=e,this.theta=i,this}copy(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,i){return this.radius=Math.sqrt(t*t+e*e+i*i),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t,i),this.phi=Math.acos(Q(e/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Mr}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Mr);const rr={type:"change"},Es={type:"start"},ar={type:"end"};class Uo extends mi{constructor(t,e){super(),this.object=t,this.domElement=e,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new x,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:ye.ROTATE,MIDDLE:ye.DOLLY,RIGHT:ye.PAN},this.touches={ONE:xe.ROTATE,TWO:xe.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return a.phi},this.getAzimuthalAngle=function(){return a.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(b){b.addEventListener("keydown",bn),this._domElementKeyEvents=b},this.saveState=function(){i.target0.copy(i.target),i.position0.copy(i.object.position),i.zoom0=i.object.zoom},this.reset=function(){i.target.copy(i.target0),i.object.position.copy(i.position0),i.object.zoom=i.zoom0,i.object.updateProjectionMatrix(),i.dispatchEvent(rr),i.update(),n=s.NONE},this.update=function(){const b=new x,F=new ot().setFromUnitVectors(t.up,new x(0,1,0)),K=F.clone().invert(),tt=new x,bt=new ot,ge=2*Math.PI;return function(){const Tn=i.object.position;b.copy(Tn).sub(i.target),b.applyQuaternion(F),a.setFromVector3(b),i.autoRotate&&n===s.NONE&&G(A()),i.enableDamping?(a.theta+=o.theta*i.dampingFactor,a.phi+=o.phi*i.dampingFactor):(a.theta+=o.theta,a.phi+=o.phi);let kt=i.minAzimuthAngle,Lt=i.maxAzimuthAngle;return isFinite(kt)&&isFinite(Lt)&&(kt<-Math.PI?kt+=ge:kt>Math.PI&&(kt-=ge),Lt<-Math.PI?Lt+=ge:Lt>Math.PI&&(Lt-=ge),kt<=Lt?a.theta=Math.max(kt,Math.min(Lt,a.theta)):a.theta=a.theta>(kt+Lt)/2?Math.max(kt,a.theta):Math.min(Lt,a.theta)),a.phi=Math.max(i.minPolarAngle,Math.min(i.maxPolarAngle,a.phi)),a.makeSafe(),a.radius*=h,a.radius=Math.max(i.minDistance,Math.min(i.maxDistance,a.radius)),i.enableDamping===!0?i.target.addScaledVector(l,i.dampingFactor):i.target.add(l),b.setFromSpherical(a),b.applyQuaternion(K),Tn.copy(i.target).add(b),i.object.lookAt(i.target),i.enableDamping===!0?(o.theta*=1-i.dampingFactor,o.phi*=1-i.dampingFactor,l.multiplyScalar(1-i.dampingFactor)):(o.set(0,0,0),l.set(0,0,0)),h=1,c||tt.distanceToSquared(i.object.position)>r||8*(1-bt.dot(i.object.quaternion))>r?(i.dispatchEvent(rr),tt.copy(i.object.position),bt.copy(i.object.quaternion),c=!1,!0):!1}}(),this.dispose=function(){i.domElement.removeEventListener("contextmenu",wn),i.domElement.removeEventListener("pointerdown",gn),i.domElement.removeEventListener("pointercancel",yn),i.domElement.removeEventListener("wheel",xn),i.domElement.removeEventListener("pointermove",Ji),i.domElement.removeEventListener("pointerup",Qi),i._domElementKeyEvents!==null&&i._domElementKeyEvents.removeEventListener("keydown",bn)};const i=this,s={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let n=s.NONE;const r=1e-6,a=new nr,o=new nr;let h=1;const l=new x;let c=!1;const d=new L,p=new L,f=new L,m=new L,g=new L,y=new L,M=new L,w=new L,S=new L,v=[],_={};function A(){return 2*Math.PI/60/60*i.autoRotateSpeed}function R(){return Math.pow(.95,i.zoomSpeed)}function G(b){o.theta-=b}function C(b){o.phi-=b}const O=function(){const b=new x;return function(K,tt){b.setFromMatrixColumn(tt,0),b.multiplyScalar(-K),l.add(b)}}(),z=function(){const b=new x;return function(K,tt){i.screenSpacePanning===!0?b.setFromMatrixColumn(tt,1):(b.setFromMatrixColumn(tt,0),b.crossVectors(i.object.up,b)),b.multiplyScalar(K),l.add(b)}}(),I=function(){const b=new x;return function(K,tt){const bt=i.domElement;if(i.object.isPerspectiveCamera){const ge=i.object.position;b.copy(ge).sub(i.target);let Mi=b.length();Mi*=Math.tan(i.object.fov/2*Math.PI/180),O(2*K*Mi/bt.clientHeight,i.object.matrix),z(2*tt*Mi/bt.clientHeight,i.object.matrix)}else i.object.isOrthographicCamera?(O(K*(i.object.right-i.object.left)/i.object.zoom/bt.clientWidth,i.object.matrix),z(tt*(i.object.top-i.object.bottom)/i.object.zoom/bt.clientHeight,i.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),i.enablePan=!1)}}();function X(b){i.object.isPerspectiveCamera?h/=b:i.object.isOrthographicCamera?(i.object.zoom=Math.max(i.minZoom,Math.min(i.maxZoom,i.object.zoom*b)),i.object.updateProjectionMatrix(),c=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),i.enableZoom=!1)}function N(b){i.object.isPerspectiveCamera?h*=b:i.object.isOrthographicCamera?(i.object.zoom=Math.max(i.minZoom,Math.min(i.maxZoom,i.object.zoom/b)),i.object.updateProjectionMatrix(),c=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),i.enableZoom=!1)}function W(b){d.set(b.clientX,b.clientY)}function Et(b){M.set(b.clientX,b.clientY)}function xt(b){m.set(b.clientX,b.clientY)}function Pt(b){p.set(b.clientX,b.clientY),f.subVectors(p,d).multiplyScalar(i.rotateSpeed);const F=i.domElement;G(2*Math.PI*f.x/F.clientHeight),C(2*Math.PI*f.y/F.clientHeight),d.copy(p),i.update()}function lt(b){w.set(b.clientX,b.clientY),S.subVectors(w,M),S.y>0?X(R()):S.y<0&&N(R()),M.copy(w),i.update()}function It(b){g.set(b.clientX,b.clientY),y.subVectors(g,m).multiplyScalar(i.panSpeed),I(y.x,y.y),m.copy(g),i.update()}function re(b){b.deltaY<0?N(R()):b.deltaY>0&&X(R()),i.update()}function je(b){let F=!1;switch(b.code){case i.keys.UP:b.ctrlKey||b.metaKey||b.shiftKey?C(2*Math.PI*i.rotateSpeed/i.domElement.clientHeight):I(0,i.keyPanSpeed),F=!0;break;case i.keys.BOTTOM:b.ctrlKey||b.metaKey||b.shiftKey?C(-2*Math.PI*i.rotateSpeed/i.domElement.clientHeight):I(0,-i.keyPanSpeed),F=!0;break;case i.keys.LEFT:b.ctrlKey||b.metaKey||b.shiftKey?G(2*Math.PI*i.rotateSpeed/i.domElement.clientHeight):I(i.keyPanSpeed,0),F=!0;break;case i.keys.RIGHT:b.ctrlKey||b.metaKey||b.shiftKey?G(-2*Math.PI*i.rotateSpeed/i.domElement.clientHeight):I(-i.keyPanSpeed,0),F=!0;break}F&&(b.preventDefault(),i.update())}function me(){if(v.length===1)d.set(v[0].pageX,v[0].pageY);else{const b=.5*(v[0].pageX+v[1].pageX),F=.5*(v[0].pageY+v[1].pageY);d.set(b,F)}}function He(){if(v.length===1)m.set(v[0].pageX,v[0].pageY);else{const b=.5*(v[0].pageX+v[1].pageX),F=.5*(v[0].pageY+v[1].pageY);m.set(b,F)}}function We(){const b=v[0].pageX-v[1].pageX,F=v[0].pageY-v[1].pageY,K=Math.sqrt(b*b+F*F);M.set(0,K)}function bi(){i.enableZoom&&We(),i.enablePan&&He()}function wi(){i.enableZoom&&We(),i.enableRotate&&me()}function pn(b){if(v.length==1)p.set(b.pageX,b.pageY);else{const K=ts(b),tt=.5*(b.pageX+K.x),bt=.5*(b.pageY+K.y);p.set(tt,bt)}f.subVectors(p,d).multiplyScalar(i.rotateSpeed);const F=i.domElement;G(2*Math.PI*f.x/F.clientHeight),C(2*Math.PI*f.y/F.clientHeight),d.copy(p)}function fn(b){if(v.length===1)g.set(b.pageX,b.pageY);else{const F=ts(b),K=.5*(b.pageX+F.x),tt=.5*(b.pageY+F.y);g.set(K,tt)}y.subVectors(g,m).multiplyScalar(i.panSpeed),I(y.x,y.y),m.copy(g)}function mn(b){const F=ts(b),K=b.pageX-F.x,tt=b.pageY-F.y,bt=Math.sqrt(K*K+tt*tt);w.set(0,bt),S.set(0,Math.pow(w.y/M.y,i.zoomSpeed)),X(S.y),M.copy(w)}function Jr(b){i.enableZoom&&mn(b),i.enablePan&&fn(b)}function Qr(b){i.enableZoom&&mn(b),i.enableRotate&&pn(b)}function gn(b){i.enabled!==!1&&(v.length===0&&(i.domElement.setPointerCapture(b.pointerId),i.domElement.addEventListener("pointermove",Ji),i.domElement.addEventListener("pointerup",Qi)),na(b),b.pointerType==="touch"?ia(b):ta(b))}function Ji(b){i.enabled!==!1&&(b.pointerType==="touch"?sa(b):ea(b))}function Qi(b){Mn(b),v.length===0&&(i.domElement.releasePointerCapture(b.pointerId),i.domElement.removeEventListener("pointermove",Ji),i.domElement.removeEventListener("pointerup",Qi)),i.dispatchEvent(ar),n=s.NONE}function yn(b){Mn(b)}function ta(b){let F;switch(b.button){case 0:F=i.mouseButtons.LEFT;break;case 1:F=i.mouseButtons.MIDDLE;break;case 2:F=i.mouseButtons.RIGHT;break;default:F=-1}switch(F){case ye.DOLLY:if(i.enableZoom===!1)return;Et(b),n=s.DOLLY;break;case ye.ROTATE:if(b.ctrlKey||b.metaKey||b.shiftKey){if(i.enablePan===!1)return;xt(b),n=s.PAN}else{if(i.enableRotate===!1)return;W(b),n=s.ROTATE}break;case ye.PAN:if(b.ctrlKey||b.metaKey||b.shiftKey){if(i.enableRotate===!1)return;W(b),n=s.ROTATE}else{if(i.enablePan===!1)return;xt(b),n=s.PAN}break;default:n=s.NONE}n!==s.NONE&&i.dispatchEvent(Es)}function ea(b){switch(n){case s.ROTATE:if(i.enableRotate===!1)return;Pt(b);break;case s.DOLLY:if(i.enableZoom===!1)return;lt(b);break;case s.PAN:if(i.enablePan===!1)return;It(b);break}}function xn(b){i.enabled===!1||i.enableZoom===!1||n!==s.NONE||(b.preventDefault(),i.dispatchEvent(Es),re(b),i.dispatchEvent(ar))}function bn(b){i.enabled===!1||i.enablePan===!1||je(b)}function ia(b){switch(vn(b),v.length){case 1:switch(i.touches.ONE){case xe.ROTATE:if(i.enableRotate===!1)return;me(),n=s.TOUCH_ROTATE;break;case xe.PAN:if(i.enablePan===!1)return;He(),n=s.TOUCH_PAN;break;default:n=s.NONE}break;case 2:switch(i.touches.TWO){case xe.DOLLY_PAN:if(i.enableZoom===!1&&i.enablePan===!1)return;bi(),n=s.TOUCH_DOLLY_PAN;break;case xe.DOLLY_ROTATE:if(i.enableZoom===!1&&i.enableRotate===!1)return;wi(),n=s.TOUCH_DOLLY_ROTATE;break;default:n=s.NONE}break;default:n=s.NONE}n!==s.NONE&&i.dispatchEvent(Es)}function sa(b){switch(vn(b),n){case s.TOUCH_ROTATE:if(i.enableRotate===!1)return;pn(b),i.update();break;case s.TOUCH_PAN:if(i.enablePan===!1)return;fn(b),i.update();break;case s.TOUCH_DOLLY_PAN:if(i.enableZoom===!1&&i.enablePan===!1)return;Jr(b),i.update();break;case s.TOUCH_DOLLY_ROTATE:if(i.enableZoom===!1&&i.enableRotate===!1)return;Qr(b),i.update();break;default:n=s.NONE}}function wn(b){i.enabled!==!1&&b.preventDefault()}function na(b){v.push(b)}function Mn(b){delete _[b.pointerId];for(let F=0;F<v.length;F++)if(v[F].pointerId==b.pointerId){v.splice(F,1);return}}function vn(b){let F=_[b.pointerId];F===void 0&&(F=new L,_[b.pointerId]=F),F.set(b.pageX,b.pageY)}function ts(b){const F=b.pointerId===v[0].pointerId?v[1]:v[0];return _[F.pointerId]}i.domElement.addEventListener("contextmenu",wn),i.domElement.addEventListener("pointerdown",gn),i.domElement.addEventListener("pointercancel",yn),i.domElement.addEventListener("wheel",xn,{passive:!1}),this.update()}}class Go extends fe{constructor(t){super(t),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(e){return new Xo(e)}),this.register(function(e){return new Qo(e)}),this.register(function(e){return new th(e)}),this.register(function(e){return new Yo(e)}),this.register(function(e){return new $o(e)}),this.register(function(e){return new Ko(e)}),this.register(function(e){return new Zo(e)}),this.register(function(e){return new Wo(e)}),this.register(function(e){return new Jo(e)}),this.register(function(e){return new qo(e)}),this.register(function(e){return new jo(e)}),this.register(function(e){return new eh(e)}),this.register(function(e){return new ih(e)})}load(t,e,i,s){const n=this;let r;this.resourcePath!==""?r=this.resourcePath:this.path!==""?r=this.path:r=Rt.extractUrlBase(t),this.manager.itemStart(t);const a=function(h){s?s(h):console.error(h),n.manager.itemError(t),n.manager.itemEnd(t)},o=new sn(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(t,function(h){try{n.parse(h,r,function(l){e(l),n.manager.itemEnd(t)},a)}catch(l){a(l)}},i,a)}setDRACOLoader(t){return this.dracoLoader=t,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(t){return this.ktx2Loader=t,this}setMeshoptDecoder(t){return this.meshoptDecoder=t,this}register(t){return this.pluginCallbacks.indexOf(t)===-1&&this.pluginCallbacks.push(t),this}unregister(t){return this.pluginCallbacks.indexOf(t)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t),1),this}parse(t,e,i,s){let n;const r={},a={};if(typeof t=="string")n=JSON.parse(t);else if(t instanceof ArrayBuffer)if(Rt.decodeText(new Uint8Array(t,0,4))===Nr){try{r[D.KHR_BINARY_GLTF]=new sh(t)}catch(l){s&&s(l);return}n=JSON.parse(r[D.KHR_BINARY_GLTF].content)}else n=JSON.parse(Rt.decodeText(new Uint8Array(t)));else n=t;if(n.asset===void 0||n.asset.version[0]<2){s&&s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const o=new gh(n,{path:e||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});o.fileLoader.setRequestHeader(this.requestHeader);for(let h=0;h<this.pluginCallbacks.length;h++){const l=this.pluginCallbacks[h](o);a[l.name]=l,r[l.name]=!0}if(n.extensionsUsed)for(let h=0;h<n.extensionsUsed.length;++h){const l=n.extensionsUsed[h],c=n.extensionsRequired||[];switch(l){case D.KHR_MATERIALS_UNLIT:r[l]=new Ho;break;case D.KHR_DRACO_MESH_COMPRESSION:r[l]=new nh(n,this.dracoLoader);break;case D.KHR_TEXTURE_TRANSFORM:r[l]=new rh;break;case D.KHR_MESH_QUANTIZATION:r[l]=new ah;break;default:c.indexOf(l)>=0&&a[l]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+l+'".')}}o.setExtensions(r),o.setPlugins(a),o.parse(i,s)}parseAsync(t,e){const i=this;return new Promise(function(s,n){i.parse(t,e,s,n)})}}function Vo(){let u={};return{get:function(t){return u[t]},add:function(t,e){u[t]=e},remove:function(t){delete u[t]},removeAll:function(){u={}}}}const D={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class jo{constructor(t){this.parser=t,this.name=D.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const t=this.parser,e=this.parser.json.nodes||[];for(let i=0,s=e.length;i<s;i++){const n=e[i];n.extensions&&n.extensions[this.name]&&n.extensions[this.name].light!==void 0&&t._addNodeRef(this.cache,n.extensions[this.name].light)}}_loadLight(t){const e=this.parser,i="light:"+t;let s=e.cache.get(i);if(s)return s;const n=e.json,o=((n.extensions&&n.extensions[this.name]||{}).lights||[])[t];let h;const l=new U(16777215);o.color!==void 0&&l.fromArray(o.color);const c=o.range!==void 0?o.range:0;switch(o.type){case"directional":h=new an(l),h.target.position.set(0,0,-1),h.add(h.target);break;case"point":h=new Us(l),h.distance=c;break;case"spot":h=new Or(l),h.distance=c,o.spot=o.spot||{},o.spot.innerConeAngle=o.spot.innerConeAngle!==void 0?o.spot.innerConeAngle:0,o.spot.outerConeAngle=o.spot.outerConeAngle!==void 0?o.spot.outerConeAngle:Math.PI/4,h.angle=o.spot.outerConeAngle,h.penumbra=1-o.spot.innerConeAngle/o.spot.outerConeAngle,h.target.position.set(0,0,-1),h.add(h.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+o.type)}return h.position.set(0,0,0),h.decay=2,te(h,o),o.intensity!==void 0&&(h.intensity=o.intensity),h.name=e.createUniqueName(o.name||"light_"+t),s=Promise.resolve(h),e.cache.add(i,s),s}getDependency(t,e){if(t==="light")return this._loadLight(e)}createNodeAttachment(t){const e=this,i=this.parser,n=i.json.nodes[t],a=(n.extensions&&n.extensions[this.name]||{}).light;return a===void 0?null:this._loadLight(a).then(function(o){return i._getNodeRef(e.cache,a,o)})}}class Ho{constructor(){this.name=D.KHR_MATERIALS_UNLIT}getMaterialType(){return Ie}extendParams(t,e,i){const s=[];t.color=new U(1,1,1),t.opacity=1;const n=e.pbrMetallicRoughness;if(n){if(Array.isArray(n.baseColorFactor)){const r=n.baseColorFactor;t.color.fromArray(r),t.opacity=r[3]}n.baseColorTexture!==void 0&&s.push(i.assignTexture(t,"map",n.baseColorTexture,jt))}return Promise.all(s)}}class Wo{constructor(t){this.parser=t,this.name=D.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(t,e){const s=this.parser.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const n=s.extensions[this.name].emissiveStrength;return n!==void 0&&(e.emissiveIntensity=n),Promise.resolve()}}class Xo{constructor(t){this.parser=t,this.name=D.KHR_MATERIALS_CLEARCOAT}getMaterialType(t){const i=this.parser.json.materials[t];return!i.extensions||!i.extensions[this.name]?null:pe}extendMaterialParams(t,e){const i=this.parser,s=i.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const n=[],r=s.extensions[this.name];if(r.clearcoatFactor!==void 0&&(e.clearcoat=r.clearcoatFactor),r.clearcoatTexture!==void 0&&n.push(i.assignTexture(e,"clearcoatMap",r.clearcoatTexture)),r.clearcoatRoughnessFactor!==void 0&&(e.clearcoatRoughness=r.clearcoatRoughnessFactor),r.clearcoatRoughnessTexture!==void 0&&n.push(i.assignTexture(e,"clearcoatRoughnessMap",r.clearcoatRoughnessTexture)),r.clearcoatNormalTexture!==void 0&&(n.push(i.assignTexture(e,"clearcoatNormalMap",r.clearcoatNormalTexture)),r.clearcoatNormalTexture.scale!==void 0)){const a=r.clearcoatNormalTexture.scale;e.clearcoatNormalScale=new L(a,a)}return Promise.all(n)}}class qo{constructor(t){this.parser=t,this.name=D.KHR_MATERIALS_IRIDESCENCE}getMaterialType(t){const i=this.parser.json.materials[t];return!i.extensions||!i.extensions[this.name]?null:pe}extendMaterialParams(t,e){const i=this.parser,s=i.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const n=[],r=s.extensions[this.name];return r.iridescenceFactor!==void 0&&(e.iridescence=r.iridescenceFactor),r.iridescenceTexture!==void 0&&n.push(i.assignTexture(e,"iridescenceMap",r.iridescenceTexture)),r.iridescenceIor!==void 0&&(e.iridescenceIOR=r.iridescenceIor),e.iridescenceThicknessRange===void 0&&(e.iridescenceThicknessRange=[100,400]),r.iridescenceThicknessMinimum!==void 0&&(e.iridescenceThicknessRange[0]=r.iridescenceThicknessMinimum),r.iridescenceThicknessMaximum!==void 0&&(e.iridescenceThicknessRange[1]=r.iridescenceThicknessMaximum),r.iridescenceThicknessTexture!==void 0&&n.push(i.assignTexture(e,"iridescenceThicknessMap",r.iridescenceThicknessTexture)),Promise.all(n)}}class Yo{constructor(t){this.parser=t,this.name=D.KHR_MATERIALS_SHEEN}getMaterialType(t){const i=this.parser.json.materials[t];return!i.extensions||!i.extensions[this.name]?null:pe}extendMaterialParams(t,e){const i=this.parser,s=i.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const n=[];e.sheenColor=new U(0,0,0),e.sheenRoughness=0,e.sheen=1;const r=s.extensions[this.name];return r.sheenColorFactor!==void 0&&e.sheenColor.fromArray(r.sheenColorFactor),r.sheenRoughnessFactor!==void 0&&(e.sheenRoughness=r.sheenRoughnessFactor),r.sheenColorTexture!==void 0&&n.push(i.assignTexture(e,"sheenColorMap",r.sheenColorTexture,jt)),r.sheenRoughnessTexture!==void 0&&n.push(i.assignTexture(e,"sheenRoughnessMap",r.sheenRoughnessTexture)),Promise.all(n)}}class $o{constructor(t){this.parser=t,this.name=D.KHR_MATERIALS_TRANSMISSION}getMaterialType(t){const i=this.parser.json.materials[t];return!i.extensions||!i.extensions[this.name]?null:pe}extendMaterialParams(t,e){const i=this.parser,s=i.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const n=[],r=s.extensions[this.name];return r.transmissionFactor!==void 0&&(e.transmission=r.transmissionFactor),r.transmissionTexture!==void 0&&n.push(i.assignTexture(e,"transmissionMap",r.transmissionTexture)),Promise.all(n)}}class Ko{constructor(t){this.parser=t,this.name=D.KHR_MATERIALS_VOLUME}getMaterialType(t){const i=this.parser.json.materials[t];return!i.extensions||!i.extensions[this.name]?null:pe}extendMaterialParams(t,e){const i=this.parser,s=i.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const n=[],r=s.extensions[this.name];e.thickness=r.thicknessFactor!==void 0?r.thicknessFactor:0,r.thicknessTexture!==void 0&&n.push(i.assignTexture(e,"thicknessMap",r.thicknessTexture)),e.attenuationDistance=r.attenuationDistance||1/0;const a=r.attenuationColor||[1,1,1];return e.attenuationColor=new U(a[0],a[1],a[2]),Promise.all(n)}}class Zo{constructor(t){this.parser=t,this.name=D.KHR_MATERIALS_IOR}getMaterialType(t){const i=this.parser.json.materials[t];return!i.extensions||!i.extensions[this.name]?null:pe}extendMaterialParams(t,e){const s=this.parser.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const n=s.extensions[this.name];return e.ior=n.ior!==void 0?n.ior:1.5,Promise.resolve()}}class Jo{constructor(t){this.parser=t,this.name=D.KHR_MATERIALS_SPECULAR}getMaterialType(t){const i=this.parser.json.materials[t];return!i.extensions||!i.extensions[this.name]?null:pe}extendMaterialParams(t,e){const i=this.parser,s=i.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const n=[],r=s.extensions[this.name];e.specularIntensity=r.specularFactor!==void 0?r.specularFactor:1,r.specularTexture!==void 0&&n.push(i.assignTexture(e,"specularIntensityMap",r.specularTexture));const a=r.specularColorFactor||[1,1,1];return e.specularColor=new U(a[0],a[1],a[2]),r.specularColorTexture!==void 0&&n.push(i.assignTexture(e,"specularColorMap",r.specularColorTexture,jt)),Promise.all(n)}}class Qo{constructor(t){this.parser=t,this.name=D.KHR_TEXTURE_BASISU}loadTexture(t){const e=this.parser,i=e.json,s=i.textures[t];if(!s.extensions||!s.extensions[this.name])return null;const n=s.extensions[this.name],r=e.options.ktx2Loader;if(!r){if(i.extensionsRequired&&i.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return e.loadTextureImage(t,n.source,r)}}class th{constructor(t){this.parser=t,this.name=D.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(t){const e=this.name,i=this.parser,s=i.json,n=s.textures[t];if(!n.extensions||!n.extensions[e])return null;const r=n.extensions[e],a=s.images[r.source];let o=i.textureLoader;if(a.uri){const h=i.options.manager.getHandler(a.uri);h!==null&&(o=h)}return this.detectSupport().then(function(h){if(h)return i.loadTextureImage(t,r.source,o);if(s.extensionsRequired&&s.extensionsRequired.indexOf(e)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return i.loadTexture(t)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(t){const e=new Image;e.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",e.onload=e.onerror=function(){t(e.height===1)}})),this.isSupported}}class eh{constructor(t){this.name=D.EXT_MESHOPT_COMPRESSION,this.parser=t}loadBufferView(t){const e=this.parser.json,i=e.bufferViews[t];if(i.extensions&&i.extensions[this.name]){const s=i.extensions[this.name],n=this.parser.getDependency("buffer",s.buffer),r=this.parser.options.meshoptDecoder;if(!r||!r.supported){if(e.extensionsRequired&&e.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return n.then(function(a){const o=s.byteOffset||0,h=s.byteLength||0,l=s.count,c=s.byteStride,d=new Uint8Array(a,o,h);return r.decodeGltfBufferAsync?r.decodeGltfBufferAsync(l,c,d,s.mode,s.filter).then(function(p){return p.buffer}):r.ready.then(function(){const p=new ArrayBuffer(l*c);return r.decodeGltfBuffer(new Uint8Array(p),l,c,d,s.mode,s.filter),p})})}else return null}}class ih{constructor(t){this.name=D.EXT_MESH_GPU_INSTANCING,this.parser=t}createNodeMesh(t){const e=this.parser.json,i=e.nodes[t];if(!i.extensions||!i.extensions[this.name]||i.mesh===void 0)return null;const s=e.meshes[i.mesh];for(const h of s.primitives)if(h.mode!==mt.TRIANGLES&&h.mode!==mt.TRIANGLE_STRIP&&h.mode!==mt.TRIANGLE_FAN&&h.mode!==void 0)return null;const r=i.extensions[this.name].attributes,a=[],o={};for(const h in r)a.push(this.parser.getDependency("accessor",r[h]).then(l=>(o[h]=l,o[h])));return a.length<1?null:(a.push(this.parser.createNodeMesh(t)),Promise.all(a).then(h=>{const l=h.pop(),c=l.isGroup?l.children:[l],d=h[0].count,p=[];for(const f of c){const m=new P,g=new x,y=new ot,M=new x(1,1,1),w=new lo(f.geometry,f.material,d);for(let S=0;S<d;S++)o.TRANSLATION&&g.fromBufferAttribute(o.TRANSLATION,S),o.ROTATION&&y.fromBufferAttribute(o.ROTATION,S),o.SCALE&&M.fromBufferAttribute(o.SCALE,S),w.setMatrixAt(S,m.compose(g,y,M));for(const S in o)S!=="TRANSLATION"&&S!=="ROTATION"&&S!=="SCALE"&&f.geometry.setAttribute(S,o[S]);H.prototype.copy.call(w,f),w.frustumCulled=!1,this.parser.assignFinalMaterial(w),p.push(w)}return l.isGroup?(l.clear(),l.add(...p),l):p[0]}))}}const Nr="glTF",ei=12,or={JSON:1313821514,BIN:5130562};class sh{constructor(t){this.name=D.KHR_BINARY_GLTF,this.content=null,this.body=null;const e=new DataView(t,0,ei);if(this.header={magic:Rt.decodeText(new Uint8Array(t.slice(0,4))),version:e.getUint32(4,!0),length:e.getUint32(8,!0)},this.header.magic!==Nr)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const i=this.header.length-ei,s=new DataView(t,ei);let n=0;for(;n<i;){const r=s.getUint32(n,!0);n+=4;const a=s.getUint32(n,!0);if(n+=4,a===or.JSON){const o=new Uint8Array(t,ei+n,r);this.content=Rt.decodeText(o)}else if(a===or.BIN){const o=ei+n;this.body=t.slice(o,o+r)}n+=r}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class nh{constructor(t,e){if(!e)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=D.KHR_DRACO_MESH_COMPRESSION,this.json=t,this.dracoLoader=e,this.dracoLoader.preload()}decodePrimitive(t,e){const i=this.json,s=this.dracoLoader,n=t.extensions[this.name].bufferView,r=t.extensions[this.name].attributes,a={},o={},h={};for(const l in r){const c=Gs[l]||l.toLowerCase();a[c]=r[l]}for(const l in t.attributes){const c=Gs[l]||l.toLowerCase();if(r[l]!==void 0){const d=i.accessors[t.attributes[l]],p=ke[d.componentType];h[c]=p.name,o[c]=d.normalized===!0}}return e.getDependency("bufferView",n).then(function(l){return new Promise(function(c){s.decodeDracoFile(l,function(d){for(const p in d.attributes){const f=d.attributes[p],m=o[p];m!==void 0&&(f.normalized=m)}c(d)},a,h)})})}}class rh{constructor(){this.name=D.KHR_TEXTURE_TRANSFORM}extendTexture(t,e){return e.texCoord!==void 0&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),e.offset===void 0&&e.rotation===void 0&&e.scale===void 0||(t=t.clone(),e.offset!==void 0&&t.offset.fromArray(e.offset),e.rotation!==void 0&&(t.rotation=e.rotation),e.scale!==void 0&&t.repeat.fromArray(e.scale),t.needsUpdate=!0),t}}class ah{constructor(){this.name=D.KHR_MESH_QUANTIZATION}}class Ur extends yi{constructor(t,e,i,s){super(t,e,i,s)}copySampleValue_(t){const e=this.resultBuffer,i=this.sampleValues,s=this.valueSize,n=t*s*3+s;for(let r=0;r!==s;r++)e[r]=i[n+r];return e}interpolate_(t,e,i,s){const n=this.resultBuffer,r=this.sampleValues,a=this.valueSize,o=a*2,h=a*3,l=s-e,c=(i-e)/l,d=c*c,p=d*c,f=t*h,m=f-h,g=-2*p+3*d,y=p-d,M=1-g,w=y-d+c;for(let S=0;S!==a;S++){const v=r[m+S+a],_=r[m+S+o]*l,A=r[f+S+a],R=r[f+S]*l;n[S]=M*v+w*_+g*A+y*R}return n}}const oh=new ot;class hh extends Ur{interpolate_(t,e,i,s){const n=super.interpolate_(t,e,i,s);return oh.fromArray(n).normalize().toArray(n),n}}const mt={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},ke={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},hr={9728:zs,9729:Xs,9984:ma,9985:ya,9986:ga,9987:qs},lr={33071:le,33648:Ls,10497:ue},Ps={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Gs={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},Zt={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},lh={CUBICSPLINE:void 0,LINEAR:Le,STEP:di},Cs={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function ch(u){return u.DefaultMaterial===void 0&&(u.DefaultMaterial=new en({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:Wi})),u.DefaultMaterial}function ii(u,t,e){for(const i in e.extensions)u[i]===void 0&&(t.userData.gltfExtensions=t.userData.gltfExtensions||{},t.userData.gltfExtensions[i]=e.extensions[i])}function te(u,t){t.extras!==void 0&&(typeof t.extras=="object"?Object.assign(u.userData,t.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+t.extras))}function uh(u,t,e){let i=!1,s=!1,n=!1;for(let h=0,l=t.length;h<l;h++){const c=t[h];if(c.POSITION!==void 0&&(i=!0),c.NORMAL!==void 0&&(s=!0),c.COLOR_0!==void 0&&(n=!0),i&&s&&n)break}if(!i&&!s&&!n)return Promise.resolve(u);const r=[],a=[],o=[];for(let h=0,l=t.length;h<l;h++){const c=t[h];if(i){const d=c.POSITION!==void 0?e.getDependency("accessor",c.POSITION):u.attributes.position;r.push(d)}if(s){const d=c.NORMAL!==void 0?e.getDependency("accessor",c.NORMAL):u.attributes.normal;a.push(d)}if(n){const d=c.COLOR_0!==void 0?e.getDependency("accessor",c.COLOR_0):u.attributes.color;o.push(d)}}return Promise.all([Promise.all(r),Promise.all(a),Promise.all(o)]).then(function(h){const l=h[0],c=h[1],d=h[2];return i&&(u.morphAttributes.position=l),s&&(u.morphAttributes.normal=c),n&&(u.morphAttributes.color=d),u.morphTargetsRelative=!0,u})}function dh(u,t){if(u.updateMorphTargets(),t.weights!==void 0)for(let e=0,i=t.weights.length;e<i;e++)u.morphTargetInfluences[e]=t.weights[e];if(t.extras&&Array.isArray(t.extras.targetNames)){const e=t.extras.targetNames;if(u.morphTargetInfluences.length===e.length){u.morphTargetDictionary={};for(let i=0,s=e.length;i<s;i++)u.morphTargetDictionary[e[i]]=i}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function ph(u){const t=u.extensions&&u.extensions[D.KHR_DRACO_MESH_COMPRESSION];let e;return t?e="draco:"+t.bufferView+":"+t.indices+":"+cr(t.attributes):e=u.indices+":"+cr(u.attributes)+":"+u.mode,e}function cr(u){let t="";const e=Object.keys(u).sort();for(let i=0,s=e.length;i<s;i++)t+=e[i]+":"+u[e[i]]+";";return t}function Vs(u){switch(u){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function fh(u){return u.search(/\.jpe?g($|\?)/i)>0||u.search(/^data\:image\/jpeg/)===0?"image/jpeg":u.search(/\.webp($|\?)/i)>0||u.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const mh=new P;class gh{constructor(t={},e={}){this.json=t,this.extensions={},this.plugins={},this.options=e,this.cache=new Vo,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let i=!1,s=!1,n=-1;typeof navigator<"u"&&(i=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,s=navigator.userAgent.indexOf("Firefox")>-1,n=s?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||i||s&&n<98?this.textureLoader=new nn(this.options.manager):this.textureLoader=new Ro(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new sn(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(t){this.extensions=t}setPlugins(t){this.plugins=t}parse(t,e){const i=this,s=this.json,n=this.extensions;this.cache.removeAll(),this._invokeAll(function(r){return r._markDefs&&r._markDefs()}),Promise.all(this._invokeAll(function(r){return r.beforeRoot&&r.beforeRoot()})).then(function(){return Promise.all([i.getDependencies("scene"),i.getDependencies("animation"),i.getDependencies("camera")])}).then(function(r){const a={scene:r[0][s.scene||0],scenes:r[0],animations:r[1],cameras:r[2],asset:s.asset,parser:i,userData:{}};ii(n,a,s),te(a,s),Promise.all(i._invokeAll(function(o){return o.afterRoot&&o.afterRoot(a)})).then(function(){t(a)})}).catch(e)}_markDefs(){const t=this.json.nodes||[],e=this.json.skins||[],i=this.json.meshes||[];for(let s=0,n=e.length;s<n;s++){const r=e[s].joints;for(let a=0,o=r.length;a<o;a++)t[r[a]].isBone=!0}for(let s=0,n=t.length;s<n;s++){const r=t[s];r.mesh!==void 0&&(this._addNodeRef(this.meshCache,r.mesh),r.skin!==void 0&&(i[r.mesh].isSkinnedMesh=!0)),r.camera!==void 0&&this._addNodeRef(this.cameraCache,r.camera)}}_addNodeRef(t,e){e!==void 0&&(t.refs[e]===void 0&&(t.refs[e]=t.uses[e]=0),t.refs[e]++)}_getNodeRef(t,e,i){if(t.refs[e]<=1)return i;const s=i.clone(),n=(r,a)=>{const o=this.associations.get(r);o!=null&&this.associations.set(a,o);for(const[h,l]of r.children.entries())n(l,a.children[h])};return n(i,s),s.name+="_instance_"+t.uses[e]++,s}_invokeOne(t){const e=Object.values(this.plugins);e.push(this);for(let i=0;i<e.length;i++){const s=t(e[i]);if(s)return s}return null}_invokeAll(t){const e=Object.values(this.plugins);e.unshift(this);const i=[];for(let s=0;s<e.length;s++){const n=t(e[s]);n&&i.push(n)}return i}getDependency(t,e){const i=t+":"+e;let s=this.cache.get(i);if(!s){switch(t){case"scene":s=this.loadScene(e);break;case"node":s=this._invokeOne(function(n){return n.loadNode&&n.loadNode(e)});break;case"mesh":s=this._invokeOne(function(n){return n.loadMesh&&n.loadMesh(e)});break;case"accessor":s=this.loadAccessor(e);break;case"bufferView":s=this._invokeOne(function(n){return n.loadBufferView&&n.loadBufferView(e)});break;case"buffer":s=this.loadBuffer(e);break;case"material":s=this._invokeOne(function(n){return n.loadMaterial&&n.loadMaterial(e)});break;case"texture":s=this._invokeOne(function(n){return n.loadTexture&&n.loadTexture(e)});break;case"skin":s=this.loadSkin(e);break;case"animation":s=this._invokeOne(function(n){return n.loadAnimation&&n.loadAnimation(e)});break;case"camera":s=this.loadCamera(e);break;default:if(s=this._invokeOne(function(n){return n!=this&&n.getDependency&&n.getDependency(t,e)}),!s)throw new Error("Unknown type: "+t);break}this.cache.add(i,s)}return s}getDependencies(t){let e=this.cache.get(t);if(!e){const i=this,s=this.json[t+(t==="mesh"?"es":"s")]||[];e=Promise.all(s.map(function(n,r){return i.getDependency(t,r)})),this.cache.add(t,e)}return e}loadBuffer(t){const e=this.json.buffers[t],i=this.fileLoader;if(e.type&&e.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+e.type+" buffer type is not supported.");if(e.uri===void 0&&t===0)return Promise.resolve(this.extensions[D.KHR_BINARY_GLTF].body);const s=this.options;return new Promise(function(n,r){i.load(Rt.resolveURL(e.uri,s.path),n,void 0,function(){r(new Error('THREE.GLTFLoader: Failed to load buffer "'+e.uri+'".'))})})}loadBufferView(t){const e=this.json.bufferViews[t];return this.getDependency("buffer",e.buffer).then(function(i){const s=e.byteLength||0,n=e.byteOffset||0;return i.slice(n,n+s)})}loadAccessor(t){const e=this,i=this.json,s=this.json.accessors[t];if(s.bufferView===void 0&&s.sparse===void 0){const r=Ps[s.type],a=ke[s.componentType],o=s.normalized===!0,h=new a(s.count*r);return Promise.resolve(new At(h,r,o))}const n=[];return s.bufferView!==void 0?n.push(this.getDependency("bufferView",s.bufferView)):n.push(null),s.sparse!==void 0&&(n.push(this.getDependency("bufferView",s.sparse.indices.bufferView)),n.push(this.getDependency("bufferView",s.sparse.values.bufferView))),Promise.all(n).then(function(r){const a=r[0],o=Ps[s.type],h=ke[s.componentType],l=h.BYTES_PER_ELEMENT,c=l*o,d=s.byteOffset||0,p=s.bufferView!==void 0?i.bufferViews[s.bufferView].byteStride:void 0,f=s.normalized===!0;let m,g;if(p&&p!==c){const y=Math.floor(d/p),M="InterleavedBuffer:"+s.bufferView+":"+s.componentType+":"+y+":"+s.count;let w=e.cache.get(M);w||(m=new h(a,y*p,s.count*p/l),w=new no(m,p/l),e.cache.add(M,w)),g=new Qs(w,o,d%p/l,f)}else a===null?m=new h(s.count*o):m=new h(a,d,s.count*o),g=new At(m,o,f);if(s.sparse!==void 0){const y=Ps.SCALAR,M=ke[s.sparse.indices.componentType],w=s.sparse.indices.byteOffset||0,S=s.sparse.values.byteOffset||0,v=new M(r[1],w,s.sparse.count*y),_=new h(r[2],S,s.sparse.count*o);a!==null&&(g=new At(g.array.slice(),g.itemSize,g.normalized));for(let A=0,R=v.length;A<R;A++){const G=v[A];if(g.setX(G,_[A*o]),o>=2&&g.setY(G,_[A*o+1]),o>=3&&g.setZ(G,_[A*o+2]),o>=4&&g.setW(G,_[A*o+3]),o>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return g})}loadTexture(t){const e=this.json,i=this.options,n=e.textures[t].source,r=e.images[n];let a=this.textureLoader;if(r.uri){const o=i.manager.getHandler(r.uri);o!==null&&(a=o)}return this.loadTextureImage(t,n,a)}loadTextureImage(t,e,i){const s=this,n=this.json,r=n.textures[t],a=n.images[e],o=(a.uri||a.bufferView)+":"+r.sampler;if(this.textureCache[o])return this.textureCache[o];const h=this.loadImageSource(e,i).then(function(l){l.flipY=!1,l.name=r.name||a.name||"";const d=(n.samplers||{})[r.sampler]||{};return l.magFilter=hr[d.magFilter]||Xs,l.minFilter=hr[d.minFilter]||qs,l.wrapS=lr[d.wrapS]||ue,l.wrapT=lr[d.wrapT]||ue,s.associations.set(l,{textures:t}),l}).catch(function(){return null});return this.textureCache[o]=h,h}loadImageSource(t,e){const i=this,s=this.json,n=this.options;if(this.sourceCache[t]!==void 0)return this.sourceCache[t].then(c=>c.clone());const r=s.images[t],a=self.URL||self.webkitURL;let o=r.uri||"",h=!1;if(r.bufferView!==void 0)o=i.getDependency("bufferView",r.bufferView).then(function(c){h=!0;const d=new Blob([c],{type:r.mimeType});return o=a.createObjectURL(d),o});else if(r.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+t+" is missing URI and bufferView");const l=Promise.resolve(o).then(function(c){return new Promise(function(d,p){let f=d;e.isImageBitmapLoader===!0&&(f=function(m){const g=new ht(m);g.needsUpdate=!0,d(g)}),e.load(Rt.resolveURL(c,n.path),f,void 0,p)})}).then(function(c){return h===!0&&a.revokeObjectURL(o),c.userData.mimeType=r.mimeType||fh(r.uri),c}).catch(function(c){throw console.error("THREE.GLTFLoader: Couldn't load texture",o),c});return this.sourceCache[t]=l,l}assignTexture(t,e,i,s){const n=this;return this.getDependency("texture",i.index).then(function(r){if(!r)return null;if(i.texCoord!==void 0&&i.texCoord!=0&&!(e==="aoMap"&&i.texCoord==1)&&console.warn("THREE.GLTFLoader: Custom UV set "+i.texCoord+" for texture "+e+" not yet supported."),n.extensions[D.KHR_TEXTURE_TRANSFORM]){const a=i.extensions!==void 0?i.extensions[D.KHR_TEXTURE_TRANSFORM]:void 0;if(a){const o=n.associations.get(r);r=n.extensions[D.KHR_TEXTURE_TRANSFORM].extendTexture(r,a),n.associations.set(r,o)}}return s!==void 0&&(r.encoding=s),t[e]=r,r})}assignFinalMaterial(t){const e=t.geometry;let i=t.material;const s=e.attributes.tangent===void 0,n=e.attributes.color!==void 0,r=e.attributes.normal===void 0;if(t.isPoints){const a="PointsMaterial:"+i.uuid;let o=this.cache.get(a);o||(o=new Fr,Wt.prototype.copy.call(o,i),o.color.copy(i.color),o.map=i.map,o.sizeAttenuation=!1,this.cache.add(a,o)),i=o}else if(t.isLine){const a="LineBasicMaterial:"+i.uuid;let o=this.cache.get(a);o||(o=new tn,Wt.prototype.copy.call(o,i),o.color.copy(i.color),this.cache.add(a,o)),i=o}if(s||n||r){let a="ClonedMaterial:"+i.uuid+":";s&&(a+="derivative-tangents:"),n&&(a+="vertex-colors:"),r&&(a+="flat-shading:");let o=this.cache.get(a);o||(o=i.clone(),n&&(o.vertexColors=!0),r&&(o.flatShading=!0),s&&(o.normalScale&&(o.normalScale.y*=-1),o.clearcoatNormalScale&&(o.clearcoatNormalScale.y*=-1)),this.cache.add(a,o),this.associations.set(o,this.associations.get(i))),i=o}i.aoMap&&e.attributes.uv2===void 0&&e.attributes.uv!==void 0&&e.setAttribute("uv2",e.attributes.uv),t.material=i}getMaterialType(){return en}loadMaterial(t){const e=this,i=this.json,s=this.extensions,n=i.materials[t];let r;const a={},o=n.extensions||{},h=[];if(o[D.KHR_MATERIALS_UNLIT]){const c=s[D.KHR_MATERIALS_UNLIT];r=c.getMaterialType(),h.push(c.extendParams(a,n,e))}else{const c=n.pbrMetallicRoughness||{};if(a.color=new U(1,1,1),a.opacity=1,Array.isArray(c.baseColorFactor)){const d=c.baseColorFactor;a.color.fromArray(d),a.opacity=d[3]}c.baseColorTexture!==void 0&&h.push(e.assignTexture(a,"map",c.baseColorTexture,jt)),a.metalness=c.metallicFactor!==void 0?c.metallicFactor:1,a.roughness=c.roughnessFactor!==void 0?c.roughnessFactor:1,c.metallicRoughnessTexture!==void 0&&(h.push(e.assignTexture(a,"metalnessMap",c.metallicRoughnessTexture)),h.push(e.assignTexture(a,"roughnessMap",c.metallicRoughnessTexture))),r=this._invokeOne(function(d){return d.getMaterialType&&d.getMaterialType(t)}),h.push(Promise.all(this._invokeAll(function(d){return d.extendMaterialParams&&d.extendMaterialParams(t,a)})))}n.doubleSided===!0&&(a.side=ha);const l=n.alphaMode||Cs.OPAQUE;if(l===Cs.BLEND?(a.transparent=!0,a.depthWrite=!1):(a.transparent=!1,l===Cs.MASK&&(a.alphaTest=n.alphaCutoff!==void 0?n.alphaCutoff:.5)),n.normalTexture!==void 0&&r!==Ie&&(h.push(e.assignTexture(a,"normalMap",n.normalTexture)),a.normalScale=new L(1,1),n.normalTexture.scale!==void 0)){const c=n.normalTexture.scale;a.normalScale.set(c,c)}return n.occlusionTexture!==void 0&&r!==Ie&&(h.push(e.assignTexture(a,"aoMap",n.occlusionTexture)),n.occlusionTexture.strength!==void 0&&(a.aoMapIntensity=n.occlusionTexture.strength)),n.emissiveFactor!==void 0&&r!==Ie&&(a.emissive=new U().fromArray(n.emissiveFactor)),n.emissiveTexture!==void 0&&r!==Ie&&h.push(e.assignTexture(a,"emissiveMap",n.emissiveTexture,jt)),Promise.all(h).then(function(){const c=new r(a);return n.name&&(c.name=n.name),te(c,n),e.associations.set(c,{materials:t}),n.extensions&&ii(s,c,n),c})}createUniqueName(t){const e=B.sanitizeNodeName(t||"");let i=e;for(let s=1;this.nodeNamesUsed[i];++s)i=e+"_"+s;return this.nodeNamesUsed[i]=!0,i}loadGeometries(t){const e=this,i=this.extensions,s=this.primitiveCache;function n(a){return i[D.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a,e).then(function(o){return ur(o,a,e)})}const r=[];for(let a=0,o=t.length;a<o;a++){const h=t[a],l=ph(h),c=s[l];if(c)r.push(c.promise);else{let d;h.extensions&&h.extensions[D.KHR_DRACO_MESH_COMPRESSION]?d=n(h):d=ur(new Ct,h,e),s[l]={primitive:h,promise:d},r.push(d)}}return Promise.all(r)}loadMesh(t){const e=this,i=this.json,s=this.extensions,n=i.meshes[t],r=n.primitives,a=[];for(let o=0,h=r.length;o<h;o++){const l=r[o].material===void 0?ch(this.cache):this.getDependency("material",r[o].material);a.push(l)}return a.push(e.loadGeometries(r)),Promise.all(a).then(function(o){const h=o.slice(0,o.length-1),l=o[o.length-1],c=[];for(let p=0,f=l.length;p<f;p++){const m=l[p],g=r[p];let y;const M=h[p];if(g.mode===mt.TRIANGLES||g.mode===mt.TRIANGLE_STRIP||g.mode===mt.TRIANGLE_FAN||g.mode===void 0)y=n.isSkinnedMesh===!0?new Rr(m,M):new Ue(m,M),y.isSkinnedMesh===!0&&!y.geometry.attributes.skinWeight.normalized&&y.normalizeSkinWeights(),g.mode===mt.TRIANGLE_STRIP?y.geometry=dr(y.geometry,Ma):g.mode===mt.TRIANGLE_FAN&&(y.geometry=dr(y.geometry,Sr));else if(g.mode===mt.LINES)y=new co(m,M);else if(g.mode===mt.LINE_STRIP)y=new Ki(m,M);else if(g.mode===mt.LINE_LOOP)y=new uo(m,M);else if(g.mode===mt.POINTS)y=new po(m,M);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+g.mode);Object.keys(y.geometry.morphAttributes).length>0&&dh(y,n),y.name=e.createUniqueName(n.name||"mesh_"+t),te(y,n),g.extensions&&ii(s,y,g),e.assignFinalMaterial(y),c.push(y)}for(let p=0,f=c.length;p<f;p++)e.associations.set(c[p],{meshes:t,primitives:p});if(c.length===1)return c[0];const d=new ai;e.associations.set(d,{meshes:t});for(let p=0,f=c.length;p<f;p++)d.add(c[p]);return d})}loadCamera(t){let e;const i=this.json.cameras[t],s=i[i.type];if(!s){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return i.type==="perspective"?e=new gi(St.radToDeg(s.yfov),s.aspectRatio||1,s.znear||1,s.zfar||2e6):i.type==="orthographic"&&(e=new Js(-s.xmag,s.xmag,s.ymag,-s.ymag,s.znear,s.zfar)),i.name&&(e.name=this.createUniqueName(i.name)),te(e,i),Promise.resolve(e)}loadSkin(t){const e=this.json.skins[t],i=[];for(let s=0,n=e.joints.length;s<n;s++)i.push(this.getDependency("node",e.joints[s]));return e.inverseBindMatrices!==void 0?i.push(this.getDependency("accessor",e.inverseBindMatrices)):i.push(null),Promise.all(i).then(function(s){const n=s.pop(),r=s,a=[],o=[];for(let h=0,l=r.length;h<l;h++){const c=r[h];if(c){a.push(c);const d=new P;n!==null&&d.fromArray(n.array,h*16),o.push(d)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',e.joints[h])}return new $i(a,o)})}loadAnimation(t){const i=this.json.animations[t],s=[],n=[],r=[],a=[],o=[];for(let h=0,l=i.channels.length;h<l;h++){const c=i.channels[h],d=i.samplers[c.sampler],p=c.target,f=p.node,m=i.parameters!==void 0?i.parameters[d.input]:d.input,g=i.parameters!==void 0?i.parameters[d.output]:d.output;s.push(this.getDependency("node",f)),n.push(this.getDependency("accessor",m)),r.push(this.getDependency("accessor",g)),a.push(d),o.push(p)}return Promise.all([Promise.all(s),Promise.all(n),Promise.all(r),Promise.all(a),Promise.all(o)]).then(function(h){const l=h[0],c=h[1],d=h[2],p=h[3],f=h[4],m=[];for(let y=0,M=l.length;y<M;y++){const w=l[y],S=c[y],v=d[y],_=p[y],A=f[y];if(w===void 0)continue;w.updateMatrix();let R;switch(Zt[A.path]){case Zt.weights:R=ze;break;case Zt.rotation:R=se;break;case Zt.position:case Zt.scale:default:R=Be;break}const G=w.name?w.name:w.uuid,C=_.interpolation!==void 0?lh[_.interpolation]:Le,O=[];Zt[A.path]===Zt.weights?w.traverse(function(I){I.morphTargetInfluences&&O.push(I.name?I.name:I.uuid)}):O.push(G);let z=v.array;if(v.normalized){const I=Vs(z.constructor),X=new Float32Array(z.length);for(let N=0,W=z.length;N<W;N++)X[N]=z[N]*I;z=X}for(let I=0,X=O.length;I<X;I++){const N=new R(O[I]+"."+Zt[A.path],S.array,z,C);_.interpolation==="CUBICSPLINE"&&(N.createInterpolant=function(Et){const xt=this instanceof se?hh:Ur;return new xt(this.times,this.values,this.getValueSize()/3,Et)},N.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),m.push(N)}}const g=i.name?i.name:"animation_"+t;return new Br(g,void 0,m)})}createNodeMesh(t){const e=this.json,i=this,s=e.nodes[t];return s.mesh===void 0?null:i.getDependency("mesh",s.mesh).then(function(n){const r=i._getNodeRef(i.meshCache,s.mesh,n);return s.weights!==void 0&&r.traverse(function(a){if(a.isMesh)for(let o=0,h=s.weights.length;o<h;o++)a.morphTargetInfluences[o]=s.weights[o]}),r})}loadNode(t){const e=this.json,i=this.extensions,s=this,n=e.nodes[t],r=n.name?s.createUniqueName(n.name):"";return function(){const a=[],o=s._invokeOne(function(d){return d.createNodeMesh&&d.createNodeMesh(t)});o&&a.push(o),n.camera!==void 0&&a.push(s.getDependency("camera",n.camera).then(function(d){return s._getNodeRef(s.cameraCache,n.camera,d)})),s._invokeAll(function(d){return d.createNodeAttachment&&d.createNodeAttachment(t)}).forEach(function(d){a.push(d)});const h=[],l=n.children||[];for(let d=0,p=l.length;d<p;d++)h.push(s.getDependency("node",l[d]));const c=n.skin===void 0?Promise.resolve(null):s.getDependency("skin",n.skin);return Promise.all([Promise.all(a),Promise.all(h),c])}().then(function(a){const o=a[0],h=a[1],l=a[2];let c;if(n.isBone===!0?c=new Xi:o.length>1?c=new ai:o.length===1?c=o[0]:c=new H,c!==o[0])for(let d=0,p=o.length;d<p;d++)c.add(o[d]);if(n.name&&(c.userData.name=n.name,c.name=r),te(c,n),n.extensions&&ii(i,c,n),n.matrix!==void 0){const d=new P;d.fromArray(n.matrix),c.applyMatrix4(d)}else n.translation!==void 0&&c.position.fromArray(n.translation),n.rotation!==void 0&&c.quaternion.fromArray(n.rotation),n.scale!==void 0&&c.scale.fromArray(n.scale);s.associations.has(c)||s.associations.set(c,{}),s.associations.get(c).nodes=t,l!==null&&c.traverse(function(d){d.isSkinnedMesh&&d.bind(l,mh)});for(let d=0,p=h.length;d<p;d++)c.add(h[d]);return c})}loadScene(t){const e=this.extensions,i=this.json.scenes[t],s=this,n=new ai;i.name&&(n.name=s.createUniqueName(i.name)),te(n,i),i.extensions&&ii(e,n,i);const r=i.nodes||[],a=[];for(let o=0,h=r.length;o<h;o++)a.push(s.getDependency("node",r[o]));return Promise.all(a).then(function(o){for(let l=0,c=o.length;l<c;l++)n.add(o[l]);const h=l=>{const c=new Map;for(const[d,p]of s.associations)(d instanceof Wt||d instanceof ht)&&c.set(d,p);return l.traverse(d=>{const p=s.associations.get(d);p!=null&&c.set(d,p)}),c};return s.associations=h(n),n})}}function yh(u,t,e){const i=t.attributes,s=new Oe;if(i.POSITION!==void 0){const a=e.json.accessors[i.POSITION],o=a.min,h=a.max;if(o!==void 0&&h!==void 0){if(s.set(new x(o[0],o[1],o[2]),new x(h[0],h[1],h[2])),a.normalized){const l=Vs(ke[a.componentType]);s.min.multiplyScalar(l),s.max.multiplyScalar(l)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const n=t.targets;if(n!==void 0){const a=new x,o=new x;for(let h=0,l=n.length;h<l;h++){const c=n[h];if(c.POSITION!==void 0){const d=e.json.accessors[c.POSITION],p=d.min,f=d.max;if(p!==void 0&&f!==void 0){if(o.setX(Math.max(Math.abs(p[0]),Math.abs(f[0]))),o.setY(Math.max(Math.abs(p[1]),Math.abs(f[1]))),o.setZ(Math.max(Math.abs(p[2]),Math.abs(f[2]))),d.normalized){const m=Vs(ke[d.componentType]);o.multiplyScalar(m)}a.max(o)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}s.expandByVector(a)}u.boundingBox=s;const r=new Ne;s.getCenter(r.center),r.radius=s.min.distanceTo(s.max)/2,u.boundingSphere=r}function ur(u,t,e){const i=t.attributes,s=[];function n(r,a){return e.getDependency("accessor",r).then(function(o){u.setAttribute(a,o)})}for(const r in i){const a=Gs[r]||r.toLowerCase();a in u.attributes||s.push(n(i[r],a))}if(t.indices!==void 0&&!u.index){const r=e.getDependency("accessor",t.indices).then(function(a){u.setIndex(a)});s.push(r)}return te(u,t),yh(u,t,e),Promise.all(s).then(function(){return t.targets!==void 0?uh(u,t.targets,e):u})}function dr(u,t){let e=u.getIndex();if(e===null){const r=[],a=u.getAttribute("position");if(a!==void 0){for(let o=0;o<a.count;o++)r.push(o);u.setIndex(r),e=u.getIndex()}else return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),u}const i=e.count-2,s=[];if(t===Sr)for(let r=1;r<=i;r++)s.push(e.getX(0)),s.push(e.getX(r)),s.push(e.getX(r+1));else for(let r=0;r<i;r++)r%2===0?(s.push(e.getX(r)),s.push(e.getX(r+1)),s.push(e.getX(r+2))):(s.push(e.getX(r+2)),s.push(e.getX(r+1)),s.push(e.getX(r)));s.length/3!==i&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const n=u.clone();return n.setIndex(s),n}/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/var pr=function(u){return URL.createObjectURL(new Blob([u],{type:"text/javascript"}))};try{URL.revokeObjectURL(pr(""))}catch{pr=function(t){return"data:application/javascript;charset=UTF-8,"+encodeURI(t)}}var yt=Uint8Array,ee=Uint16Array,js=Uint32Array,Gr=new yt([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Vr=new yt([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),xh=new yt([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),jr=function(u,t){for(var e=new ee(31),i=0;i<31;++i)e[i]=t+=1<<u[i-1];for(var s=new js(e[30]),i=1;i<30;++i)for(var n=e[i];n<e[i+1];++n)s[n]=n-e[i]<<5|i;return[e,s]},Hr=jr(Gr,2),Wr=Hr[0],bh=Hr[1];Wr[28]=258,bh[258]=28;var wh=jr(Vr,0),Mh=wh[0],Hs=new ee(32768);for(var j=0;j<32768;++j){var Jt=(j&43690)>>>1|(j&21845)<<1;Jt=(Jt&52428)>>>2|(Jt&13107)<<2,Jt=(Jt&61680)>>>4|(Jt&3855)<<4,Hs[j]=((Jt&65280)>>>8|(Jt&255)<<8)>>>1}var oi=function(u,t,e){for(var i=u.length,s=0,n=new ee(t);s<i;++s)++n[u[s]-1];var r=new ee(t);for(s=0;s<t;++s)r[s]=r[s-1]+n[s-1]<<1;var a;if(e){a=new ee(1<<t);var o=15-t;for(s=0;s<i;++s)if(u[s])for(var h=s<<4|u[s],l=t-u[s],c=r[u[s]-1]++<<l,d=c|(1<<l)-1;c<=d;++c)a[Hs[c]>>>o]=h}else for(a=new ee(i),s=0;s<i;++s)u[s]&&(a[s]=Hs[r[u[s]-1]++]>>>15-u[s]);return a},xi=new yt(288);for(var j=0;j<144;++j)xi[j]=8;for(var j=144;j<256;++j)xi[j]=9;for(var j=256;j<280;++j)xi[j]=7;for(var j=280;j<288;++j)xi[j]=8;var Xr=new yt(32);for(var j=0;j<32;++j)Xr[j]=5;var vh=oi(xi,9,1),Th=oi(Xr,5,1),Rs=function(u){for(var t=u[0],e=1;e<u.length;++e)u[e]>t&&(t=u[e]);return t},Tt=function(u,t,e){var i=t/8|0;return(u[i]|u[i+1]<<8)>>(t&7)&e},Fs=function(u,t){var e=t/8|0;return(u[e]|u[e+1]<<8|u[e+2]<<16)>>(t&7)},Sh=function(u){return(u/8|0)+(u&7&&1)},_h=function(u,t,e){(t==null||t<0)&&(t=0),(e==null||e>u.length)&&(e=u.length);var i=new(u instanceof ee?ee:u instanceof js?js:yt)(e-t);return i.set(u.subarray(t,e)),i},Ah=function(u,t,e){var i=u.length;if(!i||e&&!e.l&&i<5)return t||new yt(0);var s=!t||e,n=!e||e.i;e||(e={}),t||(t=new yt(i*3));var r=function(We){var bi=t.length;if(We>bi){var wi=new yt(Math.max(bi*2,We));wi.set(t),t=wi}},a=e.f||0,o=e.p||0,h=e.b||0,l=e.l,c=e.d,d=e.m,p=e.n,f=i*8;do{if(!l){e.f=a=Tt(u,o,1);var m=Tt(u,o+1,3);if(o+=3,m)if(m==1)l=vh,c=Th,d=9,p=5;else if(m==2){var w=Tt(u,o,31)+257,S=Tt(u,o+10,15)+4,v=w+Tt(u,o+5,31)+1;o+=14;for(var _=new yt(v),A=new yt(19),R=0;R<S;++R)A[xh[R]]=Tt(u,o+R*3,7);o+=S*3;for(var G=Rs(A),C=(1<<G)-1,O=oi(A,G,1),R=0;R<v;){var z=O[Tt(u,o,C)];o+=z&15;var g=z>>>4;if(g<16)_[R++]=g;else{var I=0,X=0;for(g==16?(X=3+Tt(u,o,3),o+=2,I=_[R-1]):g==17?(X=3+Tt(u,o,7),o+=3):g==18&&(X=11+Tt(u,o,127),o+=7);X--;)_[R++]=I}}var N=_.subarray(0,w),W=_.subarray(w);d=Rs(N),p=Rs(W),l=oi(N,d,1),c=oi(W,p,1)}else throw"invalid block type";else{var g=Sh(o)+4,y=u[g-4]|u[g-3]<<8,M=g+y;if(M>i){if(n)throw"unexpected EOF";break}s&&r(h+y),t.set(u.subarray(g,M),h),e.b=h+=y,e.p=o=M*8;continue}if(o>f){if(n)throw"unexpected EOF";break}}s&&r(h+131072);for(var Et=(1<<d)-1,xt=(1<<p)-1,Pt=o;;Pt=o){var I=l[Fs(u,o)&Et],lt=I>>>4;if(o+=I&15,o>f){if(n)throw"unexpected EOF";break}if(!I)throw"invalid length/literal";if(lt<256)t[h++]=lt;else if(lt==256){Pt=o,l=null;break}else{var It=lt-254;if(lt>264){var R=lt-257,re=Gr[R];It=Tt(u,o,(1<<re)-1)+Wr[R],o+=re}var je=c[Fs(u,o)&xt],me=je>>>4;if(!je)throw"invalid distance";o+=je&15;var W=Mh[me];if(me>3){var re=Vr[me];W+=Fs(u,o)&(1<<re)-1,o+=re}if(o>f){if(n)throw"unexpected EOF";break}s&&r(h+131072);for(var He=h+It;h<He;h+=4)t[h]=t[h-W],t[h+1]=t[h+1-W],t[h+2]=t[h+2-W],t[h+3]=t[h+3-W];h=He}}e.l=l,e.p=Pt,e.b=h,l&&(a=1,e.m=d,e.d=c,e.n=p)}while(!a);return h==t.length?t:_h(t,0,h)},Eh=new yt(0),Ph=function(u){if((u[0]&15)!=8||u[0]>>>4>7||(u[0]<<8|u[1])%31)throw"invalid zlib data";if(u[1]&32)throw"invalid zlib data: preset dictionaries not supported"};function Ch(u,t){return Ah((Ph(u),u.subarray(2,-4)),t)}var Rh=typeof TextDecoder<"u"&&new TextDecoder,Fh=0;try{Rh.decode(Eh,{stream:!0}),Fh=1}catch{}function qr(u,t,e){const i=e.length-u-1;if(t>=e[i])return i-1;if(t<=e[u])return u;let s=u,n=i,r=Math.floor((s+n)/2);for(;t<e[r]||t>=e[r+1];)t<e[r]?n=r:s=r,r=Math.floor((s+n)/2);return r}function Ih(u,t,e,i){const s=[],n=[],r=[];s[0]=1;for(let a=1;a<=e;++a){n[a]=t-i[u+1-a],r[a]=i[u+a]-t;let o=0;for(let h=0;h<a;++h){const l=r[h+1],c=n[a-h],d=s[h]/(l+c);s[h]=o+l*d,o=c*d}s[a]=o}return s}function kh(u,t,e,i){const s=qr(u,i,t),n=Ih(s,i,u,t),r=new it(0,0,0,0);for(let a=0;a<=u;++a){const o=e[s-u+a],h=n[a],l=o.w*h;r.x+=o.x*l,r.y+=o.y*l,r.z+=o.z*l,r.w+=o.w*h}return r}function Lh(u,t,e,i,s){const n=[];for(let c=0;c<=e;++c)n[c]=0;const r=[];for(let c=0;c<=i;++c)r[c]=n.slice(0);const a=[];for(let c=0;c<=e;++c)a[c]=n.slice(0);a[0][0]=1;const o=n.slice(0),h=n.slice(0);for(let c=1;c<=e;++c){o[c]=t-s[u+1-c],h[c]=s[u+c]-t;let d=0;for(let p=0;p<c;++p){const f=h[p+1],m=o[c-p];a[c][p]=f+m;const g=a[p][c-1]/a[c][p];a[p][c]=d+f*g,d=m*g}a[c][c]=d}for(let c=0;c<=e;++c)r[0][c]=a[c][e];for(let c=0;c<=e;++c){let d=0,p=1;const f=[];for(let m=0;m<=e;++m)f[m]=n.slice(0);f[0][0]=1;for(let m=1;m<=i;++m){let g=0;const y=c-m,M=e-m;c>=m&&(f[p][0]=f[d][0]/a[M+1][y],g=f[p][0]*a[y][M]);const w=y>=-1?1:-y,S=c-1<=M?m-1:e-c;for(let _=w;_<=S;++_)f[p][_]=(f[d][_]-f[d][_-1])/a[M+1][y+_],g+=f[p][_]*a[y+_][M];c<=M&&(f[p][m]=-f[d][m-1]/a[M+1][c],g+=f[p][m]*a[c][M]),r[m][c]=g;const v=d;d=p,p=v}}let l=e;for(let c=1;c<=i;++c){for(let d=0;d<=e;++d)r[c][d]*=l;l*=e-c}return r}function zh(u,t,e,i,s){const n=s<u?s:u,r=[],a=qr(u,i,t),o=Lh(a,i,u,n,t),h=[];for(let l=0;l<e.length;++l){const c=e[l].clone(),d=c.w;c.x*=d,c.y*=d,c.z*=d,h[l]=c}for(let l=0;l<=n;++l){const c=h[a-u].clone().multiplyScalar(o[l][0]);for(let d=1;d<=u;++d)c.add(h[a-u+d].clone().multiplyScalar(o[l][d]));r[l]=c}for(let l=n+1;l<=s+1;++l)r[l]=new it(0,0,0);return r}function Bh(u,t){let e=1;for(let s=2;s<=u;++s)e*=s;let i=1;for(let s=2;s<=t;++s)i*=s;for(let s=2;s<=u-t;++s)i*=s;return e/i}function Dh(u){const t=u.length,e=[],i=[];for(let n=0;n<t;++n){const r=u[n];e[n]=new x(r.x,r.y,r.z),i[n]=r.w}const s=[];for(let n=0;n<t;++n){const r=e[n].clone();for(let a=1;a<=n;++a)r.sub(s[n-a].clone().multiplyScalar(Bh(n,a)*i[a]));s[n]=r.divideScalar(i[0])}return s}function Oh(u,t,e,i,s){const n=zh(u,t,e,i,s);return Dh(n)}class Nh extends fo{constructor(t,e,i,s,n){super(),this.degree=t,this.knots=e,this.controlPoints=[],this.startKnot=s||0,this.endKnot=n||this.knots.length-1;for(let r=0;r<i.length;++r){const a=i[r];this.controlPoints[r]=new it(a.x,a.y,a.z,a.w)}}getPoint(t,e=new x){const i=e,s=this.knots[this.startKnot]+t*(this.knots[this.endKnot]-this.knots[this.startKnot]),n=kh(this.degree,this.knots,this.controlPoints,s);return n.w!==1&&n.divideScalar(n.w),i.set(n.x,n.y,n.z)}getTangent(t,e=new x){const i=e,s=this.knots[0]+t*(this.knots[this.knots.length-1]-this.knots[0]),n=Oh(this.degree,this.knots,this.controlPoints,s,1);return i.copy(n[1]).normalize(),i}}let k,q,at;class Uh extends fe{constructor(t){super(t)}load(t,e,i,s){const n=this,r=n.path===""?Rt.extractUrlBase(t):n.path,a=new sn(this.manager);a.setPath(n.path),a.setResponseType("arraybuffer"),a.setRequestHeader(n.requestHeader),a.setWithCredentials(n.withCredentials),a.load(t,function(o){try{e(n.parse(o,r))}catch(h){s?s(h):console.error(h),n.manager.itemError(t)}},i,s)}parse(t,e){if(Xh(t))k=new Wh().parse(t);else{const s=Zr(t);if(!qh(s))throw new Error("THREE.FBXLoader: Unknown format.");if(mr(s)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+mr(s));k=new Hh().parse(s)}const i=new nn(this.manager).setPath(this.resourcePath||e).setCrossOrigin(this.crossOrigin);return new Gh(i,this.manager).parse(k)}}class Gh{constructor(t,e){this.textureLoader=t,this.manager=e}parse(){q=this.parseConnections();const t=this.parseImages(),e=this.parseTextures(t),i=this.parseMaterials(e),s=this.parseDeformers(),n=new Vh().parse(s);return this.parseScene(s,n,i),at}parseConnections(){const t=new Map;return"Connections"in k&&k.Connections.connections.forEach(function(i){const s=i[0],n=i[1],r=i[2];t.has(s)||t.set(s,{parents:[],children:[]});const a={ID:n,relationship:r};t.get(s).parents.push(a),t.has(n)||t.set(n,{parents:[],children:[]});const o={ID:s,relationship:r};t.get(n).children.push(o)}),t}parseImages(){const t={},e={};if("Video"in k.Objects){const i=k.Objects.Video;for(const s in i){const n=i[s],r=parseInt(s);if(t[r]=n.RelativeFilename||n.Filename,"Content"in n){const a=n.Content instanceof ArrayBuffer&&n.Content.byteLength>0,o=typeof n.Content=="string"&&n.Content!=="";if(a||o){const h=this.parseImage(i[s]);e[n.RelativeFilename||n.Filename]=h}}}}for(const i in t){const s=t[i];e[s]!==void 0?t[i]=e[s]:t[i]=t[i].split("\\").pop()}return t}parseImage(t){const e=t.Content,i=t.RelativeFilename||t.Filename,s=i.slice(i.lastIndexOf(".")+1).toLowerCase();let n;switch(s){case"bmp":n="image/bmp";break;case"jpg":case"jpeg":n="image/jpeg";break;case"png":n="image/png";break;case"tif":n="image/tiff";break;case"tga":this.manager.getHandler(".tga")===null&&console.warn("FBXLoader: TGA loader not found, skipping ",i),n="image/tga";break;default:console.warn('FBXLoader: Image type "'+s+'" is not supported.');return}if(typeof e=="string")return"data:"+n+";base64,"+e;{const r=new Uint8Array(e);return window.URL.createObjectURL(new Blob([r],{type:n}))}}parseTextures(t){const e=new Map;if("Texture"in k.Objects){const i=k.Objects.Texture;for(const s in i){const n=this.parseTexture(i[s],t);e.set(parseInt(s),n)}}return e}parseTexture(t,e){const i=this.loadTexture(t,e);i.ID=t.id,i.name=t.attrName;const s=t.WrapModeU,n=t.WrapModeV,r=s!==void 0?s.value:0,a=n!==void 0?n.value:0;if(i.wrapS=r===0?ue:le,i.wrapT=a===0?ue:le,"Scaling"in t){const o=t.Scaling.value;i.repeat.x=o[0],i.repeat.y=o[1]}if("Translation"in t){const o=t.Translation.value;i.offset.x=o[0],i.offset.y=o[1]}return i}loadTexture(t,e){let i;const s=this.textureLoader.path,n=q.get(t.id).children;n!==void 0&&n.length>0&&e[n[0].ID]!==void 0&&(i=e[n[0].ID],(i.indexOf("blob:")===0||i.indexOf("data:")===0)&&this.textureLoader.setPath(void 0));let r;const a=t.FileName.slice(-3).toLowerCase();if(a==="tga"){const o=this.manager.getHandler(".tga");o===null?(console.warn("FBXLoader: TGA loader not found, creating placeholder texture for",t.RelativeFilename),r=new ht):(o.setPath(this.textureLoader.path),r=o.load(i))}else a==="psd"?(console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for",t.RelativeFilename),r=new ht):r=this.textureLoader.load(i);return this.textureLoader.setPath(s),r}parseMaterials(t){const e=new Map;if("Material"in k.Objects){const i=k.Objects.Material;for(const s in i){const n=this.parseMaterial(i[s],t);n!==null&&e.set(parseInt(s),n)}}return e}parseMaterial(t,e){const i=t.id,s=t.attrName;let n=t.ShadingModel;if(typeof n=="object"&&(n=n.value),!q.has(i))return null;const r=this.parseParameters(t,e,i);let a;switch(n.toLowerCase()){case"phong":a=new Ss;break;case"lambert":a=new Ir;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',n),a=new Ss;break}return a.setValues(r),a.name=s,a}parseParameters(t,e,i){const s={};t.BumpFactor&&(s.bumpScale=t.BumpFactor.value),t.Diffuse?s.color=new U().fromArray(t.Diffuse.value):t.DiffuseColor&&(t.DiffuseColor.type==="Color"||t.DiffuseColor.type==="ColorRGB")&&(s.color=new U().fromArray(t.DiffuseColor.value)),t.DisplacementFactor&&(s.displacementScale=t.DisplacementFactor.value),t.Emissive?s.emissive=new U().fromArray(t.Emissive.value):t.EmissiveColor&&(t.EmissiveColor.type==="Color"||t.EmissiveColor.type==="ColorRGB")&&(s.emissive=new U().fromArray(t.EmissiveColor.value)),t.EmissiveFactor&&(s.emissiveIntensity=parseFloat(t.EmissiveFactor.value)),t.Opacity&&(s.opacity=parseFloat(t.Opacity.value)),s.opacity<1&&(s.transparent=!0),t.ReflectionFactor&&(s.reflectivity=t.ReflectionFactor.value),t.Shininess&&(s.shininess=t.Shininess.value),t.Specular?s.specular=new U().fromArray(t.Specular.value):t.SpecularColor&&t.SpecularColor.type==="Color"&&(s.specular=new U().fromArray(t.SpecularColor.value));const n=this;return q.get(i).children.forEach(function(r){const a=r.relationship;switch(a){case"Bump":s.bumpMap=n.getTexture(e,r.ID);break;case"Maya|TEX_ao_map":s.aoMap=n.getTexture(e,r.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":s.map=n.getTexture(e,r.ID),s.map!==void 0&&(s.map.encoding=jt);break;case"DisplacementColor":s.displacementMap=n.getTexture(e,r.ID);break;case"EmissiveColor":s.emissiveMap=n.getTexture(e,r.ID),s.emissiveMap!==void 0&&(s.emissiveMap.encoding=jt);break;case"NormalMap":case"Maya|TEX_normal_map":s.normalMap=n.getTexture(e,r.ID);break;case"ReflectionColor":s.envMap=n.getTexture(e,r.ID),s.envMap!==void 0&&(s.envMap.mapping=fa,s.envMap.encoding=jt);break;case"SpecularColor":s.specularMap=n.getTexture(e,r.ID),s.specularMap!==void 0&&(s.specularMap.encoding=jt);break;case"TransparentColor":case"TransparencyFactor":s.alphaMap=n.getTexture(e,r.ID),s.transparent=!0;break;case"AmbientColor":case"ShininessExponent":case"SpecularFactor":case"VectorDisplacementColor":default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",a);break}}),s}getTexture(t,e){return"LayeredTexture"in k.Objects&&e in k.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),e=q.get(e).children[0].ID),t.get(e)}parseDeformers(){const t={},e={};if("Deformer"in k.Objects){const i=k.Objects.Deformer;for(const s in i){const n=i[s],r=q.get(parseInt(s));if(n.attrType==="Skin"){const a=this.parseSkeleton(r,i);a.ID=s,r.parents.length>1&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),a.geometryID=r.parents[0].ID,t[s]=a}else if(n.attrType==="BlendShape"){const a={id:s};a.rawTargets=this.parseMorphTargets(r,i),a.id=s,r.parents.length>1&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),e[s]=a}}}return{skeletons:t,morphTargets:e}}parseSkeleton(t,e){const i=[];return t.children.forEach(function(s){const n=e[s.ID];if(n.attrType!=="Cluster")return;const r={ID:s.ID,indices:[],weights:[],transformLink:new P().fromArray(n.TransformLink.a)};"Indexes"in n&&(r.indices=n.Indexes.a,r.weights=n.Weights.a),i.push(r)}),{rawBones:i,bones:[]}}parseMorphTargets(t,e){const i=[];for(let s=0;s<t.children.length;s++){const n=t.children[s],r=e[n.ID],a={name:r.attrName,initialWeight:r.DeformPercent,id:r.id,fullWeights:r.FullWeights.a};if(r.attrType!=="BlendShapeChannel")return;a.geoID=q.get(parseInt(n.ID)).children.filter(function(o){return o.relationship===void 0})[0].ID,i.push(a)}return i}parseScene(t,e,i){at=new ai;const s=this.parseModels(t.skeletons,e,i),n=k.Objects.Model,r=this;s.forEach(function(o){const h=n[o.ID];r.setLookAtProperties(o,h),q.get(o.ID).parents.forEach(function(c){const d=s.get(c.ID);d!==void 0&&d.add(o)}),o.parent===null&&at.add(o)}),this.bindSkeleton(t.skeletons,e,s),this.createAmbientLight(),at.traverse(function(o){if(o.userData.transformData){o.parent&&(o.userData.transformData.parentMatrix=o.parent.matrix,o.userData.transformData.parentMatrixWorld=o.parent.matrixWorld);const h=$r(o.userData.transformData);o.applyMatrix4(h),o.updateWorldMatrix()}});const a=new jh().parse();at.children.length===1&&at.children[0].isGroup&&(at.children[0].animations=a,at=at.children[0]),at.animations=a}parseModels(t,e,i){const s=new Map,n=k.Objects.Model;for(const r in n){const a=parseInt(r),o=n[r],h=q.get(a);let l=this.buildSkeleton(h,t,a,o.attrName);if(!l){switch(o.attrType){case"Camera":l=this.createCamera(h);break;case"Light":l=this.createLight(h);break;case"Mesh":l=this.createMesh(h,e,i);break;case"NurbsCurve":l=this.createCurve(h,e);break;case"LimbNode":case"Root":l=new Xi;break;case"Null":default:l=new ai;break}l.name=o.attrName?B.sanitizeNodeName(o.attrName):"",l.ID=a}this.getTransformData(l,o),s.set(a,l)}return s}buildSkeleton(t,e,i,s){let n=null;return t.parents.forEach(function(r){for(const a in e){const o=e[a];o.rawBones.forEach(function(h,l){if(h.ID===r.ID){const c=n;n=new Xi,n.matrixWorld.copy(h.transformLink),n.name=s?B.sanitizeNodeName(s):"",n.ID=i,o.bones[l]=n,c!==null&&n.add(c)}})}}),n}createCamera(t){let e,i;if(t.children.forEach(function(s){const n=k.Objects.NodeAttribute[s.ID];n!==void 0&&(i=n)}),i===void 0)e=new H;else{let s=0;i.CameraProjectionType!==void 0&&i.CameraProjectionType.value===1&&(s=1);let n=1;i.NearPlane!==void 0&&(n=i.NearPlane.value/1e3);let r=1e3;i.FarPlane!==void 0&&(r=i.FarPlane.value/1e3);let a=window.innerWidth,o=window.innerHeight;i.AspectWidth!==void 0&&i.AspectHeight!==void 0&&(a=i.AspectWidth.value,o=i.AspectHeight.value);const h=a/o;let l=45;i.FieldOfView!==void 0&&(l=i.FieldOfView.value);const c=i.FocalLength?i.FocalLength.value:null;switch(s){case 0:e=new gi(l,h,n,r),c!==null&&e.setFocalLength(c);break;case 1:e=new Js(-a/2,a/2,o/2,-o/2,n,r);break;default:console.warn("THREE.FBXLoader: Unknown camera type "+s+"."),e=new H;break}}return e}createLight(t){let e,i;if(t.children.forEach(function(s){const n=k.Objects.NodeAttribute[s.ID];n!==void 0&&(i=n)}),i===void 0)e=new H;else{let s;i.LightType===void 0?s=0:s=i.LightType.value;let n=16777215;i.Color!==void 0&&(n=new U().fromArray(i.Color.value));let r=i.Intensity===void 0?1:i.Intensity.value/100;i.CastLightOnObject!==void 0&&i.CastLightOnObject.value===0&&(r=0);let a=0;i.FarAttenuationEnd!==void 0&&(i.EnableFarAttenuation!==void 0&&i.EnableFarAttenuation.value===0?a=0:a=i.FarAttenuationEnd.value);const o=1;switch(s){case 0:e=new Us(n,r,a,o);break;case 1:e=new an(n,r);break;case 2:let h=Math.PI/3;i.InnerAngle!==void 0&&(h=St.degToRad(i.InnerAngle.value));let l=0;i.OuterAngle!==void 0&&(l=St.degToRad(i.OuterAngle.value),l=Math.max(l,1)),e=new Or(n,r,a,h,l,o);break;default:console.warn("THREE.FBXLoader: Unknown light type "+i.LightType.value+", defaulting to a PointLight."),e=new Us(n,r);break}i.CastShadows!==void 0&&i.CastShadows.value===1&&(e.castShadow=!0)}return e}createMesh(t,e,i){let s,n=null,r=null;const a=[];return t.children.forEach(function(o){e.has(o.ID)&&(n=e.get(o.ID)),i.has(o.ID)&&a.push(i.get(o.ID))}),a.length>1?r=a:a.length>0?r=a[0]:(r=new Ss({color:13421772}),a.push(r)),"color"in n.attributes&&a.forEach(function(o){o.vertexColors=!0}),n.FBX_Deformer?(s=new Rr(n,r),s.normalizeSkinWeights()):s=new Ue(n,r),s}createCurve(t,e){const i=t.children.reduce(function(n,r){return e.has(r.ID)&&(n=e.get(r.ID)),n},null),s=new tn({color:3342591,linewidth:1});return new Ki(i,s)}getTransformData(t,e){const i={};"InheritType"in e&&(i.inheritType=parseInt(e.InheritType.value)),"RotationOrder"in e?i.eulerOrder=Kr(e.RotationOrder.value):i.eulerOrder="ZYX","Lcl_Translation"in e&&(i.translation=e.Lcl_Translation.value),"PreRotation"in e&&(i.preRotation=e.PreRotation.value),"Lcl_Rotation"in e&&(i.rotation=e.Lcl_Rotation.value),"PostRotation"in e&&(i.postRotation=e.PostRotation.value),"Lcl_Scaling"in e&&(i.scale=e.Lcl_Scaling.value),"ScalingOffset"in e&&(i.scalingOffset=e.ScalingOffset.value),"ScalingPivot"in e&&(i.scalingPivot=e.ScalingPivot.value),"RotationOffset"in e&&(i.rotationOffset=e.RotationOffset.value),"RotationPivot"in e&&(i.rotationPivot=e.RotationPivot.value),t.userData.transformData=i}setLookAtProperties(t,e){"LookAtProperty"in e&&q.get(t.ID).children.forEach(function(s){if(s.relationship==="LookAtProperty"){const n=k.Objects.Model[s.ID];if("Lcl_Translation"in n){const r=n.Lcl_Translation.value;t.target!==void 0?(t.target.position.fromArray(r),at.add(t.target)):t.lookAt(new x().fromArray(r))}}})}bindSkeleton(t,e,i){const s=this.parsePoseNodes();for(const n in t){const r=t[n];q.get(parseInt(r.ID)).parents.forEach(function(o){if(e.has(o.ID)){const h=o.ID;q.get(h).parents.forEach(function(c){i.has(c.ID)&&i.get(c.ID).bind(new $i(r.bones),s[c.ID])})}})}}parsePoseNodes(){const t={};if("Pose"in k.Objects){const e=k.Objects.Pose;for(const i in e)if(e[i].attrType==="BindPose"&&e[i].NbPoseNodes>0){const s=e[i].PoseNode;Array.isArray(s)?s.forEach(function(n){t[n.Node]=new P().fromArray(n.Matrix.a)}):t[s.Node]=new P().fromArray(s.Matrix.a)}}return t}createAmbientLight(){if("GlobalSettings"in k&&"AmbientColor"in k.GlobalSettings){const t=k.GlobalSettings.AmbientColor.value,e=t[0],i=t[1],s=t[2];if(e!==0||i!==0||s!==0){const n=new U(e,i,s);at.add(new Co(n,1))}}}}class Vh{constructor(){this.negativeMaterialIndices=!1}parse(t){const e=new Map;if("Geometry"in k.Objects){const i=k.Objects.Geometry;for(const s in i){const n=q.get(parseInt(s)),r=this.parseGeometry(n,i[s],t);e.set(parseInt(s),r)}}return this.negativeMaterialIndices===!0&&console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."),e}parseGeometry(t,e,i){switch(e.attrType){case"Mesh":return this.parseMeshGeometry(t,e,i);case"NurbsCurve":return this.parseNurbsGeometry(e)}}parseMeshGeometry(t,e,i){const s=i.skeletons,n=[],r=t.parents.map(function(c){return k.Objects.Model[c.ID]});if(r.length===0)return;const a=t.children.reduce(function(c,d){return s[d.ID]!==void 0&&(c=s[d.ID]),c},null);t.children.forEach(function(c){i.morphTargets[c.ID]!==void 0&&n.push(i.morphTargets[c.ID])});const o=r[0],h={};"RotationOrder"in o&&(h.eulerOrder=Kr(o.RotationOrder.value)),"InheritType"in o&&(h.inheritType=parseInt(o.InheritType.value)),"GeometricTranslation"in o&&(h.translation=o.GeometricTranslation.value),"GeometricRotation"in o&&(h.rotation=o.GeometricRotation.value),"GeometricScaling"in o&&(h.scale=o.GeometricScaling.value);const l=$r(h);return this.genGeometry(e,a,n,l)}genGeometry(t,e,i,s){const n=new Ct;t.attrName&&(n.name=t.attrName);const r=this.parseGeoNode(t,e),a=this.genBuffers(r),o=new gt(a.vertex,3);if(o.applyMatrix4(s),n.setAttribute("position",o),a.colors.length>0&&n.setAttribute("color",new gt(a.colors,3)),e&&(n.setAttribute("skinIndex",new Er(a.weightsIndices,4)),n.setAttribute("skinWeight",new gt(a.vertexWeights,4)),n.FBX_Deformer=e),a.normal.length>0){const h=new ne().getNormalMatrix(s),l=new gt(a.normal,3);l.applyNormalMatrix(h),n.setAttribute("normal",l)}if(a.uvs.forEach(function(h,l){let c="uv"+(l+1).toString();l===0&&(c="uv"),n.setAttribute(c,new gt(a.uvs[l],2))}),r.material&&r.material.mappingType!=="AllSame"){let h=a.materialIndex[0],l=0;if(a.materialIndex.forEach(function(c,d){c!==h&&(n.addGroup(l,d-l,h),h=c,l=d)}),n.groups.length>0){const c=n.groups[n.groups.length-1],d=c.start+c.count;d!==a.materialIndex.length&&n.addGroup(d,a.materialIndex.length-d,h)}n.groups.length===0&&n.addGroup(0,a.materialIndex.length,a.materialIndex[0])}return this.addMorphTargets(n,t,i,s),n}parseGeoNode(t,e){const i={};if(i.vertexPositions=t.Vertices!==void 0?t.Vertices.a:[],i.vertexIndices=t.PolygonVertexIndex!==void 0?t.PolygonVertexIndex.a:[],t.LayerElementColor&&(i.color=this.parseVertexColors(t.LayerElementColor[0])),t.LayerElementMaterial&&(i.material=this.parseMaterialIndices(t.LayerElementMaterial[0])),t.LayerElementNormal&&(i.normal=this.parseNormals(t.LayerElementNormal[0])),t.LayerElementUV){i.uv=[];let s=0;for(;t.LayerElementUV[s];)t.LayerElementUV[s].UV&&i.uv.push(this.parseUVs(t.LayerElementUV[s])),s++}return i.weightTable={},e!==null&&(i.skeleton=e,e.rawBones.forEach(function(s,n){s.indices.forEach(function(r,a){i.weightTable[r]===void 0&&(i.weightTable[r]=[]),i.weightTable[r].push({id:n,weight:s.weights[a]})})})),i}genBuffers(t){const e={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]};let i=0,s=0,n=!1,r=[],a=[],o=[],h=[],l=[],c=[];const d=this;return t.vertexIndices.forEach(function(p,f){let m,g=!1;p<0&&(p=p^-1,g=!0);let y=[],M=[];if(r.push(p*3,p*3+1,p*3+2),t.color){const w=ji(f,i,p,t.color);o.push(w[0],w[1],w[2])}if(t.skeleton){if(t.weightTable[p]!==void 0&&t.weightTable[p].forEach(function(w){M.push(w.weight),y.push(w.id)}),M.length>4){n||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),n=!0);const w=[0,0,0,0],S=[0,0,0,0];M.forEach(function(v,_){let A=v,R=y[_];S.forEach(function(G,C,O){if(A>G){O[C]=A,A=G;const z=w[C];w[C]=R,R=z}})}),y=w,M=S}for(;M.length<4;)M.push(0),y.push(0);for(let w=0;w<4;++w)l.push(M[w]),c.push(y[w])}if(t.normal){const w=ji(f,i,p,t.normal);a.push(w[0],w[1],w[2])}t.material&&t.material.mappingType!=="AllSame"&&(m=ji(f,i,p,t.material)[0],m<0&&(d.negativeMaterialIndices=!0,m=0)),t.uv&&t.uv.forEach(function(w,S){const v=ji(f,i,p,w);h[S]===void 0&&(h[S]=[]),h[S].push(v[0]),h[S].push(v[1])}),s++,g&&(s>4&&console.warn("THREE.FBXLoader: Polygons with more than four sides are not supported. Make sure to triangulate the geometry during export."),d.genFace(e,t,r,m,a,o,h,l,c,s),i++,s=0,r=[],a=[],o=[],h=[],l=[],c=[])}),e}genFace(t,e,i,s,n,r,a,o,h,l){for(let c=2;c<l;c++)t.vertex.push(e.vertexPositions[i[0]]),t.vertex.push(e.vertexPositions[i[1]]),t.vertex.push(e.vertexPositions[i[2]]),t.vertex.push(e.vertexPositions[i[(c-1)*3]]),t.vertex.push(e.vertexPositions[i[(c-1)*3+1]]),t.vertex.push(e.vertexPositions[i[(c-1)*3+2]]),t.vertex.push(e.vertexPositions[i[c*3]]),t.vertex.push(e.vertexPositions[i[c*3+1]]),t.vertex.push(e.vertexPositions[i[c*3+2]]),e.skeleton&&(t.vertexWeights.push(o[0]),t.vertexWeights.push(o[1]),t.vertexWeights.push(o[2]),t.vertexWeights.push(o[3]),t.vertexWeights.push(o[(c-1)*4]),t.vertexWeights.push(o[(c-1)*4+1]),t.vertexWeights.push(o[(c-1)*4+2]),t.vertexWeights.push(o[(c-1)*4+3]),t.vertexWeights.push(o[c*4]),t.vertexWeights.push(o[c*4+1]),t.vertexWeights.push(o[c*4+2]),t.vertexWeights.push(o[c*4+3]),t.weightsIndices.push(h[0]),t.weightsIndices.push(h[1]),t.weightsIndices.push(h[2]),t.weightsIndices.push(h[3]),t.weightsIndices.push(h[(c-1)*4]),t.weightsIndices.push(h[(c-1)*4+1]),t.weightsIndices.push(h[(c-1)*4+2]),t.weightsIndices.push(h[(c-1)*4+3]),t.weightsIndices.push(h[c*4]),t.weightsIndices.push(h[c*4+1]),t.weightsIndices.push(h[c*4+2]),t.weightsIndices.push(h[c*4+3])),e.color&&(t.colors.push(r[0]),t.colors.push(r[1]),t.colors.push(r[2]),t.colors.push(r[(c-1)*3]),t.colors.push(r[(c-1)*3+1]),t.colors.push(r[(c-1)*3+2]),t.colors.push(r[c*3]),t.colors.push(r[c*3+1]),t.colors.push(r[c*3+2])),e.material&&e.material.mappingType!=="AllSame"&&(t.materialIndex.push(s),t.materialIndex.push(s),t.materialIndex.push(s)),e.normal&&(t.normal.push(n[0]),t.normal.push(n[1]),t.normal.push(n[2]),t.normal.push(n[(c-1)*3]),t.normal.push(n[(c-1)*3+1]),t.normal.push(n[(c-1)*3+2]),t.normal.push(n[c*3]),t.normal.push(n[c*3+1]),t.normal.push(n[c*3+2])),e.uv&&e.uv.forEach(function(d,p){t.uvs[p]===void 0&&(t.uvs[p]=[]),t.uvs[p].push(a[p][0]),t.uvs[p].push(a[p][1]),t.uvs[p].push(a[p][(c-1)*2]),t.uvs[p].push(a[p][(c-1)*2+1]),t.uvs[p].push(a[p][c*2]),t.uvs[p].push(a[p][c*2+1])})}addMorphTargets(t,e,i,s){if(i.length===0)return;t.morphTargetsRelative=!0,t.morphAttributes.position=[];const n=this;i.forEach(function(r){r.rawTargets.forEach(function(a){const o=k.Objects.Geometry[a.geoID];o!==void 0&&n.genMorphGeometry(t,e,o,s,a.name)})})}genMorphGeometry(t,e,i,s,n){const r=e.PolygonVertexIndex!==void 0?e.PolygonVertexIndex.a:[],a=i.Vertices!==void 0?i.Vertices.a:[],o=i.Indexes!==void 0?i.Indexes.a:[],h=t.attributes.position.count*3,l=new Float32Array(h);for(let f=0;f<o.length;f++){const m=o[f]*3;l[m]=a[f*3],l[m+1]=a[f*3+1],l[m+2]=a[f*3+2]}const c={vertexIndices:r,vertexPositions:l},d=this.genBuffers(c),p=new gt(d.vertex,3);p.name=n||i.attrName,p.applyMatrix4(s),t.morphAttributes.position.push(p)}parseNormals(t){const e=t.MappingInformationType,i=t.ReferenceInformationType,s=t.Normals.a;let n=[];return i==="IndexToDirect"&&("NormalIndex"in t?n=t.NormalIndex.a:"NormalsIndex"in t&&(n=t.NormalsIndex.a)),{dataSize:3,buffer:s,indices:n,mappingType:e,referenceType:i}}parseUVs(t){const e=t.MappingInformationType,i=t.ReferenceInformationType,s=t.UV.a;let n=[];return i==="IndexToDirect"&&(n=t.UVIndex.a),{dataSize:2,buffer:s,indices:n,mappingType:e,referenceType:i}}parseVertexColors(t){const e=t.MappingInformationType,i=t.ReferenceInformationType,s=t.Colors.a;let n=[];return i==="IndexToDirect"&&(n=t.ColorIndex.a),{dataSize:4,buffer:s,indices:n,mappingType:e,referenceType:i}}parseMaterialIndices(t){const e=t.MappingInformationType,i=t.ReferenceInformationType;if(e==="NoMappingInformation")return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:i};const s=t.Materials.a,n=[];for(let r=0;r<s.length;++r)n.push(r);return{dataSize:1,buffer:s,indices:n,mappingType:e,referenceType:i}}parseNurbsGeometry(t){const e=parseInt(t.Order);if(isNaN(e))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",t.Order,t.id),new Ct;const i=e-1,s=t.KnotVector.a,n=[],r=t.Points.a;for(let c=0,d=r.length;c<d;c+=4)n.push(new it().fromArray(r,c));let a,o;if(t.Form==="Closed")n.push(n[0]);else if(t.Form==="Periodic"){a=i,o=s.length-1-a;for(let c=0;c<i;++c)n.push(n[c])}const l=new Nh(i,s,n,a,o).getPoints(n.length*12);return new Ct().setFromPoints(l)}}class jh{parse(){const t=[],e=this.parseClips();if(e!==void 0)for(const i in e){const s=e[i],n=this.addClip(s);t.push(n)}return t}parseClips(){if(k.Objects.AnimationCurve===void 0)return;const t=this.parseAnimationCurveNodes();this.parseAnimationCurves(t);const e=this.parseAnimationLayers(t);return this.parseAnimStacks(e)}parseAnimationCurveNodes(){const t=k.Objects.AnimationCurveNode,e=new Map;for(const i in t){const s=t[i];if(s.attrName.match(/S|R|T|DeformPercent/)!==null){const n={id:s.id,attr:s.attrName,curves:{}};e.set(n.id,n)}}return e}parseAnimationCurves(t){const e=k.Objects.AnimationCurve;for(const i in e){const s={id:e[i].id,times:e[i].KeyTime.a.map(Yh),values:e[i].KeyValueFloat.a},n=q.get(s.id);if(n!==void 0){const r=n.parents[0].ID,a=n.parents[0].relationship;a.match(/X/)?t.get(r).curves.x=s:a.match(/Y/)?t.get(r).curves.y=s:a.match(/Z/)?t.get(r).curves.z=s:a.match(/d|DeformPercent/)&&t.has(r)&&(t.get(r).curves.morph=s)}}}parseAnimationLayers(t){const e=k.Objects.AnimationLayer,i=new Map;for(const s in e){const n=[],r=q.get(parseInt(s));r!==void 0&&(r.children.forEach(function(o,h){if(t.has(o.ID)){const l=t.get(o.ID);if(l.curves.x!==void 0||l.curves.y!==void 0||l.curves.z!==void 0){if(n[h]===void 0){const c=q.get(o.ID).parents.filter(function(d){return d.relationship!==void 0})[0].ID;if(c!==void 0){const d=k.Objects.Model[c.toString()];if(d===void 0){console.warn("THREE.FBXLoader: Encountered a unused curve.",o);return}const p={modelName:d.attrName?B.sanitizeNodeName(d.attrName):"",ID:d.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};at.traverse(function(f){f.ID===d.id&&(p.transform=f.matrix,f.userData.transformData&&(p.eulerOrder=f.userData.transformData.eulerOrder))}),p.transform||(p.transform=new P),"PreRotation"in d&&(p.preRotation=d.PreRotation.value),"PostRotation"in d&&(p.postRotation=d.PostRotation.value),n[h]=p}}n[h]&&(n[h][l.attr]=l)}else if(l.curves.morph!==void 0){if(n[h]===void 0){const c=q.get(o.ID).parents.filter(function(y){return y.relationship!==void 0})[0].ID,d=q.get(c).parents[0].ID,p=q.get(d).parents[0].ID,f=q.get(p).parents[0].ID,m=k.Objects.Model[f],g={modelName:m.attrName?B.sanitizeNodeName(m.attrName):"",morphName:k.Objects.Deformer[c].attrName};n[h]=g}n[h][l.attr]=l}}}),i.set(parseInt(s),n))}return i}parseAnimStacks(t){const e=k.Objects.AnimationStack,i={};for(const s in e){const n=q.get(parseInt(s)).children;n.length>1&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");const r=t.get(n[0].ID);i[s]={name:e[s].attrName,layer:r}}return i}addClip(t){let e=[];const i=this;return t.layer.forEach(function(s){e=e.concat(i.generateTracks(s))}),new Br(t.name,-1,e)}generateTracks(t){const e=[];let i=new x,s=new ot,n=new x;if(t.transform&&t.transform.decompose(i,s,n),i=i.toArray(),s=new dt().setFromQuaternion(s,t.eulerOrder).toArray(),n=n.toArray(),t.T!==void 0&&Object.keys(t.T.curves).length>0){const r=this.generateVectorTrack(t.modelName,t.T.curves,i,"position");r!==void 0&&e.push(r)}if(t.R!==void 0&&Object.keys(t.R.curves).length>0){const r=this.generateRotationTrack(t.modelName,t.R.curves,s,t.preRotation,t.postRotation,t.eulerOrder);r!==void 0&&e.push(r)}if(t.S!==void 0&&Object.keys(t.S.curves).length>0){const r=this.generateVectorTrack(t.modelName,t.S.curves,n,"scale");r!==void 0&&e.push(r)}if(t.DeformPercent!==void 0){const r=this.generateMorphTrack(t);r!==void 0&&e.push(r)}return e}generateVectorTrack(t,e,i,s){const n=this.getTimesForAllAxes(e),r=this.getKeyframeTrackValues(n,e,i);return new Be(t+"."+s,n,r)}generateRotationTrack(t,e,i,s,n,r){e.x!==void 0&&(this.interpolateRotations(e.x),e.x.values=e.x.values.map(St.degToRad)),e.y!==void 0&&(this.interpolateRotations(e.y),e.y.values=e.y.values.map(St.degToRad)),e.z!==void 0&&(this.interpolateRotations(e.z),e.z.values=e.z.values.map(St.degToRad));const a=this.getTimesForAllAxes(e),o=this.getKeyframeTrackValues(a,e,i);s!==void 0&&(s=s.map(St.degToRad),s.push(r),s=new dt().fromArray(s),s=new ot().setFromEuler(s)),n!==void 0&&(n=n.map(St.degToRad),n.push(r),n=new dt().fromArray(n),n=new ot().setFromEuler(n).invert());const h=new ot,l=new dt,c=[];for(let d=0;d<o.length;d+=3)l.set(o[d],o[d+1],o[d+2],r),h.setFromEuler(l),s!==void 0&&h.premultiply(s),n!==void 0&&h.multiply(n),h.toArray(c,d/3*4);return new se(t+".quaternion",a,c)}generateMorphTrack(t){const e=t.DeformPercent.curves.morph,i=e.values.map(function(n){return n/100}),s=at.getObjectByName(t.modelName).morphTargetDictionary[t.morphName];return new ze(t.modelName+".morphTargetInfluences["+s+"]",e.times,i)}getTimesForAllAxes(t){let e=[];if(t.x!==void 0&&(e=e.concat(t.x.times)),t.y!==void 0&&(e=e.concat(t.y.times)),t.z!==void 0&&(e=e.concat(t.z.times)),e=e.sort(function(i,s){return i-s}),e.length>1){let i=1,s=e[0];for(let n=1;n<e.length;n++){const r=e[n];r!==s&&(e[i]=r,s=r,i++)}e=e.slice(0,i)}return e}getKeyframeTrackValues(t,e,i){const s=i,n=[];let r=-1,a=-1,o=-1;return t.forEach(function(h){if(e.x&&(r=e.x.times.indexOf(h)),e.y&&(a=e.y.times.indexOf(h)),e.z&&(o=e.z.times.indexOf(h)),r!==-1){const l=e.x.values[r];n.push(l),s[0]=l}else n.push(s[0]);if(a!==-1){const l=e.y.values[a];n.push(l),s[1]=l}else n.push(s[1]);if(o!==-1){const l=e.z.values[o];n.push(l),s[2]=l}else n.push(s[2])}),n}interpolateRotations(t){for(let e=1;e<t.values.length;e++){const i=t.values[e-1],s=t.values[e]-i,n=Math.abs(s);if(n>=180){const r=n/180,a=s/r;let o=i+a;const h=t.times[e-1],c=(t.times[e]-h)/r;let d=h+c;const p=[],f=[];for(;d<t.times[e];)p.push(d),d+=c,f.push(o),o+=a;t.times=gr(t.times,e,p),t.values=gr(t.values,e,f)}}}}class Hh{getPrevNode(){return this.nodeStack[this.currentIndent-2]}getCurrentNode(){return this.nodeStack[this.currentIndent-1]}getCurrentProp(){return this.currentProp}pushStack(t){this.nodeStack.push(t),this.currentIndent+=1}popStack(){this.nodeStack.pop(),this.currentIndent-=1}setCurrentProp(t,e){this.currentProp=t,this.currentPropName=e}parse(t){this.currentIndent=0,this.allNodes=new Yr,this.nodeStack=[],this.currentProp=[],this.currentPropName="";const e=this,i=t.split(/[\r\n]+/);return i.forEach(function(s,n){const r=s.match(/^[\s\t]*;/),a=s.match(/^[\s\t]*$/);if(r||a)return;const o=s.match("^\\t{"+e.currentIndent+"}(\\w+):(.*){",""),h=s.match("^\\t{"+e.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),l=s.match("^\\t{"+(e.currentIndent-1)+"}}");o?e.parseNodeBegin(s,o):h?e.parseNodeProperty(s,h,i[++n]):l?e.popStack():s.match(/^[^\s\t}]/)&&e.parseNodePropertyContinued(s)}),this.allNodes}parseNodeBegin(t,e){const i=e[1].trim().replace(/^"/,"").replace(/"$/,""),s=e[2].split(",").map(function(o){return o.trim().replace(/^"/,"").replace(/"$/,"")}),n={name:i},r=this.parseNodeAttr(s),a=this.getCurrentNode();this.currentIndent===0?this.allNodes.add(i,n):i in a?(i==="PoseNode"?a.PoseNode.push(n):a[i].id!==void 0&&(a[i]={},a[i][a[i].id]=a[i]),r.id!==""&&(a[i][r.id]=n)):typeof r.id=="number"?(a[i]={},a[i][r.id]=n):i!=="Properties70"&&(i==="PoseNode"?a[i]=[n]:a[i]=n),typeof r.id=="number"&&(n.id=r.id),r.name!==""&&(n.attrName=r.name),r.type!==""&&(n.attrType=r.type),this.pushStack(n)}parseNodeAttr(t){let e=t[0];t[0]!==""&&(e=parseInt(t[0]),isNaN(e)&&(e=t[0]));let i="",s="";return t.length>1&&(i=t[1].replace(/^(\w+)::/,""),s=t[2]),{id:e,name:i,type:s}}parseNodeProperty(t,e,i){let s=e[1].replace(/^"/,"").replace(/"$/,"").trim(),n=e[2].replace(/^"/,"").replace(/"$/,"").trim();s==="Content"&&n===","&&(n=i.replace(/"/g,"").replace(/,$/,"").trim());const r=this.getCurrentNode();if(r.name==="Properties70"){this.parseNodeSpecialProperty(t,s,n);return}if(s==="C"){const o=n.split(",").slice(1),h=parseInt(o[0]),l=parseInt(o[1]);let c=n.split(",").slice(3);c=c.map(function(d){return d.trim().replace(/^"/,"")}),s="connections",n=[h,l],Kh(n,c),r[s]===void 0&&(r[s]=[])}s==="Node"&&(r.id=n),s in r&&Array.isArray(r[s])?r[s].push(n):s!=="a"?r[s]=n:r.a=n,this.setCurrentProp(r,s),s==="a"&&n.slice(-1)!==","&&(r.a=ks(n))}parseNodePropertyContinued(t){const e=this.getCurrentNode();e.a+=t,t.slice(-1)!==","&&(e.a=ks(e.a))}parseNodeSpecialProperty(t,e,i){const s=i.split('",').map(function(l){return l.trim().replace(/^\"/,"").replace(/\s/,"_")}),n=s[0],r=s[1],a=s[2],o=s[3];let h=s[4];switch(r){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":h=parseFloat(h);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":h=ks(h);break}this.getPrevNode()[n]={type:r,type2:a,flag:o,value:h},this.setCurrentProp(this.getPrevNode(),n)}}class Wh{parse(t){const e=new fr(t);e.skip(23);const i=e.getUint32();if(i<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+i);const s=new Yr;for(;!this.endOfContent(e);){const n=this.parseNode(e,i);n!==null&&s.add(n.name,n)}return s}endOfContent(t){return t.size()%16===0?(t.getOffset()+160+16&-16)>=t.size():t.getOffset()+160+16>=t.size()}parseNode(t,e){const i={},s=e>=7500?t.getUint64():t.getUint32(),n=e>=7500?t.getUint64():t.getUint32();e>=7500?t.getUint64():t.getUint32();const r=t.getUint8(),a=t.getString(r);if(s===0)return null;const o=[];for(let d=0;d<n;d++)o.push(this.parseProperty(t));const h=o.length>0?o[0]:"",l=o.length>1?o[1]:"",c=o.length>2?o[2]:"";for(i.singleProperty=n===1&&t.getOffset()===s;s>t.getOffset();){const d=this.parseNode(t,e);d!==null&&this.parseSubNode(a,i,d)}return i.propertyList=o,typeof h=="number"&&(i.id=h),l!==""&&(i.attrName=l),c!==""&&(i.attrType=c),a!==""&&(i.name=a),i}parseSubNode(t,e,i){if(i.singleProperty===!0){const s=i.propertyList[0];Array.isArray(s)?(e[i.name]=i,i.a=s):e[i.name]=s}else if(t==="Connections"&&i.name==="C"){const s=[];i.propertyList.forEach(function(n,r){r!==0&&s.push(n)}),e.connections===void 0&&(e.connections=[]),e.connections.push(s)}else if(i.name==="Properties70")Object.keys(i).forEach(function(n){e[n]=i[n]});else if(t==="Properties70"&&i.name==="P"){let s=i.propertyList[0],n=i.propertyList[1];const r=i.propertyList[2],a=i.propertyList[3];let o;s.indexOf("Lcl ")===0&&(s=s.replace("Lcl ","Lcl_")),n.indexOf("Lcl ")===0&&(n=n.replace("Lcl ","Lcl_")),n==="Color"||n==="ColorRGB"||n==="Vector"||n==="Vector3D"||n.indexOf("Lcl_")===0?o=[i.propertyList[4],i.propertyList[5],i.propertyList[6]]:o=i.propertyList[4],e[s]={type:n,type2:r,flag:a,value:o}}else e[i.name]===void 0?typeof i.id=="number"?(e[i.name]={},e[i.name][i.id]=i):e[i.name]=i:i.name==="PoseNode"?(Array.isArray(e[i.name])||(e[i.name]=[e[i.name]]),e[i.name].push(i)):e[i.name][i.id]===void 0&&(e[i.name][i.id]=i)}parseProperty(t){const e=t.getString(1);let i;switch(e){case"C":return t.getBoolean();case"D":return t.getFloat64();case"F":return t.getFloat32();case"I":return t.getInt32();case"L":return t.getInt64();case"R":return i=t.getUint32(),t.getArrayBuffer(i);case"S":return i=t.getUint32(),t.getString(i);case"Y":return t.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":const s=t.getUint32(),n=t.getUint32(),r=t.getUint32();if(n===0)switch(e){case"b":case"c":return t.getBooleanArray(s);case"d":return t.getFloat64Array(s);case"f":return t.getFloat32Array(s);case"i":return t.getInt32Array(s);case"l":return t.getInt64Array(s)}const a=Ch(new Uint8Array(t.getArrayBuffer(r))),o=new fr(a.buffer);switch(e){case"b":case"c":return o.getBooleanArray(s);case"d":return o.getFloat64Array(s);case"f":return o.getFloat32Array(s);case"i":return o.getInt32Array(s);case"l":return o.getInt64Array(s)}break;default:throw new Error("THREE.FBXLoader: Unknown property type "+e)}}}class fr{constructor(t,e){this.dv=new DataView(t),this.offset=0,this.littleEndian=e!==void 0?e:!0}getOffset(){return this.offset}size(){return this.dv.buffer.byteLength}skip(t){this.offset+=t}getBoolean(){return(this.getUint8()&1)===1}getBooleanArray(t){const e=[];for(let i=0;i<t;i++)e.push(this.getBoolean());return e}getUint8(){const t=this.dv.getUint8(this.offset);return this.offset+=1,t}getInt16(){const t=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,t}getInt32(){const t=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,t}getInt32Array(t){const e=[];for(let i=0;i<t;i++)e.push(this.getInt32());return e}getUint32(){const t=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,t}getInt64(){let t,e;return this.littleEndian?(t=this.getUint32(),e=this.getUint32()):(e=this.getUint32(),t=this.getUint32()),e&2147483648?(e=~e&4294967295,t=~t&4294967295,t===4294967295&&(e=e+1&4294967295),t=t+1&4294967295,-(e*4294967296+t)):e*4294967296+t}getInt64Array(t){const e=[];for(let i=0;i<t;i++)e.push(this.getInt64());return e}getUint64(){let t,e;return this.littleEndian?(t=this.getUint32(),e=this.getUint32()):(e=this.getUint32(),t=this.getUint32()),e*4294967296+t}getFloat32(){const t=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,t}getFloat32Array(t){const e=[];for(let i=0;i<t;i++)e.push(this.getFloat32());return e}getFloat64(){const t=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,t}getFloat64Array(t){const e=[];for(let i=0;i<t;i++)e.push(this.getFloat64());return e}getArrayBuffer(t){const e=this.dv.buffer.slice(this.offset,this.offset+t);return this.offset+=t,e}getString(t){let e=[];for(let s=0;s<t;s++)e[s]=this.getUint8();const i=e.indexOf(0);return i>=0&&(e=e.slice(0,i)),Rt.decodeText(new Uint8Array(e))}}class Yr{add(t,e){this[t]=e}}function Xh(u){const t="Kaydara FBX Binary  \0";return u.byteLength>=t.length&&t===Zr(u,0,t.length)}function qh(u){const t=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"];let e=0;function i(s){const n=u[s-1];return u=u.slice(e+s),e++,n}for(let s=0;s<t.length;++s)if(i(1)===t[s])return!1;return!0}function mr(u){const t=/FBXVersion: (\d+)/,e=u.match(t);if(e)return parseInt(e[1]);throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}function Yh(u){return u/46186158e3}const $h=[];function ji(u,t,e,i){let s;switch(i.mappingType){case"ByPolygonVertex":s=u;break;case"ByPolygon":s=t;break;case"ByVertice":s=e;break;case"AllSame":s=i.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+i.mappingType)}i.referenceType==="IndexToDirect"&&(s=i.indices[s]);const n=s*i.dataSize,r=n+i.dataSize;return Zh($h,i.buffer,n,r)}const Is=new dt,Fe=new x;function $r(u){const t=new P,e=new P,i=new P,s=new P,n=new P,r=new P,a=new P,o=new P,h=new P,l=new P,c=new P,d=new P,p=u.inheritType?u.inheritType:0;if(u.translation&&t.setPosition(Fe.fromArray(u.translation)),u.preRotation){const C=u.preRotation.map(St.degToRad);C.push(u.eulerOrder||dt.DefaultOrder),e.makeRotationFromEuler(Is.fromArray(C))}if(u.rotation){const C=u.rotation.map(St.degToRad);C.push(u.eulerOrder||dt.DefaultOrder),i.makeRotationFromEuler(Is.fromArray(C))}if(u.postRotation){const C=u.postRotation.map(St.degToRad);C.push(u.eulerOrder||dt.DefaultOrder),s.makeRotationFromEuler(Is.fromArray(C)),s.invert()}u.scale&&n.scale(Fe.fromArray(u.scale)),u.scalingOffset&&a.setPosition(Fe.fromArray(u.scalingOffset)),u.scalingPivot&&r.setPosition(Fe.fromArray(u.scalingPivot)),u.rotationOffset&&o.setPosition(Fe.fromArray(u.rotationOffset)),u.rotationPivot&&h.setPosition(Fe.fromArray(u.rotationPivot)),u.parentMatrixWorld&&(c.copy(u.parentMatrix),l.copy(u.parentMatrixWorld));const f=e.clone().multiply(i).multiply(s),m=new P;m.extractRotation(l);const g=new P;g.copyPosition(l);const y=g.clone().invert().multiply(l),M=m.clone().invert().multiply(y),w=n,S=new P;if(p===0)S.copy(m).multiply(f).multiply(M).multiply(w);else if(p===1)S.copy(m).multiply(M).multiply(f).multiply(w);else{const O=new P().scale(new x().setFromMatrixScale(c)).clone().invert(),z=M.clone().multiply(O);S.copy(m).multiply(f).multiply(z).multiply(w)}const v=h.clone().invert(),_=r.clone().invert();let A=t.clone().multiply(o).multiply(h).multiply(e).multiply(i).multiply(s).multiply(v).multiply(a).multiply(r).multiply(n).multiply(_);const R=new P().copyPosition(A),G=l.clone().multiply(R);return d.copyPosition(G),A=d.clone().multiply(S),A.premultiply(l.invert()),A}function Kr(u){u=u||0;const t=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return u===6?(console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),t[0]):t[u]}function ks(u){return u.split(",").map(function(e){return parseFloat(e)})}function Zr(u,t,e){return t===void 0&&(t=0),e===void 0&&(e=u.byteLength),Rt.decodeText(new Uint8Array(u,t,e))}function Kh(u,t){for(let e=0,i=u.length,s=t.length;e<s;e++,i++)u[i]=t[e]}function Zh(u,t,e,i){for(let s=e,n=0;s<i;s++,n++)u[n]=t[s];return u}function gr(u,t,e){return u.slice(0,t).concat(e).concat(u.slice(t))}class Jh{constructor(){T(this,"loaderGLTF");T(this,"loaderFBX");T(this,"loaderTexture");T(this,"loaderCubeTexture");this.loaderGLTF=new Go,this.loaderFBX=new Uh,this.loaderTexture=new nn,this.loaderCubeTexture=new _o}loadGLTF(t){return new Promise((e,i)=>{this.loaderGLTF.load(t,s=>{e(s)},null,s=>i(s))})}loadFBX(t){return new Promise((e,i)=>{this.loaderFBX.load(t,s=>{e(s)},null,s=>i(s))})}loadTexture(t){return new Promise((e,i)=>{this.loaderTexture.load(t,s=>{s.flipY=!1,e(s)},null,s=>i(s))})}loadCubeTexture(t){return new Promise((e,i)=>{t.length!=6&&i(new Error("Number of cube texture paths is Not 6")),this.loaderCubeTexture.load(t,s=>e(s),null,s=>i(s))})}}let Qh=new Jh;const Qt={index:{label:"Index Buffer",cpuFormat:"[object Uint16Array]",usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST},position:{label:"Position Vertex Buffer",cpuFormat:"[object Float32Array]",gpuFormat:"float32x3",usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,stride:3*4},normal:{label:"Normal Vertex Buffer",cpuFormat:"[object Float32Array]",gpuFormat:"float32x3",usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,stride:3*4},color:{label:"Color Vertex Buffer",cpuFormat:"[object Float32Array]",gpuFormat:"float32x4",usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,stride:4*4},uv:{label:"UV Vertex Buffer",cpuFormat:"[object Float32Array]",gpuFormat:"float32x2",usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,stride:2*4}};class tl{constructor(){}createLayout(t){let e=[],i=0;for(let s of t)if(s!=="index"){if(!Qt[s])throw new Error(`Vertex Buffer Attribute Not Exist: ${s}`);e.push({arrayStride:Qt[s].stride,attributes:[{shaderLocation:i,offset:0,format:Qt[s].gpuFormat}]}),i++}return e}createResource(t,e){let i={};for(const s of t){if(!Qt[s])throw new Error(`Vertex Buffer Attribute Not Exist: ${s}`);if(!e[s])throw new Error(`${s} Needs Copy Data`);if(Object.prototype.toString.call(e[s])!=Qt[s].cpuFormat)throw new Error(`Invalide Type of Vertex Buffer Attribute '${s}'. Should Be ${Qt[s].cpuFormat}, But Got ${Object.prototype.toString.call(e[s])}.`);e[s].byteLength%4!=0&&(e[s]=new Uint16Array([...e[s],0]));const n=E.createBuffer({label:Qt[s].label,usage:Qt[s].usage,size:e[s].byteLength});E.queue.writeBuffer(n,0,e[s]),i[s]=n}return i}}const ui=class{constructor(){T(this,"resources");this.resources=new WeakMap}static RegisterFormats(t){for(const e in t){if(ui.Formats[e])throw new Error(`Resource Format ${e} has already Registered!`);ui.Formats[e]=t[e]}}async toBitmap(t){return t instanceof ImageBitmap?t:await createImageBitmap(t)}toBitmaps(t){let e=[];return t.forEach(i=>{e.push(this.toBitmap(i))}),Promise.all(e)}async createResource(t,e){var s;let i={};for(const n of t){const r=ui.Formats[n];if(!r)throw new Error(`Resource Attribute Not Exist: ${n}`);switch(r.type){case"buffer":{const a=e[n];let o=this.resources.get(a==null?void 0:a.value);o||(o=E.createBuffer({label:r.label,size:((s=a==null?void 0:a.value)==null?void 0:s.byteLength)||(a==null?void 0:a.size)||r.size,usage:r.usage}),a!=null&&a.value&&(E.queue.writeBuffer(o,0,a==null?void 0:a.value),this.resources.set(a==null?void 0:a.value,o))),i[n]=o;break}case"sampler":{let a=this.resources.get(r);a||(a=E.createSampler({label:r.label,magFilter:r.magFilter||"linear",minFilter:r.minFilter||"linear",mipmapFilter:r.mipmapFilter||"linear",compare:r.compare||void 0}),this.resources.set(r,a)),i[n]=a;break}case"texture":{const a=e[n];let o=this.resources.get(a==null?void 0:a.value);if(o)i[n]=o;else{const h=a==null?void 0:a.value,l=h?[h.width,h.height]:(a==null?void 0:a.size)||r.size;let c={label:r.label,size:l,mipLevelCount:r.mipLevelCount||1,dimension:r.dimension||"2d",format:r.format,usage:r.usage};r.viewFormat&&(c.viewFormats=[r.viewFormat]),o=E.createTexture(c),h&&(E.queue.copyExternalImageToTexture({source:h,flipY:(a==null?void 0:a.flipY)||!1},{texture:o},l),this.resources.set(h,o)),i[n]=o}break}case"cube-texture":{const a=e[n];if(a!=null&&a.value){if(a.value.length!=6)throw new Error("Array Length of cube-texture is Not 6")}else if(a!=null&&a.size&&a.size[2]!=6)throw new Error("Array Length of cube-texture is Not 6")}case"texture-array":{const a=e[n];let o=this.resources.get(a==null?void 0:a.value);if(o)i[n]=o;else{const h=a==null?void 0:a.value,l=h?[h[0].width,h[0].height,h.length]:(a==null?void 0:a.size)||r.size;let c={label:r.label,size:l,mipLevelCount:r.mipLevelCount||1,dimension:r.dimension||"2d",format:r.format,usage:r.usage};if(r.viewFormat&&(c.viewFormats=[r.viewFormat]),o=E.createTexture(c),h){for(let d=0;d<h.length;d++)E.queue.copyExternalImageToTexture({source:h[d],flipY:(a==null?void 0:a.flipY[d])||!1},{texture:o,origin:[0,0,d]},[l[0],l[1],1]);this.resources.set(h,o)}i[n]=o}break}default:throw new Error("Resource Type Not Support")}}return i}};let J=ui;T(J,"Formats",{});class el{constructor(){}createLayout(t,e=void 0){let i=[],s=0;for(const n of t){if(!J.Formats[n])throw new Error(`Resource Attribute Not Exist: ${n}`);switch(J.Formats[n].type){case"buffer":{i.push({binding:s,visibility:J.Formats[n].visibility,buffer:J.Formats[n].layout});break}case"sampler":{i.push({binding:s,visibility:J.Formats[n].visibility,sampler:J.Formats[n].layout});break}case"texture":case"texture-array":case"cube-texture":{i.push({binding:s,visibility:J.Formats[n].visibility,texture:J.Formats[n].layout});break}default:throw new Error("Resource Type Not Support")}s++}return E.createBindGroupLayout({entries:i,label:e})}create(t,e,i=null,s=void 0){let n;i?n=i:n=this.createLayout(t,s);let r=[],a=0;for(const l of t){const c=J.Formats[l];if(!c)throw new Error(`Resource Attribute Not Exist: ${l}`);if(!e[l])throw new Error(`Resource '${l}' Not Exist`);switch(c.type){case"buffer":{r.push({binding:a,resource:{buffer:e[l]}});break}case"sampler":{r.push({binding:a,resource:e[l]});break}case"texture":case"texture-array":case"cube-texture":{r.push({binding:a,resource:e[l].createView({format:c.viewFormat||c.format,dimension:c.layout.viewDimension||"2d"})});break}default:throw new Error("Resource Type Not Support")}a++}let o;s?o={label:s,layout:n,entries:r}:o={layout:n,entries:r};let h=E.createBindGroup(o);return{layout:n,group:h}}}const qi=new tl,fi=new J,Yi=new el,yr=2048;class xr{constructor(t,e){T(this,"camera");T(this,"light");T(this,"resourceAttributes");T(this,"resourceCPUData");T(this,"resource");this.camera=t,this.light=e}static RegisterResourceFormats(){J.RegisterFormats({renderDepthMap:{type:"texture",label:"Render Depth Map",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,size:[rt.width,rt.height],dimension:"2d",format:"depth32float"},frameResult:{type:"texture",label:"Render Frame Result",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,size:[rt.width,rt.height],dimension:ie,format:"depth32float"},camera:{type:"buffer",label:"Camera Structure",visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,layout:{type:"uniform"}},directionalLight:{type:"buffer",label:"Directional Light Structure",visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,layout:{type:"uniform"}},linearSampler:{type:"sampler",label:"Linear Sampler",visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,magFilter:"linear",minFilter:"linear",layout:{type:"filtering"}},envMap:{type:"cube-texture",label:"Skybox Map",visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT,size:[yr,yr,6],dimension:"2d",mipLevelCount:1,format:"rgba8unorm",viewFormat:"rgba8unorm-srgb",layout:{sampleType:"float",viewDimension:"cube"}}})}initCameraResource(){let t=2*this.camera.near*Math.tan(Math.PI/180*.5*this.camera.fov)/this.camera.zoom,e=this.camera.near,i=this.camera.far,s=this.camera.aspect*t/e,n=-t/e,r=(i-e)/(e*i),a=1/i,o=new Float32Array(4+16*3+4);return o.set([s,n,r,a],4+16*3),o}async initResource(){this.resourceAttributes=["renderDepthMap","camera","directionalLight","envMap","linearSampler"];const t=this.light;let e=t.position.clone().sub(t.target.position).normalize(),i=new x(...this.light.color.toArray()).setScalar(this.light.intensity),s=await Qh.loadCubeTexture(["skybox/right.jpg","skybox/left.jpg","skybox/top.jpg","skybox/bottom.jpg","skybox/front.jpg","skybox/back.jpg"]);this.resourceCPUData={camera:{value:this.initCameraResource()},directionalLight:{value:new Float32Array([...e.toArray(),0,...i.toArray(),0])},envMap:{value:await fi.toBitmaps(s.image),flipY:new Array(6).fill(s.flipY)}},this.resource=await fi.createResource(this.resourceAttributes,this.resourceCPUData)}update(){this.camera.position.setFromMatrixPosition(this.camera.matrixWorld);const t=this.resourceCPUData.camera;t.value.set([...this.camera.position.toArray(),0,...this.camera.matrixWorldInverse.toArray(),...this.camera.matrixWorld.toArray(),...this.camera.projectionMatrix.toArray()]),E.queue.writeBuffer(this.resource.camera,0,t.value,0)}}const il=/#([^\s]*)(\s*)/gm;function de(u,...t){const e=[];let i={string:"",elseIsValid:!1,expression:!0},s=1;for(let n=0;n<u.length;++n){const r=u[n],a=r.matchAll(il);let o=0,h=!1;for(const l of a){switch(i.string+=r.substring(o,l.index),l[1]){case"if":if(l.index+l[0].length!=r.length)throw new Error("#if must be immediately followed by a template expression (ie: ${value})");h=!0,e.push(i),s++,i={string:"",elseIsValid:!0,expression:!!t[n]};break;case"elif":if(l.index+l[0].length!=r.length)throw new Error("#elif must be immediately followed by a template expression (ie: ${value})");if(!i.elseIsValid)throw new Error("#elif not preceeded by an #if or #elif");h=!0,i.expression&&e.length!=s&&e.push(i),i={string:"",elseIsValid:!0,expression:!!t[n]};break;case"else":if(!i.elseIsValid)throw new Error("#else not preceeded by an #if or #elif");i.expression&&e.length!=s&&e.push(i),i={string:l[2],elseIsValid:!1,expression:!0};break;case"endif":if(!e.length)throw new Error("#endif not preceeded by an #if");const c=e.length==s?e.pop():i;i=e.pop(),s--,c.expression&&(i.string+=c.string),i.string+=l[2];break;default:i.string+=l[0];break}o=l.index+l[0].length}o!=r.length&&(i.string+=r.substring(o,r.length)),!h&&t.length>n&&(i.string+=t[n])}if(e.length)throw new Error("Mismatched #if/#endif count");return i.string}const sl=`
struct Camera {
  position: vec3<f32>,
  viewMatrix: mat4x4<f32>,
  viewMatrixInverse: mat4x4<f32>,
  projectionMatrix: mat4x4<f32>,
  params: vec4<f32>
};
`,nl=`
struct DirectionalLight {
  direction: vec3<f32>,
  color: vec3<f32>
};
`,rl=`
struct SphereMaterial {
  sphereRadius: f32,
  metalness: f32,
  specularIntensity: f32,
  roughness: f32,
  color: vec3<f32>
};
`,pt={Camera:sl,DirectionalLight:nl,SphereMaterial:rl},al=`
fn sRGBGammaEncode(color: vec3<f32>) -> vec3<f32> {
  return mix(
    color.rgb * 12.92,                                    // x <= 0.0031308
    pow(color.rgb, vec3<f32>(0.41666)) * 1.055 - 0.055,   // x >  0.0031308
    saturate(sign(color.rgb - 0.0031308))
  );
}
`,ln={sRGBGammaEncode:al},ol=de`

${pt.Camera}
${pt.SphereMaterial}

struct VertexInput {
  @builtin(instance_index) instanceIndex: u32,
  @location(0) position: vec3<f32>,
  @location(1) uv: vec2<f32>,
};

struct VertexOutput {
  @builtin(position) position: vec4<f32>,
  @location(0) @interpolate(perspective, center) vPositionCam: vec4<f32>,
  @location(1) @interpolate(perspective, center) vUv: vec2<f32>,
};

@group(0) @binding(0) var<uniform> camera: Camera;
@group(0) @binding(1) var<uniform> material: SphereMaterial;
@group(0) @binding(2) var<storage> instancePositions: array<vec3<f32>>;

@vertex
fn main(input: VertexInput) -> VertexOutput {
  let centerPositonCam = camera.viewMatrix * vec4<f32>(instancePositions[input.instanceIndex], 1.0);
  let positionCam = centerPositonCam + vec4<f32>(input.position * material.sphereRadius, 0.0);
  let positionScreen = camera.projectionMatrix * positionCam;
  return VertexOutput(
    positionScreen, positionCam, input.uv
  );
}

`,hl=de`

${pt.Camera}
${pt.DirectionalLight}
${pt.SphereMaterial}

struct FragmentInput {
  @location(0) @interpolate(perspective, center) vPositionCam: vec4<f32>,
  @location(1) @interpolate(perspective, center) vUv: vec2<f32>,
};

struct FragmentOutput {
  @builtin(frag_depth) depth: f32,
  @location(0) color: vec4<f32>
};

@group(0) @binding(0) var<uniform> camera: Camera;
@group(0) @binding(1) var<uniform> material: SphereMaterial;
@group(0) @binding(3) var<uniform> light: DirectionalLight;

${ln.sRGBGammaEncode}

@fragment
fn main(input: FragmentInput) -> FragmentOutput {

  // caculate normal from uv
  var normalCam = vec4<f32>(input.vUv * 2.0 - 1.0, 0.0, 0.0);
  let radius2 = dot(normalCam.xy, normalCam.xy);
  if (radius2 > 1.0) { discard; }
  normalCam.z = sqrt(1.0 - radius2);
  let normalWorld = camera.viewMatrixInverse * normalCam; // camera space normal -> world space normal

  // caculate depth
  let fragPosCam = input.vPositionCam + normalCam * material.sphereRadius;
  let positionClip = camera.projectionMatrix * fragPosCam;
  let depth = positionClip.z / positionClip.w;

  // simple diffuse shading
  let NoL = saturate(dot(normalize(normalWorld.xyz), light.direction));
  let irradiance = NoL * light.color;
  let diffuse = (irradiance + 0.02) * 0.3183098861837907 * material.color; // RECIPROCAL_PI

  return FragmentOutput(
    depth, vec4<f32>(sRGBGammaEncode(diffuse), 1.0)
  );
}

`,cn=class{constructor(t){T(this,"radius");T(this,"spriteMesh");T(this,"simulator");T(this,"vertexShaderCode");T(this,"fragmentShaderCode");T(this,"vertexCount");T(this,"vertexBufferAttributes");T(this,"vertexBufferData");T(this,"vertexBuffers");T(this,"resourceAttributes");T(this,"resourceCPUData");T(this,"resource");T(this,"vertexBufferLayout");T(this,"bindGroupLayout");T(this,"bindGroup");T(this,"renderPipeline");this.vertexShaderCode=ol,this.fragmentShaderCode=hl,this.simulator=t,this.radius=.03,this.spriteMesh=new Ue(new Zs(1,1),new Ir({color:302836}))}static RegisterResourceFormats(){J.RegisterFormats(cn.ResourceFormats)}initVertexBuffer(){this.vertexBufferAttributes=["position","uv"],this.vertexBufferData={position:this.spriteMesh.geometry.attributes.position.array,uv:this.spriteMesh.geometry.attributes.uv.array},this.spriteMesh.geometry.index?(this.vertexBufferAttributes.push("index"),this.vertexBufferData.index=this.spriteMesh.geometry.index.array,this.vertexCount=this.spriteMesh.geometry.index.count):this.vertexCount=this.spriteMesh.geometry.attributes.position.count,this.vertexBufferLayout=qi.createLayout(this.vertexBufferAttributes),this.vertexBuffers=qi.createResource(this.vertexBufferAttributes,this.vertexBufferData)}async initGroupResource(t){const e=this.spriteMesh.material;this.resourceAttributes=["material","particlePosition"],this.resourceCPUData={material:{value:new Float32Array([this.radius,e.metalness,e.specularIntensity,e.roughness,...e.color.toArray(),0])}},this.resource=await fi.createResource(["material"],this.resourceCPUData),this.resource.particlePosition=this.simulator.particlePositionBuffer,this.initBindGroup(t)}initBindGroup(t){this.bindGroupLayout=E.createBindGroupLayout({label:"Particle Rendering Pipeline Bind Group Layout",entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:2,visibility:GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]}),this.bindGroup=E.createBindGroup({label:"Particle Rendering Pipeline Bind Group",layout:this.bindGroupLayout,entries:[{binding:0,resource:{buffer:t.camera}},{binding:1,resource:{buffer:this.resource.material}},{binding:2,resource:{buffer:this.simulator.particlePositionBuffer}},{binding:3,resource:{buffer:t.directionalLight}}]})}async initPipeline(){this.renderPipeline=await E.createRenderPipelineAsync({label:"Render Pipeline",layout:E.createPipelineLayout({bindGroupLayouts:[this.bindGroupLayout]}),vertex:{module:E.createShaderModule({code:this.vertexShaderCode}),entryPoint:"main",buffers:this.vertexBufferLayout},fragment:{module:E.createShaderModule({code:this.fragmentShaderCode}),entryPoint:"main",targets:[{format:ie}]},primitive:{topology:"triangle-list",cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"greater",format:"depth32float"}})}async setRenderBundle(t){t.setPipeline(this.renderPipeline);let e=0,i=!1;for(const s of this.vertexBufferAttributes)s==="index"?(t.setIndexBuffer(this.vertexBuffers.index,"uint16"),i=!0):(t.setVertexBuffer(e,this.vertexBuffers[s]),e++);t.setBindGroup(0,this.bindGroup),i?t.drawIndexed(this.vertexCount,this.simulator.particleCount):t.draw(this.vertexCount,this.simulator.particleCount)}};let hi=cn;T(hi,"ResourceFormats",{material:{type:"buffer",label:"Material Structure",visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,layout:{type:"uniform"}}});const ll=`

${pt.Camera}
${pt.DirectionalLight}
${pt.SphereMaterial}

struct FragmentInput {
  @location(0) @interpolate(perspective, center) vPositionCam: vec4<f32>,
  @location(1) @interpolate(perspective, center) vUv: vec2<f32>,
};

struct FragmentOutput {
  @builtin(frag_depth) frag_depth: f32,
  @location(0) depthCam: vec4<f32>
};

@group(0) @binding(0) var<uniform> camera: Camera;
@group(0) @binding(1) var<uniform> material: SphereMaterial;
@group(0) @binding(3) var<uniform> light: DirectionalLight;

@fragment
fn main(input: FragmentInput) -> FragmentOutput {

  // caculate normal from uv
  var normalCam = vec4<f32>(input.vUv * 2.0 - 1.0, 0.0, 0.0);
  let radius2 = dot(normalCam.xy, normalCam.xy);
  if (radius2 > 1.0) { discard; }
  normalCam.z = sqrt(1.0 - radius2);

  // caculate depth
  let positionCam = input.vPositionCam + normalCam * material.sphereRadius;
  let positionClip = camera.projectionMatrix * positionCam;
  let depth = positionClip.z / positionClip.w;
  let depthCam = -positionCam.z / positionCam.w;

  return FragmentOutput( depth, vec4<f32>(depthCam, 0.0, 0.0, 1.0) );

}

`,cl=`

${pt.Camera}
${pt.DirectionalLight}
${pt.SphereMaterial}

struct FragmentInput {
  @location(0) @interpolate(perspective, center) vPositionCam: vec4<f32>,
  @location(1) @interpolate(perspective, center) vUv: vec2<f32>,
};

struct FragmentOutput {
  @location(0) volume: f32
};

@group(0) @binding(0) var<uniform> camera: Camera;
@group(0) @binding(1) var<uniform> material: SphereMaterial;
@group(0) @binding(3) var<uniform> light: DirectionalLight;

@fragment
fn main(input: FragmentInput) -> FragmentOutput {

  // caculate normal from uv
  var normalCam = vec4<f32>(input.vUv * 2.0 - 1.0, 0.0, 0.0);
  let radius2 = dot(normalCam.xy, normalCam.xy);
  if (radius2 > 1.0) { discard; }

  // caculate volume // sigma = 0.5
  let volume = exp(-radius2 * 2.0) * 0.2;

  return FragmentOutput( volume );
}

`;class ul extends hi{constructor(e){super(e);T(this,"depthRenderPipeline");T(this,"volumeRenderPipeline");T(this,"depthRenderBundle");T(this,"volumeRenderBundle");T(this,"depthStencilMap")}async initPipeline(){this.depthRenderPipeline=await E.createRenderPipelineAsync({label:"Sprite Particle Depth Render Pipeline",layout:E.createPipelineLayout({bindGroupLayouts:[this.bindGroupLayout]}),vertex:{module:E.createShaderModule({code:this.vertexShaderCode}),entryPoint:"main",buffers:this.vertexBufferLayout},fragment:{module:E.createShaderModule({code:ll}),entryPoint:"main",targets:[{format:"r32float"}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"greater",format:"depth32float"}}),this.volumeRenderPipeline=await E.createRenderPipelineAsync({label:"Sprite Particle Depth Render Pipeline",layout:E.createPipelineLayout({bindGroupLayouts:[this.bindGroupLayout]}),vertex:{module:E.createShaderModule({code:this.vertexShaderCode}),entryPoint:"main",buffers:this.vertexBufferLayout},fragment:{module:E.createShaderModule({code:cl}),entryPoint:"main",targets:[{format:"r16float",writeMask:GPUColorWrite.RED,blend:{color:{operation:"add",srcFactor:"one",dstFactor:"one"},alpha:{operation:"add",srcFactor:"one",dstFactor:"one"}}}]},primitive:{topology:"triangle-list",cullMode:"back"}})}setRenderCommands(e,i){e.setPipeline(i);let s=0,n=!1;for(const r of this.vertexBufferAttributes)r==="index"?(e.setIndexBuffer(this.vertexBuffers.index,"uint16"),n=!0):(e.setVertexBuffer(s,this.vertexBuffers[r]),s++);e.setBindGroup(0,this.bindGroup),n?e.drawIndexed(this.vertexCount,this.simulator.particleCount):e.draw(this.vertexCount,this.simulator.particleCount)}initRenderBundle(){this.depthStencilMap=E.createTexture({size:[rt.width,rt.height],format:"depth32float",usage:GPUTextureUsage.RENDER_ATTACHMENT});let e=E.createRenderBundleEncoder({colorFormats:["r32float"],depthStencilFormat:"depth32float"});this.setRenderCommands(e,this.depthRenderPipeline),this.depthRenderBundle=e.finish(),e=E.createRenderBundleEncoder({colorFormats:["r16float"]}),this.setRenderCommands(e,this.volumeRenderPipeline),this.volumeRenderBundle=e.finish()}render(e,i,s){const n=e.beginRenderPass({colorAttachments:[{view:i.createView(),clearValue:{r:0,g:0,b:0,a:0},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:this.depthStencilMap.createView(),depthClearValue:0,depthLoadOp:"clear",depthStoreOp:"store"}});n.executeBundles([this.depthRenderBundle]),n.end();const r=e.beginRenderPass({colorAttachments:[{view:s.createView(),clearValue:{r:0,g:0,b:0,a:0},loadOp:"clear",storeOp:"store"}]});r.executeBundles([this.volumeRenderBundle]),r.end()}}const dl=`

override width: u32;
override height: u32;

@group(0) @binding(0) var srcTexture: texture_2d<f32>;
@group(0) @binding(1) var destTexture: texture_storage_2d<r32float, write>;
@group(0) @binding(2) var<uniform> filterDirection: vec2<i32>;
@group(0) @binding(3) var<uniform> filterSize: i32;

@compute @workgroup_size(4, 4, 1)
fn main(@builtin(global_invocation_id) global_index : vec3<u32>) {

  if (global_index.x >= width || global_index.y >= height) { return; }
  let coord = vec2<i32>(global_index.xy);
  let val = textureLoad(srcTexture, coord, 0).r;

  if (val > 0.0) {
    var val_sum = 0.0; var weight_sum = 0.0;
    var sample_val: f32; var sample_weight: f32;
    var r: f32;
    for (var i: i32 = -filterSize; i <= filterSize; i++) {
      sample_val = textureLoad(srcTexture, coord + i * filterDirection, 0).r;
      if (sample_val == 0.0) { continue; }

      // spatial domain
      r = f32(i) / 10.0; // 6.0
      sample_weight = exp(-r * r);

      // range domain;
      r = (sample_val - val) / 0.5; // 0.1
      sample_weight = sample_weight * exp(-r * r);

      val_sum = val_sum + sample_val * sample_weight;
      weight_sum = weight_sum + sample_weight;
    }

    if (sample_weight > 0.0) {
      textureStore(
        destTexture, global_index.xy, 
        vec4<f32>(val_sum / weight_sum, 0.0, 0.0, 0.0)
      );
    }
  }
  else {
    textureStore( destTexture, global_index.xy, vec4<f32>(0.0) );
  }
  return;

}

`;class pl{constructor(){T(this,"computeShaderCode");T(this,"textureSize");T(this,"filterTexture");T(this,"tempTexture");T(this,"filterSize");T(this,"filterSizeBuffer");T(this,"bindGroupLayout");T(this,"bindGroupX");T(this,"bindGroupY");T(this,"pipeline");this.computeShaderCode=dl}setTexture(t,e){this.filterTexture=t,this.textureSize=e,this.tempTexture=E.createTexture({size:this.textureSize,format:"r32float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING}),this.filterSize=new Int32Array(1),this.filterSizeBuffer=E.createBuffer({size:4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM})}createFilterDirBuffer(){const t={size:8,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM},e=E.createBuffer(t),i=E.createBuffer(t),s=new Int32Array(2);s.set([1,0]),E.queue.writeBuffer(e,0,s,0);const n=new Int32Array(2);return n.set([0,1]),E.queue.writeBuffer(i,0,n,0),{filterDirBufferX:e,filterDirBufferY:i}}initBindGroup(){this.bindGroupLayout=E.createBindGroupLayout({label:"Filter Pipeline Bind Group Layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},{binding:1,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"r32float",access:"write-only"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]});const t=this.filterTexture.createView(),e=this.tempTexture.createView(),{filterDirBufferX:i,filterDirBufferY:s}=this.createFilterDirBuffer();this.bindGroupX=E.createBindGroup({label:"Filter Pipeline Bind Group (X-axis)",layout:this.bindGroupLayout,entries:[{binding:0,resource:t},{binding:1,resource:e},{binding:2,resource:{buffer:i}},{binding:3,resource:{buffer:this.filterSizeBuffer}}]}),this.bindGroupY=E.createBindGroup({label:"Filter Pipeline Bind Group (Y-axis)",layout:this.bindGroupLayout,entries:[{binding:0,resource:e},{binding:1,resource:t},{binding:2,resource:{buffer:s}},{binding:3,resource:{buffer:this.filterSizeBuffer}}]})}async initPipeline(){this.pipeline=await E.createComputePipelineAsync({label:"Filter Pipeline",layout:E.createPipelineLayout({bindGroupLayouts:[this.bindGroupLayout]}),compute:{module:E.createShaderModule({code:this.computeShaderCode}),entryPoint:"main",constants:{width:this.textureSize[0],height:this.textureSize[1]}}})}setFilterSize(t){this.filterSize.set([t]),E.queue.writeBuffer(this.filterSizeBuffer,0,this.filterSize,0)}execute(t){const e=t.beginComputePass();e.setPipeline(this.pipeline),e.setBindGroup(0,this.bindGroupX),e.dispatchWorkgroups(this.textureSize[0]/4,this.textureSize[1]/4),e.setBindGroup(0,this.bindGroupY),e.dispatchWorkgroups(this.textureSize[0]/4,this.textureSize[1]/4),e.end()}}const fl=`

override screenWidth: f32;
override screenHeight: f32;

struct VertOutput {
  @builtin(position) position: vec4<f32>,
  @location(0) @interpolate(linear, center) coord: vec4<f32>,
};

const coords = array<vec2<f32>, 4>(
  vec2<f32>(-1.0, -1.0), // Bottom Left
  vec2<f32>( 1.0, -1.0), // Bottom Right
  vec2<f32>(-1.0,  1.0), // Top Left
  vec2<f32>( 1.0,  1.0)  // Top Right
);

@vertex
fn main(@builtin(vertex_index) index: u32) -> VertOutput {
  let coord = coords[index];
  let position = vec4<f32>(coord, 0.0, 1.0);
  let uv = coord * vec2<f32>(0.5, -0.5) + 0.5; // https://www.w3.org/TR/webgpu/#coordinate-systems
  let gbufferCoord = vec4<f32>(uv, uv * vec2<f32>(screenWidth, screenHeight));
  return VertOutput(
    position, gbufferCoord
  );
}

`,ml=`

${pt.Camera}
${pt.DirectionalLight}

struct FragInput {
  @location(0) @interpolate(linear, center) coord: vec4<f32>,
};

struct FragOutput {
  @location(0) color: vec4<f32>,
};

@group(0) @binding(0) var<uniform> camera: Camera;
@group(0) @binding(1) var<uniform> light: DirectionalLight;
@group(0) @binding(2) var linearSampler: sampler;
@group(0) @binding(3) var fluidDepthMap: texture_2d<f32>;
@group(0) @binding(4) var fluidVolumeMap: texture_2d<f32>;
@group(0) @binding(5) var envMap: texture_cube<f32>;

${ln.sRGBGammaEncode}

// fn linearEyeDepth(z: f32) -> f32 {
//   return 1.0 / dot(camera.params.zw, vec2<f32>(z, 1.0));
// }

// fn uvToEye(uv: vec2<f32>, z: f32) -> vec3<f32> {
//   let depthEye = linearEyeDepth(z); // Z coordinate of eye space is negtive
//   return vec3<f32>(
//     (uv - 0.5) * camera.params.xy * depthEye,
//     -depthEye
//   );
// }

fn getNormal(positionEye: vec3<f32>) -> vec3<f32> {
  let ddx = dpdx(positionEye);
  let ddy = dpdy(positionEye);
  let normalEye = normalize(cross(-ddx, ddy));
  return normalEye;
}

fn getPosition(uv: vec2<f32>, depthEye: f32) -> vec3<f32> {
  return vec3<f32>(
    (uv - 0.5) * camera.params.xy * depthEye, -depthEye
  );
}

fn diffuseShading(normalWorld: vec3<f32>) -> vec3<f32> {
  // simple diffuse shading
  let NoL = saturate(dot(normalWorld, light.direction));
  let irradiance = NoL * light.color;
  return (irradiance + 0.02) * 0.3183098861837907 * vec3<f32>(4, 142, 219) / 256.0; // RECIPROCAL_PI
}

fn Fresnel_Schlick(F0: vec3<f32>, VoH: f32) -> vec3<f32> {
  let Fc = exp2((-5.55473 * VoH - 6.98316) * VoH);
  return saturate(50.0 * F0) * Fc + (1.0 - Fc) * F0;
}

fn shading(
  normalEye: vec3<f32>,
  positionEye: vec3<f32>,
  thickness: f32
) -> vec3<f32> {

  let viewDirEye = normalize(-positionEye);
  let VoN = saturate(dot(viewDirEye, normalEye));
  let fresnel = Fresnel_Schlick(vec3<f32>(0.02), VoN); // F0 of water is 0.02
  let attenuate = max(exp(-thickness * 0.5), 0.2);
  let tintColor = vec3<f32>(6.0, 105.0, 217.0) / 256.0;

  let reflectDirEye = reflect(-viewDirEye, normalEye);
  let refractDirEye = refract(-viewDirEye, normalEye, 0.7501875); // 1.0 / 1.333

  let normalWorld = (camera.viewMatrixInverse * vec4<f32>(normalEye, 0.0)).xyz;
  let reflectDirWorld = (camera.viewMatrixInverse * vec4<f32>(reflectDirEye, 0.0)).xyz;
  let refractDirWorld = (camera.viewMatrixInverse * vec4<f32>(refractDirEye, 0.0)).xyz;

  let normalColor = textureSample(envMap, linearSampler, normalWorld).rgb;
  let reflectColor = textureSample(envMap, linearSampler, reflectDirWorld).rgb;
  let refractColor = textureSample(envMap, linearSampler, refractDirWorld).rgb;

  let color = mix(
    mix(tintColor, refractColor, attenuate),
    reflectColor, fresnel
  );
  return color;

}

@fragment
fn main(input: FragInput) -> FragOutput {

  let frameCoord = vec2<u32>(floor(input.coord.zw));
  let depthEye = textureLoad(fluidDepthMap, frameCoord, 0).r;
  if (depthEye == 0.0) { discard; }
  let fluidVolume = textureSample(fluidVolumeMap, linearSampler, input.coord.xy).r;
  let positionEye = getPosition(input.coord.xy, depthEye);
  let normalEye = getNormal(positionEye);
  let color = shading(normalEye, positionEye, fluidVolume);

  return FragOutput(
    vec4<f32>(sRGBGammaEncode(color), 1.0)
  );

}

`;class gl{constructor(){T(this,"vertexShaderCode");T(this,"fragmentShaderCode");T(this,"bindGroupLayout");T(this,"bindGroup");T(this,"renderPipeline");T(this,"renderBundle");this.vertexShaderCode=fl,this.fragmentShaderCode=ml}initBindGroup(t){const e=Yi.create(["camera","directionalLight","linearSampler","fluidDepthMap","fluidVolumeMap","envMap"],t);this.bindGroupLayout=e.layout,this.bindGroup=e.group}async initPipeline(){this.renderPipeline=await E.createRenderPipelineAsync({label:"Postprocess Pipeline",layout:E.createPipelineLayout({bindGroupLayouts:[this.bindGroupLayout]}),vertex:{module:E.createShaderModule({code:this.vertexShaderCode}),constants:{screenWidth:rt.width,screenHeight:rt.height},entryPoint:"main"},fragment:{module:E.createShaderModule({code:this.fragmentShaderCode}),entryPoint:"main",targets:[{format:ie,writeMask:GPUColorWrite.RED|GPUColorWrite.GREEN|GPUColorWrite.BLUE,blend:{color:{operation:"add",srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{operation:"add",srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"}}}]},primitive:{topology:"triangle-strip",cullMode:"none"}})}initRenderBundle(){let t=E.createRenderBundleEncoder({colorFormats:[ie]});t.setPipeline(this.renderPipeline),t.setBindGroup(0,this.bindGroup),t.draw(4),this.renderBundle=t.finish()}render(t,e){const i=t.beginRenderPass({colorAttachments:[{view:e,loadOp:"load",storeOp:"store"}]});i.executeBundles([this.renderBundle]),i.end()}}class br{constructor(t,e){T(this,"camera");T(this,"fluidParticles");T(this,"textureCopy");T(this,"textureFilter");T(this,"postprocess");T(this,"resourceAttributes");T(this,"resourceCPUData");T(this,"resource");T(this,"renderDepthMap");T(this,"particleRenderBundle");T(this,"postprocessBundle");this.camera=e,this.fluidParticles=new ul(t),this.textureFilter=new pl,this.postprocess=new gl}static RegisterResourceFormats(){J.RegisterFormats({fluidDepthMap:{type:"texture",label:"Fluid Depth Storage Map for Filtering",visibility:GPUShaderStage.FRAGMENT,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT,size:[rt.width,rt.height],dimension:"2d",format:"r32float",layout:{sampleType:"unfilterable-float",viewDimension:"2d"}},fluidVolumeMap:{type:"texture",label:"Fluid Volume Map",visibility:GPUShaderStage.FRAGMENT,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,size:[rt.width/2,rt.height/2],dimension:"2d",format:"r16float",layout:{sampleType:"float",viewDimension:"2d"}}})}async initResource(t){this.renderDepthMap=t.renderDepthMap,this.resourceAttributes=["fluidDepthMap","fluidVolumeMap"],this.resource=await fi.createResource(this.resourceAttributes,{}),this.fluidParticles.initVertexBuffer(),await this.fluidParticles.initGroupResource(t),await this.fluidParticles.initPipeline(),this.fluidParticles.initRenderBundle(),this.textureFilter.setTexture(this.resource.fluidDepthMap,[rt.width,rt.height]),this.textureFilter.initBindGroup(),await this.textureFilter.initPipeline(),this.postprocess.initBindGroup({...t,...this.resource}),await this.postprocess.initPipeline(),this.postprocess.initRenderBundle()}render(t,e){this.textureFilter.setFilterSize(10),this.fluidParticles.render(t,this.resource.fluidDepthMap,this.resource.fluidVolumeMap),this.textureFilter.execute(t),this.postprocess.render(t,e)}}const yl=`
struct Camera {
  position: vec3<f32>,
  viewMatrix: mat4x4<f32>,
  viewMatrixInverse: mat4x4<f32>,
  projectionMatrix: mat4x4<f32>,
  params: vec4<f32>
};
@group(0) @binding(0) var<uniform> camera: Camera;

struct VertOutput {
  @builtin(position) position: vec4<f32>,
  @location(0) vPosition: vec3<f32>,
};

@vertex
fn main(@location(0) position: vec3<f32>) -> VertOutput {
  let positionCamera = camera.viewMatrix * vec4<f32>(position, 0.0);
  let positionNDC = camera.projectionMatrix * vec4<f32>(positionCamera.xyz, 1.0);
  let positionReverseZ = vec4<f32>(positionNDC.xy, 0.0, positionNDC.w);
  return VertOutput(positionReverseZ, position);
}
`,xl=`
@group(0) @binding(1) var linearSampler: sampler;
@group(0) @binding(2) var envMap: texture_cube<f32>;

${ln.sRGBGammaEncode}

@fragment
fn main(
  @builtin(position) position : vec4<f32>,
  @location(0) fragPosition : vec3<f32>,
) -> @location(0) vec4<f32> {
  let color_linear = textureSampleLevel(envMap, linearSampler, fragPosition, 0);
  return vec4<f32>(sRGBGammaEncode(color_linear.xyz), 1.0);
}
`;class bl{constructor(){T(this,"vertexShaderCode");T(this,"fragmentShaderCode");T(this,"vertexCount");T(this,"vertexBufferAttributes");T(this,"vertexBuffers");T(this,"vertexBufferLayout");T(this,"bindGroupLayout");T(this,"bindGroup");T(this,"renderPipeline");this.vertexShaderCode=yl,this.fragmentShaderCode=xl}initVertexBuffer(){const t=["position","index"],e=new Float32Array([-1,1,-1,-1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,-1]),i=new Uint16Array([3,6,7,3,2,6,0,5,1,0,4,5,0,1,2,0,2,3,4,6,5,4,7,6,1,5,6,1,6,2,0,7,4,0,3,7]);this.renderPipeline=void 0,this.vertexCount=36,this.vertexBufferAttributes=t,this.vertexBufferLayout=qi.createLayout(this.vertexBufferAttributes),this.vertexBuffers=qi.createResource(t,{position:e,index:i})}async initGroupResource(t){const e=Yi.create(["camera","linearSampler","envMap"],t);this.bindGroupLayout=e.layout,this.bindGroup=e.group}async initPipeline(){this.renderPipeline=await E.createRenderPipelineAsync({label:"Skybox Render Pipeline",layout:E.createPipelineLayout({bindGroupLayouts:[this.bindGroupLayout]}),vertex:{module:E.createShaderModule({code:this.vertexShaderCode}),entryPoint:"main",buffers:this.vertexBufferLayout},fragment:{module:E.createShaderModule({code:this.fragmentShaderCode}),entryPoint:"main",targets:[{format:ie}]},primitive:{topology:"triangle-list",cullMode:"front"},depthStencil:{depthWriteEnabled:!0,depthCompare:"greater-equal",format:"depth32float"}})}async setRenderBundle(t){t.setPipeline(this.renderPipeline),t.setIndexBuffer(this.vertexBuffers.index,"uint16"),t.setVertexBuffer(0,this.vertexBuffers.position),t.setBindGroup(0,this.bindGroup),t.drawIndexed(this.vertexCount)}}const un=class{constructor(t=1,e=25){T(this,"particleCount");T(this,"stepCount");T(this,"particlePositionBuffer");this.stepCount=e,this.particleCount=t,this.particlePositionBuffer=E.createBuffer({size:4*this.particleCount*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST})}static RegisterResourceFormats(){J.RegisterFormats(un.ResourceFormats)}};let li=un;T(li,"ResourceFormats",{particlePosition:{type:"buffer",label:"Particle Positions",visibility:GPUShaderStage.COMPUTE,layout:{type:"storage"}}});function wl(u,t){const e=de`
  dpos = (vec3<f32>(vec3<u32>(i, j, k)) - fx) * dx;
  weight = w[i][0] * w[j][1] * w[k][2];
  i = i + base.x; j = j + base.y; k = k + base.z; 

  if ( i >= 0 && i < ${t} && j >= 0 && j < ${t} && k >= 0 && k < ${t} ) {
    v_del = weight * (p_mass * v_p + affine * dpos);
    m_del = weight * p_mass;

    loop {
      let atomic_storage_ptr = &(grid[i][j][k][0]);
      old_val= bitcast<f32>(atomicLoad(atomic_storage_ptr));
      new_val = old_val + v_del.x;
      if ( 
        atomicCompareExchangeWeak(
          atomic_storage_ptr, bitcast<i32>(old_val), bitcast<i32>(new_val)
        ).exchanged
      ) { break; }
    }

    loop {
      let atomic_storage_ptr = &(grid[i][j][k][1]);
      old_val = bitcast<f32>(atomicLoad(atomic_storage_ptr));
      new_val = old_val + v_del.y;
      if ( 
        atomicCompareExchangeWeak(
          atomic_storage_ptr, bitcast<i32>(old_val), bitcast<i32>(new_val)
        ).exchanged
      ) { break; }
    }

    loop {
      let atomic_storage_ptr = &(grid[i][j][k][2]);
      old_val = bitcast<f32>(atomicLoad(atomic_storage_ptr));
      new_val = old_val + v_del.z;
      if ( 
        atomicCompareExchangeWeak(
          atomic_storage_ptr, bitcast<i32>(old_val), bitcast<i32>(new_val)
        ).exchanged
      ) { break; }
    }

    loop {
      let atomic_storage_ptr = &(grid[i][j][k][3]);
      old_val = bitcast<f32>(atomicLoad(atomic_storage_ptr));
      new_val = old_val + m_del;
      if ( 
        atomicCompareExchangeWeak(
          atomic_storage_ptr, bitcast<i32>(old_val), bitcast<i32>(new_val)
        ).exchanged
      ) {
        break; 
      }
    }
  }
`;return de`

override dx: f32;
override dt: f32;
override p_vol: f32;
override p_mass: f32;
override E: f32;

struct Particle {
  v: vec4<f32>,
  C: mat3x3<f32>
};

@group(0) @binding(0) var<storage, read_write> x: array<vec3<f32>, ${u}>;
@group(0) @binding(1) var<storage, read_write> particle_set: array<Particle, ${u}>;
@group(0) @binding(2) var<storage, read_write> grid: array<array<array<array<atomic<i32>, 4>, ${t}>, ${t}>, ${t}>;

const identity_mat3x3 = mat3x3<f32>(
  1.0, 0.0, 0.0,
  0.0, 1.0, 0.0,
  0.0, 0.0, 1.0
);

@compute @workgroup_size(4, 1, 1)
fn main(@builtin(global_invocation_id) global_index : vec3<u32>) {

  let p = global_index.x;
  if (p >= ${u}) { return; }

  let particle = particle_set[p];
  let x_p = x[p];
  let v_p = particle.v.xyz;
  let C_p = particle.C;
  let J_p = particle.v.w * (1.0 + dt * (C_p[0][0] + C_p[1][1] + C_p[2][2]));

  let Xp = x_p / dx;
  let base = vec3<u32>(Xp - 0.5);
  let fx = Xp - vec3<f32>(base);
  let w = mat3x3<f32>(
    0.5 * (1.5 - fx) * (1.5 - fx), 
    0.75 - (fx - 1.0) * (fx - 1.0), 
    0.5 * (fx - 0.5) * (fx - 0.5)
  );

  let stress = -dt * 4.0 * E * p_vol * (J_p - 1.0) / (dx * dx);
  let affine = stress * identity_mat3x3 + p_mass * C_p;

  var i: u32; var j: u32; var k: u32;
  var weight: f32; var dpos: vec3<f32>;
  var old_val: f32; var new_val: f32;
  var v_del: vec3<f32>; var m_del: f32; 

  i = 0; j = 0; k = 0; ${e}
  i = 0; j = 0; k = 1; ${e}
  i = 0; j = 0; k = 2; ${e}
  i = 0; j = 1; k = 0; ${e}
  i = 0; j = 1; k = 1; ${e}
  i = 0; j = 1; k = 2; ${e}
  i = 0; j = 2; k = 0; ${e}
  i = 0; j = 2; k = 1; ${e}
  i = 0; j = 2; k = 2; ${e}
  
  i = 1; j = 0; k = 0; ${e}
  i = 1; j = 0; k = 1; ${e}
  i = 1; j = 0; k = 2; ${e}
  i = 1; j = 1; k = 0; ${e}
  i = 1; j = 1; k = 1; ${e}
  i = 1; j = 1; k = 2; ${e}
  i = 1; j = 2; k = 0; ${e}
  i = 1; j = 2; k = 1; ${e}
  i = 1; j = 2; k = 2; ${e}

  i = 2; j = 0; k = 0; ${e}
  i = 2; j = 0; k = 1; ${e}
  i = 2; j = 0; k = 2; ${e}
  i = 2; j = 1; k = 0; ${e}
  i = 2; j = 1; k = 1; ${e}
  i = 2; j = 1; k = 2; ${e}
  i = 2; j = 2; k = 0; ${e}
  i = 2; j = 2; k = 1; ${e}
  i = 2; j = 2; k = 2; ${e}

  particle_set[p].v.w = J_p;

}

  `}function Ml(u,t){return de`

override dt: f32;
override bound: u32;

@group(0) @binding(0) var<storage, read_write> grid: array<array<array<vec4<f32>, ${t}>, ${t}>, ${t}>;
@group(0) @binding(1) var<storage, read_write> gravity: vec4<f32>;

@compute @workgroup_size(2, 2, 2)
fn main(@builtin(global_invocation_id) global_index : vec3<u32>) {

  let i = global_index.x; let j = global_index.y; let k = global_index.z;
  if (i >= ${t} || j >= ${t} || k >= ${t}) { return; }
  let grid_node = grid[i][j][k];

  // momentum -> velocity
  var velocity = vec4<f32>();
  if (grid_node.w > 0.0) { 
    velocity = grid_node / grid_node.w; 
  }

  // apply gravity
  velocity = velocity + dt * gravity;

  // apply boundary condition
  let max_bound = ${t} - bound;
  if ( (i < bound && velocity.x < 0) || (i >= max_bound && velocity.x > 0) ) {
    velocity.x = 0.0;
  }
  if ( (j < bound && velocity.y < 0) || (j >= max_bound && velocity.y > 0) ) {
    velocity.y = 0.0;
  }
  if ( (k < bound && velocity.z < 0) || (k >= max_bound && velocity.z > 0) ) {
    velocity.z = 0.0;
  }

  grid[i][j][k] = velocity;

}

  `}function vl(u,t){const e=de`
  dpos = (vec3<f32>(vec3<u32>(i, j, k)) - fx) * dx;
  weight = w[i][0] * w[j][1] * w[k][2];
  i = i + base.x; j = j + base.y; k = k + base.z; 
  velocity = grid[i][j][k];
  new_v = new_v + weight * velocity;
  new_C = new_C + inv4_dx2 * weight * mat3x3<f32>(
    velocity.x * dpos,
    velocity.y * dpos,
    velocity.z * dpos
  );
`;return de`

override dx: f32;
override dt: f32;

struct Particle {
  v: vec3<f32>,
  C: mat3x3<f32>
};

@group(0) @binding(0) var<storage, read_write> x: array<vec3<f32>, ${u}>;
@group(0) @binding(1) var<storage, read_write> particle_set: array<Particle, ${u}>;
@group(0) @binding(2) var<storage, read_write> grid: array<array<array<vec3<f32>, ${t}>, ${t}>, ${t}>;

@compute @workgroup_size(4, 1, 1)
fn main(@builtin(global_invocation_id) global_index : vec3<u32>) {

  let p = global_index.x;
  if (p >= ${u}) { return; }

  let x_p = x[p];
  let Xp = x_p / dx;
  let base = vec3<u32>(Xp - 0.5);
  let fx = Xp - vec3<f32>(base);
  let w = mat3x3<f32>(
    0.5 * (1.5 - fx) * (1.5 - fx), 
    0.75 - (fx - 1.0) * (fx - 1.0), 
    0.5 * (fx - 0.5) * (fx - 0.5)
  );

  var i: u32; var j: u32; var k: u32;
  var new_v = vec3<f32>(); var new_C = mat3x3<f32>();
  var weight: f32; var dpos: vec3<f32>;
  var velocity: vec3<f32>;
  let inv4_dx2 = 4.0 / (dx * dx);

  i = 0; j = 0; k = 0; ${e}
  i = 0; j = 0; k = 1; ${e}
  i = 0; j = 0; k = 2; ${e}
  i = 0; j = 1; k = 0; ${e}
  i = 0; j = 1; k = 1; ${e}
  i = 0; j = 1; k = 2; ${e}
  i = 0; j = 2; k = 0; ${e}
  i = 0; j = 2; k = 1; ${e}
  i = 0; j = 2; k = 2; ${e}
  
  i = 1; j = 0; k = 0; ${e}
  i = 1; j = 0; k = 1; ${e}
  i = 1; j = 0; k = 2; ${e}
  i = 1; j = 1; k = 0; ${e}
  i = 1; j = 1; k = 1; ${e}
  i = 1; j = 1; k = 2; ${e}
  i = 1; j = 2; k = 0; ${e}
  i = 1; j = 2; k = 1; ${e}
  i = 1; j = 2; k = 2; ${e}

  i = 2; j = 0; k = 0; ${e}
  i = 2; j = 0; k = 1; ${e}
  i = 2; j = 0; k = 2; ${e}
  i = 2; j = 1; k = 0; ${e}
  i = 2; j = 1; k = 1; ${e}
  i = 2; j = 1; k = 2; ${e}
  i = 2; j = 2; k = 0; ${e}
  i = 2; j = 2; k = 1; ${e}
  i = 2; j = 2; k = 2; ${e}

  particle_set[p].v = new_v;
  particle_set[p].C = new_C;
  x[p] = x_p + dt * new_v;

}

`}const dn=class extends li{constructor(){super(9e3,15);T(this,"pause");T(this,"timeStep");T(this,"gridCount");T(this,"gridLength");T(this,"bound");T(this,"material");T(this,"gravityArray");T(this,"resource");T(this,"P2GComputePipeline");T(this,"GridComputePipeline");T(this,"G2PComputePipeline");T(this,"P2GBindGroup");T(this,"GridBindGroup");this.timeStep=4e-4,this.gridCount=32,this.gridLength=1/32,this.bound=3;const i=1,s=Math.pow(this.gridLength*.5,2);this.material={particleDensity:i,particleVolume:s,particleMass:i*s,E:400},this.gravityArray=new Float32Array(4),this.pause=!1}static _RegisterResourceFormats(){J.RegisterFormats(dn._ResourceFormats)}async initResource(){this.resource=await fi.createResource(["particle","grid","gravity"],{particle:{size:4*4*this.particleCount*Float32Array.BYTES_PER_ELEMENT},grid:{size:4*this.gridCount*this.gridCount*this.gridCount*Float32Array.BYTES_PER_ELEMENT},gravity:{size:4*Float32Array.BYTES_PER_ELEMENT}}),this.resource.particlePosition=this.particlePositionBuffer;let e=new Float32Array(16*this.particleCount),i=new Array(3).fill(0);for(let s=0;s<this.particleCount;s++)e.set(i.map(n=>Math.random()*.4+.15),s*4);E.queue.writeBuffer(this.particlePositionBuffer,0,e,0,4*this.particleCount);for(let s=0;s<this.particleCount;s++)e.set([1],s*16+3);E.queue.writeBuffer(this.resource.particle,0,e,0),this.gravityArray.set([0,-9.8,0,0]),E.queue.writeBuffer(this.resource.gravity,0,this.gravityArray,0)}enableInteraction(){document.addEventListener("keydown",e=>{e.key.toUpperCase()==="W"?this.gravityArray.set([-9.8,0,0,0]):e.key.toUpperCase()==="A"?this.gravityArray.set([0,0,9.8,0]):e.key.toUpperCase()==="S"?this.gravityArray.set([9.8,0,0,0]):e.key.toUpperCase()==="D"?this.gravityArray.set([0,0,-9.8,0]):e.key.toUpperCase()==="Q"?this.gravityArray.set([0,9.8,0,0]):e.key.toUpperCase()==="E"?this.gravityArray.set([0,-9.8,0,0]):e.key.toUpperCase()===" "&&(this.pause=!this.pause)})}async initP2GComputePipeline(){this.P2GComputePipeline=await E.createComputePipelineAsync({label:"MPM P2G Compute Pipeline",layout:E.createPipelineLayout({bindGroupLayouts:[this.P2GBindGroup.layout]}),compute:{module:E.createShaderModule({code:wl(this.particleCount,this.gridCount)}),constants:{dx:this.gridLength,dt:this.timeStep,p_vol:this.material.particleVolume,p_mass:this.material.particleMass,E:this.material.E},entryPoint:"main"}})}async initGridComputePipeline(){this.GridComputePipeline=await E.createComputePipelineAsync({label:"MPM Grid Compute Pipeline",layout:E.createPipelineLayout({bindGroupLayouts:[this.GridBindGroup.layout]}),compute:{module:E.createShaderModule({code:Ml(this.particleCount,this.gridCount)}),constants:{dt:this.timeStep,bound:this.bound},entryPoint:"main"}})}async initG2PComputePipeline(){this.G2PComputePipeline=await E.createComputePipelineAsync({label:"MPM G2P Compute Pipeline",layout:E.createPipelineLayout({bindGroupLayouts:[this.P2GBindGroup.layout]}),compute:{module:E.createShaderModule({code:vl(this.particleCount,this.gridCount)}),constants:{dx:this.gridLength,dt:this.timeStep},entryPoint:"main"}})}async initComputePipeline(){this.P2GBindGroup=Yi.create(["particlePosition","particle","grid"],this.resource),this.GridBindGroup=Yi.create(["grid","gravity"],this.resource),await this.initP2GComputePipeline(),await this.initGridComputePipeline(),await this.initG2PComputePipeline()}run(e){if(this.pause)return;e.clearBuffer(this.resource.grid);const i=e.beginComputePass();i.setPipeline(this.P2GComputePipeline),i.setBindGroup(0,this.P2GBindGroup.group),i.dispatchWorkgroups(Math.ceil(this.particleCount/4)),i.setPipeline(this.GridComputePipeline),i.setBindGroup(0,this.GridBindGroup.group),i.dispatchWorkgroups(Math.ceil(this.gridCount/2),Math.ceil(this.gridCount/2),Math.ceil(this.gridCount/2)),i.setPipeline(this.G2PComputePipeline),i.setBindGroup(0,this.P2GBindGroup.group),i.dispatchWorkgroups(Math.ceil(this.particleCount/4)),i.end()}update(){E.queue.writeBuffer(this.resource.gravity,0,this.gravityArray,0)}async debug(){await this.resource.debug.mapAsync(GPUMapMode.READ);const e=this.resource.debug.getMappedRange();console.log(e);const i=new Float32Array(e);console.log(i);for(let s=0;s<32;s++)s==15&&console.log(i.slice(s*4*32*32,(s+1)*4*32*32));this.resource.debug.unmap()}};let ci=dn;T(ci,"_ResourceFormats",{particle:{type:"buffer",label:"Particle Velocity and Plastic Deformation",visibility:GPUShaderStage.COMPUTE,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,layout:{type:"storage"}},grid:{type:"buffer",label:"Grid Velocity and Mass",visibility:GPUShaderStage.COMPUTE,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,layout:{type:"storage"}},gravity:{type:"buffer",label:"Gravity",visibility:GPUShaderStage.COMPUTE,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,layout:{type:"storage"}},debug:{type:"buffer",label:"Debug",usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}});P.prototype.makePerspective=function(u,t,e,i,s,n){const r=this.elements,a=2*s/(t-u),o=2*s/(e-i),h=(t+u)/(t-u),l=(e+i)/(e-i),c=s/(n-s),d=n*s/(n-s);return r[0]=a,r[4]=0,r[8]=h,r[12]=0,r[1]=0,r[5]=o,r[9]=l,r[13]=0,r[2]=0,r[6]=0,r[10]=c,r[14]=d,r[3]=0,r[7]=0,r[11]=-1,r[15]=0,this};P.prototype.makeOrthographic=function(u,t,e,i,s,n){const r=this.elements,a=1/(t-u),o=1/(e-i),h=1/(n-s),l=(t+u)*a,c=(e+i)*o,d=s*h;return r[0]=2*a,r[4]=0,r[8]=0,r[12]=-l,r[1]=0,r[5]=2*o,r[9]=0,r[13]=-c,r[2]=0,r[6]=0,r[10]=-1*h,r[14]=-d,r[3]=0,r[7]=0,r[11]=0,r[15]=1,this};Cr.prototype.setFromProjectionMatrix=function(u){const t=this.planes,e=u.elements,i=e[0],s=e[1],n=e[2],r=e[3],a=e[4],o=e[5],h=e[6],l=e[7],c=e[8],d=e[9],p=e[10],f=e[11],m=e[12],g=e[13],y=e[14],M=e[15];return t[0].setComponents(r-i,l-a,f-c,M-m).normalize(),t[1].setComponents(r+i,l+a,f+c,M+m).normalize(),t[2].setComponents(r+s,l+o,f+d,M+g).normalize(),t[3].setComponents(r-s,l-o,f-d,M-g).normalize(),t[4].setComponents(r-n,l-h,f-p,M-y).normalize(),t[5].setComponents(n,h,p,y).normalize(),this};let E,ie,rt;class Tl{constructor(t){T(this,"canvas");T(this,"context");T(this,"renderBundle");T(this,"renderDepthMap");T(this,"camera");T(this,"globalResource");T(this,"skybox");T(this,"fluidRender");T(this,"simulator");this.canvas=t}RegisterResourceFormats(){xr.RegisterResourceFormats(),hi.RegisterResourceFormats(),br.RegisterResourceFormats(),li.RegisterResourceFormats(),ci._RegisterResourceFormats()}async initWebGPU(){if(!navigator.gpu)throw new Error("Not Support WebGPU");const t=await navigator.gpu.requestAdapter({powerPreference:"high-performance"});if(!t)throw new Error("No Adapter Found");t.features.forEach(i=>console.log(`Support feature: ${i}`)),E=await t.requestDevice(),console.log(E);const e=this.canvas.getContext("webgpu");if(!e)throw new Error("Can Not Get GPUCanvasContext");this.context=e,rt={width:this.canvas.width,height:this.canvas.height},ie=navigator.gpu.getPreferredCanvasFormat(),e.configure({device:E,usage:GPUTextureUsage.RENDER_ATTACHMENT,format:ie,alphaMode:"opaque"})}async initScene(t,e){this.RegisterResourceFormats(),this.camera=t,this.camera.updateMatrixWorld(),this.camera.updateProjectionMatrix(),this.globalResource=new xr(t,e),await this.globalResource.initResource(),this.renderDepthMap=this.globalResource.resource.renderDepthMap,this.simulator=new ci,await this.simulator.initResource(),await this.simulator.initComputePipeline(),this.simulator.enableInteraction(),this.fluidRender=new br(this.simulator,this.camera),await this.fluidRender.initResource(this.globalResource.resource),this.skybox=new bl,this.skybox.initVertexBuffer(),await this.skybox.initGroupResource(this.globalResource.resource),await this.skybox.initPipeline();const i=E.createRenderBundleEncoder({colorFormats:[ie],depthStencilFormat:"depth32float"});await this.skybox.setRenderBundle(i),this.renderBundle=i.finish()}run(){const t=E.createCommandEncoder();for(let n=0;n<this.simulator.stepCount;n++)this.simulator.run(t);const e=this.context.getCurrentTexture().createView(),i=t.beginRenderPass({colorAttachments:[{view:e,clearValue:{r:0,g:0,b:0,a:0},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:this.renderDepthMap.createView(),depthClearValue:0,depthLoadOp:"clear",depthStoreOp:"store"}});i.executeBundles([this.renderBundle]),i.end(),this.fluidRender.render(t,e);const s=t.finish();E.queue.submit([s])}update(){this.camera.updateMatrixWorld(),this.camera.updateProjectionMatrix(),this.globalResource.update(),this.simulator.update()}}class Sl{constructor(){T(this,"canvas");T(this,"stats");T(this,"clock");T(this,"controller");this.canvas=document.querySelector("canvas");const t=window.devicePixelRatio||1;this.canvas.width=this.canvas.clientWidth*t,this.canvas.height=this.canvas.clientHeight*t,this.controller=new Tl(this.canvas),this.stats=new si,this.stats.showPanel(0),document.body.appendChild(this.stats.dom)}start(){const t=()=>{this.stats.begin(),this.controller.update(),this.controller.run(),this.stats.end(),requestAnimationFrame(t)};t()}async init(){const t=new gi(50,window.innerWidth/window.innerHeight,.1,50);t.position.set(2,2,0),t.lookAt(0,0,0),new Uo(t,this.canvas);let e=new an(16777215,1);e.position.set(0,0,10),await this.controller.initWebGPU(),await this.controller.initScene(t,e)}}const wr=new Sl;wr.init().then(()=>wr.start());
